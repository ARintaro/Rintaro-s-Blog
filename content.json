{"meta":{"title":"Rintaro's Blog","subtitle":"Algorithm and Anime(?","description":"某弱省一弱校高一OIer","author":"Rintaro","url":"http://arintaro.com","root":"/"},"pages":[{"title":"","date":"2019-04-27T09:40:13.536Z","updated":"2019-04-27T07:31:21.041Z","comments":false,"path":"categories/index.html","permalink":"http://arintaro.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-27T09:27:03.030Z","updated":"2019-04-27T08:25:25.513Z","comments":false,"path":"tags/index.html","permalink":"http://arintaro.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Essay/LNOI2019 & 多省联考 游记","date":"2019-04-27T09:01:25.797Z","updated":"2019-04-25T02:08:22.633Z","comments":true,"path":"2019/04/27/Essay/LNOI2019 & 多省联考 游记/","link":"","permalink":"http://arintaro.com/2019/04/27/Essay/LNOI2019 & 多省联考 游记/","excerpt":"","text":"Day1:待更，鸽了","categories":[],"tags":[]},{"title":"","slug":"Detail/综合技巧与实践","date":"2019-04-27T09:01:25.547Z","updated":"2019-04-11T06:23:34.289Z","comments":true,"path":"2019/04/27/Detail/综合技巧与实践/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/综合技巧与实践/","excerpt":"","text":"一、杂项​ 1.值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域 二、STL相关1.algorithm123456789101112131.lower_bound &amp; upper_bound //我就算饿死，死外面，也不会自己写一个二分查找的 int pos = lower_bound(arr+1,arr+n+1,val) - arr; //在有序数组[1,n]中查第一个 &gt;=val的数 // 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater2.unique //常用于离散化 n = unique(arr+1,arr+n+1) - (arr+1); //去重，新元素存在[1,n] 3.inplace_merge merge // 常用于CDQ分治中，不要cdq里套sort了！！ // 数组 arr分为有序的两部分 [1,mid] [mid+1,n] inplace_merge(arr+1,arr+mid+1,arr+n+1); merge(first1,last1,first2,last2,result,compare);4.nth_element //数组中O(n)找第k大，前k个数一定都在[1，k] nth_element(arr+1,arr+k,arr+n+1);5.sort stable_sort // 后一个可以稳定排序 6.reverse // 跟sort传参一样，序列反转 2.vector121.vector的clear不会释放空间，需要释放空间的话，需要: vector&lt;int&gt;().swap(a); // 但是几乎比clear慢一倍 三、NOI Linux相关​ 1.Emacs相关（M为Alt键，C为Ctrl键 M+x输入命令 C+x+k关闭当前窗口 Options-Use CUA Keys (转换复制粘贴快捷键) Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题） Options-Set Default Font - Ubuntu Mono 20-30（变更字体 C-x-2 水平切分当前Buffer, C-x-3 左右切分 命令 Find-file后， ~/.emacs 可以直接打开配置文件 123456789101112131415161718192021(global-linum-mode t) ;;line num 显示行号(setq c-basic-offset 3) ;; 变更缩进(setq default-tab-width 3) (electric-pair-mode t) ;;electric pair 括号补全(electric-layout-mode t)(electric-indent-mode t)(setq-default cursor-type 'bar) ;;光标竖线(show-paren-mode t) ;;show paren 括号配对(global-set-key [f4] 'shell) ;;摁F4进入shell(defun compile-file()(interactive)(compile(format \"g++ -o '%s' '%s' -lm -Wall -g\"(file-name-sans-extension(buffer-name))(buffer-name))))(global-set-key [f5] 'compile-file) ;;摁F5编译(global-set-key [f6] 'gdb) ;;摁F6进入gdb调试(global-set-key (kbd \"C-s\") 'save-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"C-a\") 'mark-the-whole-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"RET\") 'newline-and-indent) ;;回车自动缩进 四、对拍相关​ 1.程序运行时间 12double t = clock();cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl;","categories":[],"tags":[]},{"title":"","slug":"Detail/常见代码实现细节","date":"2019-04-27T09:01:25.528Z","updated":"2019-04-26T12:52:52.032Z","comments":true,"path":"2019/04/27/Detail/常见代码实现细节/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/常见代码实现细节/","excerpt":"","text":"这里记录的问题，全是我调过的问题orz 一、变量溢出问题 乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘 int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long， unsigned类型：值域$[0,2^{8size}-1]$溢出后对$2^{8size}$取模。 signed类型: 值$[-2^{8size-1},2^{8size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。 long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数 二、运算问题 有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数 要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除 做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值， 维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf 注意非负整数与“正整数”的区别，值域里可能会有0 有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。 三、语言问题 有时需要注意\\n \\r的问题，建议写手动读入的时候直接特判掉 宏定义千万别忘了括号，调一辈子 lint 输入输出 %lld，ldob输入输出 %Lf 数组作为形参会退化成指针，不能再用sizeof求大小 题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0 程序中常量默认是INT型，设定 long long a = 10000 9999 9998 等一定要注意常量爆INT的问题 使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉 写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等 维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义 计算某些东西时，如果计算后需要移动指针，注意别先移动指针了。（Acwing 294） 写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧 维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。 四、数学相关 BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$ 123if(Z == 1) return 0; //Luogu P2485 [SDOI2011]计算器if(Y % P == 0) return Z%P == 0 ? 1 : -1; i*len - ht[Yk] &gt;= 0 无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况 exgcd求出的d，如果要算最小非负解，一定把模数取决定值，才能用我们惯用的写法 如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的 计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\\ ||\\ m&lt;0\\ ||\\ n&lt;0$时0种方案 试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于 五、数据结构相关 维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1] 分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错 分块题开数组不要开混了 在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数” 常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2 静态线段树空间直接开4n防越界，动态开点的范围为 $[mlog_2m, 2n-1]$ 翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放 下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响 pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去 将操作重新排序后，注意是删除操作优先，还是增加操作优先 邻接表 i=nxt[i], 千万别写成 i=nxt[x] 如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。 有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。 有时需要特判“不存在”、”没找到“的情况 写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空相关指针，数据清不清无所谓。 六、图论相关 如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。 邻接矩阵注意初值是0还是inf 在有负权边时，树的直径不能通过两次DFS求。 无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。 带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。 在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。 七、动态规划相关 要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \\forall j \\ \\ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。 状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$ 八、杂项 题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;= 一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1 在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。 九、奇异的语言细节 123456// C++标准并没有规定参数的求值顺序void test(int x,int y)&#123; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;&#125;test(++x,x); // 输出 1 1test(++x,x-1); // 输出1 -1","categories":[],"tags":[]},{"title":"","slug":"Detail/OI中知识点与技巧总结","date":"2019-04-27T09:01:25.509Z","updated":"2019-04-18T02:33:00.446Z","comments":true,"path":"2019/04/27/Detail/OI中知识点与技巧总结/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/OI中知识点与技巧总结/","excerpt":"","text":"一、最优化问题 二分答案：答案具有“单调性”，外层花费$log\\ ans$的时间转化为判定性问题 答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的 二分出的答案一般对check的进行有所帮助 动态规划：一定要有最优子结构性质 贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件，很少作为一个题的main idea出现， 可以小范围搜索+多重限制贪心乱搞 一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质 二、计数问题三、数据结构题四、数学题 求和题：核心思想：[交换求和顺序] 五、图论问题六、搜索优化策略七、动态规划优化策略 费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算 七、常见有用思想与技巧、性质 正难则反：广泛应用于各种问题 答案不容易求、不容易划分，利用全集减去补集从而求出答案 字典序最小的方案：结合性质5，倒序处理 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数 凹凸性（二阶导数）：凸壳优化 对称性： “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于 例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于 试填法、字典序","categories":[],"tags":[]},{"title":"","slug":"Contest/NOIP 2018/D1T3 赛道修建","date":"2019-04-27T09:01:25.456Z","updated":"2019-04-25T09:07:27.583Z","comments":true,"path":"2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/","link":"","permalink":"http://arintaro.com/2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/","excerpt":"","text":"Description:给定一棵带权树，要求从树上划分出$m​$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \\times 10^4​$级别（实际上可以出到$5\\times10^5​$左右，边权再缩小点甚至能更大，卡$sort​$?(雾 Solution:分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助，发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。考虑性质1：每条路径对答案的贡献其实是相同的，都是$1$，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之性质2：父节点只能有一条路径到当前节点，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在保证配对数最大的同时，还要保证剩下的深度最大，从而上传给父节点。我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下： 给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。 这里网上通常有三种实现形式，我从复杂到简洁讲： 算法1：贪心+平衡树/双向链表、删除标记首先，我们显然有性质1：应该优先配对较小的深度。 如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。 然后，我们有性质2：最优方案中，每个最小值都应该与能配对的最小的数配对，显然，不证了。基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \\ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（期望得分：55分，实际得分：100分 算法2：双指针+栈一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是能配对的最小的数。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。 STD算法：双指针那么有没有不用栈，常数更加优秀（并不，更加简洁的算法呢？有，就是本题的标算。基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last​$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j​$，配对到了左指针$i​$，如果$j-1​$不能与$i​$配对，那么剩下的右指针也显然配对不了，所以$i​$必须得与$j​$配对，这时我们更新$last = j - 1​$即可，如果最后考虑一个右指针$j​$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]​$成功配对的右指针平移到$[j,last-1]​$，然后用$last​$对应的值更新上传的最大值。由于网上$blog​$没有对这个算法的讲解，$std​$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std​$在干什么。。 这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\\frac{\\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，从而实现了卡sort的可能。还有俩剪枝，二分上界可以设到$min{\\frac{\\sum{w_i}}{m} ,d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;const int rid = 8;int n, m;int root = 1, sumw = 0;int temp[maxn], rcnt[1&lt;&lt;rid], rmod = (1 &lt;&lt; rid) - 1;inline void rsort(int arr[], int n) &#123; if(n &lt; 256) &#123; sort(arr+1, arr+n+1); return; &#125; for(rint i=0; i&lt;=31; i+=rid) &#123; memset(rcnt, 0, sizeof(rcnt)); for(rint k=1; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++; for(rint j=1; j&lt;=rmod; j++) rcnt[j] += rcnt[j-1]; for(rint k=n; k&gt;=1; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k]; memcpy(arr, temp, sizeof(int) * (n+1)); &#125;&#125;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;int arr[maxn], dist[maxn];int dfs(int x, int fa, int mid) &#123; int res = 0, tot = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else arr[++tot] = dist[ev[i]] + ew[i]; &#125; rsort(arr, tot), dist[x] = 0; for(rint i=1, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123; while(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++]; if(i == j) &#123; dist[x] = arr[last]; break; &#125; if(j &amp;&amp; arr[i] + arr[j-1] &lt; mid) last = j-1; if(res &gt;= m) return res; &#125; return res;&#125;int maxd, dp[maxn];void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]); dp[x] = max(dp[x], dp[y] + ew[i]); &#125;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs2(root, root); int l = 1, r = min(maxd, sumw / m); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define sit multiset&lt;int&gt;::iteratortemplate&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;int n, m;int root = 1;int sumw = 0, dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;multiset&lt;int&gt; s;int dfs(int x, int fa, int mid) &#123; int res = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; dist[x] = 0, s.clear(); for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else s.insert(dist[ev[i]] + ew[i]); &#125; for(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; // nxt一定在it后面 sit nxt = s.lower_bound(mid - (*it)); if(nxt == it &amp;&amp; nxt != s.end()) nxt++; if(nxt == s.end()) &#123; it++; continue; &#125; s.erase(nxt), s.erase(it++), res++; // 注意先删nxt, 不然it++可能等于nxt if(res &gt;= m) return res; &#125; if(!s.empty()) dist[x] = *s.rbegin(); return res;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; int l = 1, r = sumw / 2; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125;","categories":[],"tags":[]},{"title":"树的相关性质(更新中)","slug":"Algorithm/树的相关性质","date":"2019-04-27T09:01:25.373Z","updated":"2019-04-27T10:10:34.231Z","comments":true,"path":"2019/04/27/Algorithm/树的相关性质/","link":"","permalink":"http://arintaro.com/2019/04/27/Algorithm/树的相关性质/","excerpt":"","text":"本文大概会长期更新，然后本文大概率不会有图。（我才不会告诉你我写的时候看的图都是随手拿画图画的。。） 一、树的直径（一）求法：树形DP（不要求边权非负）、两次DFS（二）性质： 分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。 任意一个节点作根，直径两端点一定是叶子节点。 距离任意点最远的点一定是直径的一个端点。（相当有用的性质 设从A出发找到最远点B 如果A已经是直径上一个端点，正确性显然。 如果不是，考虑反证，设直径为CD。 由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。 则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。 树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分，且在这部分两侧的长度一定相等。 显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。 如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。 对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。 如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。 往一棵树里加一个点，直径的端点最多改变一个 先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。 （三）在具体题目下的性质证明 NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，然而原题不要求证明这些东西 在任意直径上求最小偏心距都相等 考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。 考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://arintaro.com/categories/算法/图论/"}],"tags":[]},{"title":"","slug":"Template/小工具/log2的姿势","date":"2019-04-27T09:01:25.331Z","updated":"2019-04-26T08:25:22.435Z","comments":true,"path":"2019/04/27/Template/小工具/log2的姿势/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/小工具/log2的姿势/","excerpt":"","text":"1.转double法double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，几乎是$O(1)$的。请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可） 123456#define lint long longinline lint mlog2(lint x)&#123; if(x == 1) return 0; double t = (double)x; return (lint)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1; // 注意最前面还要再转一次long long&#125; Luogu ST表 传统打表法 1011ms https://www.luogu.org/recordnew/show/13493959Luogu ST表 double法 1009ms https://www.luogu.org/recordnew/show/18155615实测后发现速度差异不大, 开了O2打表会快一些 2.打表法显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论 $$\\forall k \\in [0,35], 2^kmod\\ 37,\\ 取遍[1,36]​$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// test site: https://www.luogu.org/problemnew/show/P3865// 要求：实现函数mlog2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define rint register int#define lint long longusing namespace std;const int maxn = 1e5 + 10;int n, m, logn;int arr[maxn];inline lint mlog2(lint x) &#123; &#125;int rmq[20][maxn];inline void getrmq() &#123; for(rint i=1; i&lt;=n; i++) rmq[0][i] = arr[i]; for(rint d=1; d&lt;=logn; d++) &#123; int len = (1 &lt;&lt; d), half = (1 &lt;&lt; (d-1)); for(rint i=1; i+len-1&lt;=n; i++) &#123; rmq[d][i] = max(rmq[d-1][i], rmq[d-1][i+half]); &#125; &#125;&#125;inline int ask(int l, int r) &#123; int loglen = mlog2(r - l + 1); return max(rmq[loglen][l], rmq[loglen][r-(1&lt;&lt;loglen)+1]);&#125;int main() &#123; readint(n), readint(m); logn = ceil(log2(n)); for(rint i=1; i&lt;=n; i++) readint(arr[i]); getrmq(); int nl, nr; while(m--) &#123; readint(nl), readint(nr); printf(\"%d\\n\",ask(nl,nr)); &#125; return 0;&#125;","categories":[],"tags":[]}]}