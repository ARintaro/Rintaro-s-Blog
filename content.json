{"meta":{"title":"Rintaro's Blog","subtitle":"Algorithm and Anime","description":"某弱省一弱校高一OIer","author":"Rintaro","url":"http://arintaro.com","root":"/"},"pages":[{"title":"","date":"2019-10-31T02:20:18.129Z","updated":"2019-04-27T07:31:21.041Z","comments":false,"path":"categories/index.html","permalink":"http://arintaro.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"《天气之子》观后感","slug":"Essay/《天气之子》观后感","date":"2019-11-02T16:40:16.669Z","updated":"2019-11-02T19:35:20.294Z","comments":true,"path":"2019/11/03/Essay/《天气之子》观后感/","link":"","permalink":"http://arintaro.com/2019/11/03/Essay/《天气之子》观后感/","excerpt":"退役警告","text":"退役警告 一、前言 &amp; 观影体验@card{ 先讲讲我对新海诚的认识，毕竟这部动画很大一部分讨论都集中在他身上，这是一个蛮有趣的现象，其他日本动画电影在宣发时主要强调的是IP，毕竟深夜动画圈相对整个观影人群还是占绝对少数的，而君名和这部宣发很大程度上强调的是由”新海诚”这个人上，这是与”宫崎骏”在同等地位上的。 诚哥在《君名》之前，认知度还是集中在”平时就比较喜欢看日本动画”的人里，我在这个时间点大概只看过《秒速五厘米》。《君名》爆红之后，我才陆陆续续补了其他作品，当然，我作为一名萌二，肯定是现在还没看完的，记得《云端》只看了木鱼水心的解说视频，现在最喜欢的大概是《星之声》，当然这部从制作水准上肯定是没现在的作品强，但是我喜欢的是其中的”idea”。（比民俗我大概更喜欢科幻。 这次的《天气之子》是比《君名》在上映前更受到关注的，资本因素大概会更多一些？不过有趣的是，国内的引进速度都是差不多的（奇异的游戏人生zero，话说TV动画什么时候继续出啊？！），因此我在上映前就被各大位于日本的动漫高手剧透了大体剧情走向（当然出钱这么多的片子肯定也可以推测出不会让诚哥乱搞一个BE出来的）。 接着讲观影体验，具体观影我是在11/2的晚上刷了两遍，一开始本来只想看一场的，但是由于：第一场： 我一个人坐在了两对情侣之间- 儿童厅的小屏幕- 提前买了冰奶茶很好喝+ 首次观影+ 第二场: 有dbn陪我吹水+ imax的大屏幕+ 有可爱的妹子+ 人少可以随便换座+ 明天放假+ 第一次在影院里看到《君名》女主翻译成”宫本茂”时，我的反映： 这不是做马里奥的那个大叔嘛？ 我是不是记错女主名字了，她不是叫宫水三叶么？ 啊啊，应该是嫁给男主改姓了 可是男主不是叫”立花泷”么？ ？？我记错哪个名字了？！ } 二、杂项@card{ 这部分放在前面，因为我确实啥也不懂，只能跟《君名》做做比较。 作画这部分似乎没什么人提，因为经费比较充足，确实作画质量吊打各大其余”类似画风”的动画。动作场面非常精彩，诚哥标志性的城市风景和天空也得到了充分的体现，对于我这样的非作豚肯定是只能吹爆了。（当然单从作监履历上来看，田村篤确实之前没有什么著名作品，肯定是没有《君名》的安藤雅司耀眼），anitama上贴了很多幕后制作故事、访谈，连接。 人设上我认为女主的人设还是比较新颖的，男主的似乎见得比较多？ 音乐，我这样五音不全的人就不评价了，单听都是非常好听，但从”契合度”上来讲，似乎是没有《君名》好，中间还有女主唱《逃耻》的曲子，我在电影院里居然反应过来。。 配音我认为都非常优秀，包括在日上映之前在zhihu上饱受怀疑的启用明星配音的小栗旬。 } 三、剧情 (剧透警告)@card{ 由于我现在没读过小说，BD也没出，以下均按我在影院看了两遍的个人感受为准。 剧情主体还是传统的boy meets girl，再混合了一些超能力设定和小偷家族的感觉？出来看了访谈， 据说新海当初在观看是枝裕和导演执导的《小偷家族》时，就想着要酝酿一部，未必如揭示日本低层民众疾苦的《小偷家族》那般立意沉重深远，但在感觉上较为相近的作品。登场人物中既有姐姐，年幼的孩子，也有上了年纪的老婆婆，以及少年。如此，便有望将影片打造成老少皆宜的作品。作者：izumi链接：http://www.anitama.cn/article/e49836264d7384cc来源：Anitama 前期剧情前期讲了男主离家出走，受到女主和大叔帮助，并用捡来的枪击退了劝拐女主从事风俗业的坏人，后来想到利用能力牟利并度过了一段欢乐日常。 一开始，男主离家出走时身上是带伤的，暂不清楚是因为他太皮被”合理的管教”了，还是单纯的家暴。这里如果解释成”男主被家暴”了，大概男主的形象会在”社会意义上”正面一些。 之后女主给了落魄的男主一个汉堡，并成为后来男主阻止女主从事风俗业的flag，后来女主被开除我个人倾向是女主说的”其他原因”，而不是因为给了男主一个汉堡，毕竟女主想给的话，应该是自己掏钱买，从女主其余地方表现的善良性格，大概是不会偷汉堡店的东西的。 中间前辈的两个女友玩了声优梗。(前辈太强了，orz) 这段大叔的戒指给了非常多的特写，疯狂暗示大叔的亡妻，看zhihu上说场刊废设有大叔是专门研究民俗的学者，而不是现在的八卦小报编辑。剧情中给了相当多的暗示大叔是有故事的人，我个人倾向于他妻子也是那种”牺牲小我成就大我的巫女”(是不是天气巫女不确定)，并且大叔没有像这次的男主一样选择老婆而不是世界，之后现在的大叔一直在后悔。但我认为他对这次阳菜能力的设定还是不太清楚的，如果清楚，恐怕他会在得知阳菜在滥用能力之后立刻阻止的吧。我认为如果大叔设定成”学者”，并将救阳菜的后果与方法研究出来，这个片子的剧情走向恐怕就会完全改变，这个之后再说。 捡到枪是非常重要的flag，它直接引起了后来的剧情冲突，但是这也恰恰是被很多人喷的点，还是之后再说。 在男主想到能力牟利后，剧情前期大概就再也没描写过生活不易，并且这段他们的活动已经引起了相当的关注。这里可以发现他们所在的世界(同时也是《君名》的世界)，虽然充斥着超自然现象，但在普通群众的认可度不高，政府也没有相关机构研究，换句话说，就是没有社会人认为能力是真的，也没有政府认为能力是真的，否则单凭这几个孩子肯定是要被抓走的。当然，这是与剧中大型活动单靠女主矛盾的，不过也可以解释成”当个吉祥物”，否则就是剧情出锅了。不少能力系的作品的核心矛盾就定在”政府/机构抓人研究上”，但是这部作品没有。我在这里就联想到了《哆啦A梦》，大雄每次适当用道具时就不会出事，一旦开始乱搞就肯定会出事，这其实是插上了BE的flag。 中期中期大概是三人组的整个逃亡过程。 然后就到了主要争论点，这片没有不可调和的核心矛盾，所谓的矛盾大部分是男主决策失误自己作的。(这并不是定论，请接着往下看) 剧中中期阻碍两人在一起的是警察，后期阻碍的是警察+神隐。中期警察为什么抓他俩？ 是因为男主捡到枪并使用了它，女主带着弟弟独立生活，由于剧中并没有描写警察势力有多么黑暗，从常理来讲”男主持枪”在暴力袭警之前，是完全可以解释清楚的。而”女主带着弟弟独立生活”也不是不可调和的，即使接受收容，女主反而可以接受教育，弟弟也能过上物质条件好一些的生活，并且接受稳定的教育，这与女主照顾弟弟的目标是契合的。剧中解释是想”两人在一起生活”，可接受收容后两人也并不是见不到了呀。现在剩下的问题其实是，一旦男主选择与警察和解，其必然要被遣返读完高中，事实上从结局给出的结果来看，这并不是不可接受的结果。然后最终他们选择了跑路，其成功性也非常渺茫，没有身份证件，黑活也很难找到，也没有其他有效收入与住所，事发之后控制天气的私活也很难干下去，还要面临警察全天候的追捕，并且弟弟再也接受不了义务教育了。 从上述视角看，这个故事是”不合逻辑的”，但是剧中作出决策的并不是拥有上帝视角的观众，而是会作出”毫无准备的离家出走”这种决策的男主，这样的男主会作出不理性的决策，导致观众认为的”主线任务”偏离。 我一开始认为的主线是”男女主与世界的对抗”，看完想想，不如说是”男女主走到一起的曲折过程”，它可能本来会非常顺利，但是因为意外或者是剧中人物的决策失误导致了偏离，从”对抗世界”转而”对抗警察”。 我认为从”事实上的事件”来看，这个过程是没有问题的；但是从剧作的角度来看，我们平时看到的剧本一定是符合逻辑的，即使存在意外也在合理的范围并存在铺垫的：比如白箱最后一集，放一个不知道哪里出现的纵火犯把武藏野烧了，这恐怕会被喷到死，但是这种事件在现实里的京都却发生了，这就是所谓的”现实比剧本更加离奇”。 当然，这种事件在现实里肯定会有铺垫，但是由于我们信息量太少，无法掌握，而这在剧本里是会给你的，比如”某人买了不知用途的汽油，并拿着攻击用品朝着京都动画走来”，这就是可能推测出”这个人以后会纵火”的关键信息，而在现实里没有上帝视角or编剧特意强调的信息，这种信息是根本无法掌握的。 所以，我认为从男主之前设定的性格来看，作出这些冲动决策其实是合理的。但这样的情节安排肯定会导致”故事性不强”，这也是评价两极分化的直接原因，我认为是没有必要得出一个定论”故事性不强”好不好的，喜欢的人自然喜欢，不喜欢的人自然不喜欢。 后期后期讲了阳菜消失到拯救阳菜，及留白的遣返三年。 又到了一个争论点，不过大概没有上一个大，即男主的选择，在女主和东京之间果断选择了女主。 但是从影片中来看，男主做梦大概只做到了女主从神社升天(如果设定集改了这个前提，以下说明均不成立)，并没有给出他拯救女主的方法与后果。这也就是上文说的，”如果大叔设定成学者并研究成功”，这段男主的行为就从”观众的逻辑”完全解释的通了，而不是自我的”任性”。 仔细考虑一下，他被逮捕后，是不知道拯救女主的方法与后果的，这代表着即使他让大叔与姐姐成为共犯，即使他成功暴力袭警并选择为之承担后果，也不知道能否成功拯救女主，其成功概率是他无法预估的，而后果更是他无法预估的，是仅仅下雨几天，还是下雨几个月，或者是下雨三年淹了东京，还是最严重的淹了全世界。 他是根本不知道的，他是抱着仅有的一丝可能性，不顾之后的任何后果，选择了暴力袭警拯救女主，从这个角度考虑，这确实是能突出两人的羁绊的。从事后诸葛亮的角度来讲，恐怕任何观众换进去从逃亡开始走男主的流程，没有一个能打出GE的，反而是”任性”的男主打出了”个人较优解”。 不过，我相当奇怪的是女主的转变，在女主消失的那个晚上，她是愿意为世界而牺牲自己的，但是当后来男主不顾一切来找她的时候，她没有丝毫犹豫，直接跟男主走了。当然，由于没有女主视角，不知道女主这时对能力的前提与后果掌握的怎么样了，因此只能作为”奇怪的地方”。 不过也可以换个角度解释，也可以解释成那个晚上女主问男主愿不愿意停雨，那时男主说了”嗯”，所以女主依照男主的想法决定牺牲自己，但这时男主其实是不知道停雨的代价是女主消失，等到男主了解代价，并来救女主，其实就是告诉女主”我其实是不愿意你消失的”，所以女主又按照男主的想法立即回去了。大概这个角度能更突出两人的羁绊。 然后就是几人被抓后的现实社会情节，这部分一点没讲，但这其实是之前为何逃亡的重要原因，但影片自始自终没表现最后被抓回去有多惨，反而是男主只判了一个保护观察正常接收教育，男主未成年就忍了，但作为成年人共犯的大叔，就算能洗掉诱拐，可是暴力袭警怎么洗呀，基于开头的讨论，法官也肯定不会相信是因为一些超自然力，但是大叔三年后反而还混的更好了，这部分等设定集洗吧，不知道能如何解释。 当然，如果不考虑得这么复杂，我们抽象一点，东京和女主选哪个，或者更大一点，世界和女主选哪个，从我的立场来说，我选女主。 最后男女主的相见还是经典的坡道梗，虽然上面这么说了，但真正在电影院里看的时候，还是非常有感染力的。 } 四、总结@card{ 制作顶尖的作品。 如果你在意剧情，那么主要看您对”故事性不强”的故事的接受程度。我认为不在意剧情的人，这片都会看得非常开心。 知乎上有非常多的补充细节和剧情分析，如果您看完了这部，并对这些东西感兴趣十分推荐阅读，这里我就懒得放链接了。 最后，散发的女主真好看.jpg，等出了BD我要截下来。 }","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"},{"name":"观后感","slug":"文章/观后感","permalink":"http://arintaro.com/categories/文章/观后感/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://arintaro.com/tags/动画/"},{"name":"颓废","slug":"颓废","permalink":"http://arintaro.com/tags/颓废/"}]},{"title":"Luogu P3400 仓鼠窝","slug":"Answer/hamster","date":"2019-11-01T08:46:01.002Z","updated":"2019-11-01T09:35:37.443Z","comments":true,"path":"2019/11/01/Answer/hamster/","link":"","permalink":"http://arintaro.com/2019/11/01/Answer/hamster/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给一个$n \\times n$的$01$矩阵，求出其中均为$1$的子矩阵个数。 $1 \\leq n \\leq 3000$ } Solution:@card{ 先考虑几个朴素做法，枚举子矩阵的三个角，暴力判断其中是否都是$1$，$O(n^6)$。 发现判断很耗时，不如用hash，降到$O(n^4)$。 考虑只枚举两个角，即枚举两个行，然后判断两行间有多少子矩阵。只要把多行压成一行，然后转化成一维问题解决即可。降到$O(n^3)$。 再写出暴力对拍后，考虑能否只枚举一个角解决问题。 算法一: 单调栈 + 分行计算贡献考虑之前经常做的最大子矩阵问题，我们可以枚举一行，然后每列之上连续的$1$的数量作为一列的高度。 同时注意不要重复计算，我们每次计算的是”底端在这行上”的数量，类似最大子矩阵问题，我们在出栈时计算贡献。 与之前相同，因为我们维护了矩形的单调性，我们出栈时倒序计算可以保证右边的矩形都比当前矩形高，从而快速累加贡献。但是这里我们需要计算什么呢？为了防止重复计算，我们规定出栈时只计算”跨多个矩形构成的子矩阵”，出栈一个矩形时，分成它自己的左端，和这次之前出栈的右端，不妨设左端宽度$w$，右端宽度$now$，左端高度$h$，则这次的贡献显然是$w \\times now \\times h$。 之后注意入栈时不能只入$now + 1$一个矩形，而是要入一个$now$和一个$1$的，因为新加进来的矩形与之前的矩形的贡献还未计算。 算法二： 单调栈 + 对每个右下角计算贡献考虑对一个右下角有多少个左上角能与其匹配，手玩后发现其在列上满足一定的单调性。所以分列转移，用递推预处理出每个点向左最多能扩展$1$的长度，再用单调栈维护一下即可，具体做法与上个方法类似。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 算法1#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 3000 + 10;int n, m;bool ma[maxn][maxn];int arr[maxn];lint ans = 0;int h[maxn], w[maxn], stop = 0;// 注意n, m别写反了lint calc() &#123; stop = 0; lint res = 0; for(rint i=1; i&lt;=m+1; i++) &#123; res += arr[i]; if(h[stop] &lt; arr[i]) h[++stop] = arr[i], w[stop] = 1; else &#123; int now = 0; while(stop &amp;&amp; h[stop] &gt;= arr[i]) &#123; res += (lint)w[stop] * now * h[stop], now += w[stop]; stop--; &#125; if(arr[i] != 0) &#123; h[++stop] = arr[i], w[stop] = now; h[++stop] = arr[i], w[stop] = 1; &#125; &#125; &#125; return res;&#125;int main() &#123; readint(n), readint(m); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(ma[i][j]); &#125; &#125; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) arr[j] = ma[i][j] ? arr[j] + 1 : 0; ans += calc(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 算法二#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 3000 + 10;int n, m;int lt[maxn][maxn];bool ma[maxn][maxn];int h[maxn], w[maxn];lint ans = 0;int main() &#123; readint(n), readint(m); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(ma[i][j]); lt[i][j] = ma[i][j] ? lt[i][j-1] + 1 : 0; &#125; &#125; for(rint j=1; j&lt;=m; j++) &#123; int cnt = 0, stop = 0; for(rint i=1; i&lt;=n; i++) &#123; cnt += lt[i][j]; if(!stop || (stop &amp;&amp; w[stop] &lt;= lt[i][j])) &#123; w[++stop] = lt[i][j], h[stop] = 1; &#125; else &#123; int now = 1; while(stop &amp;&amp; w[stop] &gt;= lt[i][j]) &#123; cnt -= (w[stop] - lt[i][j]) * h[stop]; now += h[stop], stop--; &#125; w[++stop] = lt[i][j], h[stop] = now; &#125; ans += cnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://arintaro.com/tags/单调栈/"},{"name":"悬线法","slug":"悬线法","permalink":"http://arintaro.com/tags/悬线法/"},{"name":"多维问题","slug":"多维问题","permalink":"http://arintaro.com/tags/多维问题/"}]},{"title":"USACO11OPEN 奇数度 Odd degrees","slug":"Answer/cow3","date":"2019-11-01T02:41:11.874Z","updated":"2019-11-01T08:45:40.063Z","comments":true,"path":"2019/11/01/Answer/cow3/","link":"","permalink":"http://arintaro.com/2019/11/01/Answer/cow3/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给一张图，要求选出一些边，使每个点的度数为奇数。 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$ } Solution:@card{ 由于图上问题有”任意性”, 难以进行DP，所以先考虑性质与扫描。 发现这个问题与图的形态无关，其实就是给一个全$0$序列和$m$对关系，选一对关系是把两个都加一，最后求怎么选能让序列中的数都都是奇数，最后发现十分不可做，我们难以确定计算顺序，选了一对关系很可能会对后面带来无法估计与记录的影响。 考虑在树上怎么做，树上显然确定计算顺序自下而上即可，叶子节点连向父亲的边是必须选的，考虑完所有的叶子节点，再考虑向上一层，它们此时的度数的奇偶性是确定，也就是说成为新的”可以直接确定连向父亲边选不选的”叶子节点。 接着扩展到图上，发现图上随便一个生成树的所有方案其实覆盖了图上的所有方案。首先，对一条链来讲，把其中边选不选的状态取反，中间的节点度数奇偶性均不变，只有两头的节点奇偶性取反。那么如果存在一种方案有一条不在生成树上的边成立，那么去掉这条边，把它在生成树路径上的边取反，显然也是一种成立的方案。 所以随便求个生成树当树上问题做即可。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e4 + 10;const int maxm = 2e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], id[maxm], totedge = 1;inline void addedge(int nu, int nv, int x) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; id[totedge] = x;&#125;// 图上问题在树上怎么做？int cnt = 0;bool vis[maxn], choose[maxm];bool dfs(int x) &#123; bool res = 0; vis[x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y]) continue; if(!dfs(y)) cnt++, choose[id[i]] = 1, res ^= 1; &#125; return res;&#125;int main() &#123; readint(n), readint(m); int nu, nv; for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv); addedge(nu, nv, i), addedge(nv, nu, i); &#125; bool failed = 0; for(rint x=1; x&lt;=n; x++) &#123; if(vis[x]) continue; if(!dfs(x)) &#123; failed = 1; break; &#125; &#125; if(failed) puts(\"-1\"); else &#123; printf(\"%d\\n\", cnt); for(rint i=1; i&lt;=m; i++) if(choose[i]) printf(\"%d\\n\", i); &#125; return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"等效法","slug":"等效法","permalink":"http://arintaro.com/tags/等效法/"},{"name":"生成树","slug":"生成树","permalink":"http://arintaro.com/tags/生成树/"}]},{"title":"USACO13JAN 牛的阵容 Cow Lineup","slug":"Answer/cow2","date":"2019-10-31T11:41:09.091Z","updated":"2019-10-31T11:46:54.171Z","comments":true,"path":"2019/10/31/Answer/cow2/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cow2/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给定一个颜色序列，可以至多去掉$k$种颜色，使去除后一个连续相同颜色的子段最长。 $1 \\leq k \\leq 10^5$, $1 \\leq k \\leq n$ } Solution:@card{ 考虑一个颜色数不大于$k+1$的区间，它显然可以去掉$k$种留下区间颜色数最多的得到这个区间的答案。 然后双指针扫一扫，对每个$i$找颜色数尽量多的区间即可。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, k, ans = 0;int arr[maxn];int ht[maxn], tot = 0;inline int eco(int x) &#123; return lower_bound(ht+1, ht+tot+1, x) - ht;&#125;int cnt_color[maxn], cnt = 0;inline void update(int c, int x) &#123; int pre = (cnt_color[c] != 0); cnt_color[c] += x; cnt += (cnt_color[c] != 0) - pre;&#125;int main() &#123; cnt_color[0] = 1; readint(n), readint(k); for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]); ht[++tot] = arr[i]; &#125; sort(ht+1, ht+n+1), tot = unique(ht+1, ht+n+1) - (ht + 1); for(rint i=1; i&lt;=n; i++) arr[i] = eco(arr[i]); for(rint i=1, j=0; i&lt;=n; i++) &#123; while(j &lt;= n &amp;&amp; cnt &lt;= k + 1) update(arr[++j], 1); ans = max(ans, cnt_color[arr[i]]); update(arr[i], -1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"等效法","slug":"等效法","permalink":"http://arintaro.com/tags/等效法/"}]},{"title":"POJ3017 Cut The Sequence","slug":"Answer/cut","date":"2019-10-31T06:20:01.041Z","updated":"2019-10-31T11:38:57.144Z","comments":true,"path":"2019/10/31/Answer/cut/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cut/","excerpt":"","text":"Description:@card{ 给定一个长度为$n$的序列A，要求把该序列分成若干段，在满足“每段中所有数的和”不超过$m$的前提下，让“每段中所有数的最大值”之和最小。 $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^{11}$ } Solution:@card{ 这题是个相当好的题目。 最优化问题，乍一看挺像一个二分答案的，答案显然具有单调性，然而仔细考虑一下，二分答案中，我们二分出来的“答案”需要对计算有帮助，然而这个答案““每段中所有数的最大值”之和”，对计算毫无卵用，根本无法check。 既然最优化问题的第一个想法二分答案不行，我们接着考虑最优化问题的第二个想法，DP。 不妨设$max[l,r] = max{arr[k],k \\in [l,r]}$, 显然有状态转移方程：$$dp[i] = \\min(dp[j] + max[j+1, i])$$ 是一种经典的枚举断点从而转移的序列分段DP，然而复杂度过高，稍微想想没什么显然的等效转移or状态。 接着考虑优化此方程，然而也很困难，$max[k+1,i]$是一个与当前状态变量有关的函数，这样$i$每增加1，我们都必须得考虑每个合法决策来确定决策对当前状态的评分。这也不是简单多项式函数，可以利用斜率优化解决的。 四边形不等式？需要有$max[k,i+1] + max[k+1,i] &gt;= max[k,i] + max[k+1,i+1]$，这个式子乍一看像成立的，然而并不成立（虽然对不少小规模数据是可以成立的，这也提醒我们四边形不等式的打表一定要打的长一些，不能太懒），考虑$k$与$i+1$位置上出现有俩$inf$，此时等式左边只有一个$inf$，而等式右边俩$inf$，显然不成立。 考虑定值，斜率优化，四边形不等式全挂了，只剩一个单调性了。 从实际意义出发：考虑前后两个决策$k$, $k+1$显然有$$dp[k] \\leq dp[k+1]$$$$max[k+1,i] \\geq max[k+2,i]$$即非严格单调性，那如果$k+1$想成为最优决策，必须有$max[k+2,i] &lt; max[k+1,i]$,进而可以推出$arr[k+1] = max[k+1,i]$（注意两个条件并不等价） 可以发现，我们似乎把不确定的$max[k+1,i]$化为了一个数组中的定值，然而决策$k+1$中的函数是$max[k+2,i]$，那怎么办呢？既然$k+1$可能成为最优决策可以确定$max[k+1,i]$的值，那不妨我们就去找$k+2$或更后面的决策可能成为最优决策的时候$max[k+2,i]$的值也便确定了。 基于此思路，由于前面的限制条件$sum[i] - sum[k] \\leq m$,是一个”越前面越难满足的条件”，说白了就是从队头出队，所以我们可以维护一个单调队列，其中$arr[k]$单调递减，显然队列中第$k$项的$max$函数就是下一项的的值。这样对于一个决策，只要队列中的下一项不变，它的评分就与$i$无关，是一个定值，这样就化为了模板题，用堆or平衡树维护决策集合即可。由于本题中出队时，需要有删除操作，而堆要删除每次还要记录指针，相当麻烦，不如直接用平衡树，复杂度也是$O(nlogn)$，常数大一些。 讨论至此，您写出来可能发现样例都过不了，因为忽视了讨论的“前提条件”，我们考虑了$k+1$，用$k$肯定or否定了它的最优性，那么有没有这样一个决策，前面没有决策呢？显然就是最小的满足$sum[i] - sum[k] \\leq m$的$k$。 程序实现上，由于队列中最后一项的$max$函数的值一定是$arr[i]$，我们可以在转移前把$arr[i]$入队计算即可。另外要注意特判平衡树or队列为空的情况，避免RE或WA。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const lint inf = 1e16;int n;int arr[maxn], q[maxn];lint m, sum[maxn], dp[maxn];multiset&lt;lint&gt; s;inline lint calc(int pos) &#123; return dp[q[pos]] + arr[q[pos + 1]];&#125;int main() &#123; readint(n), readint(m); // 无解与正常计算分开判断 for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]), sum[i] = sum[i-1] + arr[i]; if(arr[i] &gt; m) &#123; puts(\"-1\"); return 0; &#125; &#125; int l = 1, r = 0; for(rint i=1, p=0; i&lt;=n; i++) &#123; while(p &lt; i &amp;&amp; sum[i] - sum[p] &gt; m) p++; while(l &lt;= r &amp;&amp; sum[i] - sum[q[l]] &gt; m) s.erase(s.find(calc(l++))); while(l &lt;= r &amp;&amp; arr[q[r]] &lt;= arr[i]) &#123; if(l &lt; r) s.erase(s.find(calc(r - 1))); r--; &#125; q[++r] = i; if(l &lt; r) s.insert(calc(r - 1)); dp[i] = dp[p] + arr[q[l]]; if(l &lt; r) dp[i] = min(dp[i], *s.begin()); &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"POJ","slug":"POJ","permalink":"http://arintaro.com/categories/POJ/"},{"name":"题解","slug":"POJ/题解","permalink":"http://arintaro.com/categories/POJ/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"单调队列","slug":"单调队列","permalink":"http://arintaro.com/tags/单调队列/"}]},{"title":"高斯消元","slug":"Template/数学/线性代数/高斯消元","date":"2019-10-31T02:54:23.836Z","updated":"2019-10-31T06:19:44.151Z","comments":true,"path":"2019/10/31/Template/数学/线性代数/高斯消元/","link":"","permalink":"http://arintaro.com/2019/10/31/Template/数学/线性代数/高斯消元/","excerpt":"注意无解和多解的判断","text":"注意无解和多解的判断 一、概念@card{ 先确定这次要消哪元，然后从还没被确定的方程中选一个系数不为$0$的消其他所有该元系数不为$0$的方程，无解即存在$0 = 4$这种方程，多解即存在$0 = 0$的方程。 } 二、测试地址@card{ Luogu高斯消元模版：https://www.luogu.org/record/26019277 } 三、代码@card{123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define zero(x) (fabs((x)) &lt; eps)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50 + 10;const double eps = 1e-6;int n;double c[maxn][maxn];int calc() &#123; for(rint t=1, p=1; t&lt;=n; t++) &#123; for(rint i=p; i&lt;=n; i++) &#123; if(zero(c[i][t])) continue; for(rint k=1; k&lt;=n+1; k++) swap(c[i][k], c[p][k]); break; &#125; if(zero(c[p][t])) continue; for(rint i=1; i&lt;=n; i++) &#123; if(i == p || zero(c[i][t])) continue; double rate = c[i][t] / c[p][t]; for(rint k=1; k&lt;=n+1; k++) c[i][k] -= c[p][k] * rate; &#125; p++; &#125; for(rint i=1, p=1; i&lt;=n; i++) &#123; while(p &lt;= n &amp;&amp; zero(c[i][p])) p++; if(p == n + 1 &amp;&amp; !zero(c[i][p])) return -1; &#125; for(rint i=1, p=1; i&lt;=n; i++) &#123; while(p &lt;= n &amp;&amp; zero(c[i][p])) p++; if(p == n + 1) return 0; &#125; return 1;&#125;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=n+1; j++) readint(c[i][j]); &#125; int res = calc(); if(res == 1) &#123; for(rint i=1; i&lt;=n; i++) printf(\"x%d=%.2lf\\n\", i, c[i][n+1] / c[i][i]); &#125; else printf(\"%d\\n\", res); return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数学","slug":"模板/数学","permalink":"http://arintaro.com/categories/模板/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"线性代数","slug":"线性代数","permalink":"http://arintaro.com/tags/线性代数/"}]},{"title":"HAOI2015 树上染色","slug":"Answer/color","date":"2019-10-31T02:03:25.740Z","updated":"2019-10-31T11:41:02.748Z","comments":true,"path":"2019/10/31/Answer/color/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/color/","excerpt":"换个思路，统计贡献","text":"换个思路，统计贡献 Description:@card{ 有一棵点数为$n$的树，树边有边权，你要在这棵树中选择$k$个点，将其染成黑色，并将其他的$n-k$个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益，问收益最大值。 $1&lt;=n&lt;=2000$，$0&lt;=k&lt;=n$ } Solution:@card{ 先迅速地打出暴力，枚举选哪些，然后每个节点作根暴力计算答案，手玩了一下没发现有什么贪心性质。 由于是树上的路径之和，考虑类似树上差分的想法，即有很多个点对，每次都会把它们之间的路径覆盖一次，求每个边的边权乘以覆盖次数的和，对每条边计算覆盖次数即可。 此题中的覆盖一条边的覆盖次数显然是子树中的某色点数量乘子树外的某色点数量，由于色点数量给定，一旦我们知道了一端的数量，就能通过整体减去局部的方法计算出另外一端。 所以可以先确定自下而上的计算顺序，状态定义为某个子树中选$k$个黑点所有边产生的最大贡献，类似费用提前计算，之后直接跑树上背包即可，注意应用上下界剪枝优化到$O(n^2)$ } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 2 * maxn;int n, m, root = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;// 统计路径贡献 -&gt; 树上差分，考虑一条边的贡献 (费用提前计算)// 整体减局部为另外，正难则反// 以x为根的子树，k个黑点，所有边的最大贡献// lint dp[maxn][maxn];int size[maxn];void dfs(int x, int fa) &#123; size[x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs(y, x); for(rint j=min(m, size[x] + size[y]); j&gt;=0; j--) &#123; for(rint k=max(0, j-size[x]); k&lt;=j &amp;&amp; k&lt;=size[y]; k++) &#123; dp[x][j] = max(dp[x][j], dp[x][j-k] + dp[y][k] + (lint)k * (m - k) * ew[i] + ((lint)size[y] - k) * (n - size[y] - (m - k)) * (lint)ew[i]); &#125; &#125; size[x] += size[y]; &#125;&#125;int main() &#123; readint(n), readint(m); int nu, nv, nw; for(rint i=2; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs(root, 0); printf(\"%lld\\n\", dp[root][m]); return 0;&#125; }","categories":[{"name":"省选","slug":"省选","permalink":"http://arintaro.com/categories/省选/"},{"name":"题解","slug":"省选/题解","permalink":"http://arintaro.com/categories/省选/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"换根法","slug":"换根法","permalink":"http://arintaro.com/tags/换根法/"}]},{"title":"USACO12FEB 附近的牛 Nearby Cows","slug":"Answer/cow1","date":"2019-10-31T00:26:43.109Z","updated":"2019-10-31T01:22:21.943Z","comments":true,"path":"2019/10/31/Answer/cow1/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cow1/","excerpt":"强行与牛有关","text":"强行与牛有关 Description:@card{ 树上每个点有一个点权，求每个点距离不超过$k$的点权。其中$1&lt;=k&lt;=20$, $1&lt;=n&lt;=10^5$ } Solution:@card{ 注意要求全部点的答案，并且$k$较小，所以很可能是个换根DP。 又注意到对于任意一种转移顺序，某个点$x$的$dp[x][k]$，不可能转移到$y$的$dp[x][k+1]$，所以可以直接在状态内记录当前点范围为$k$的答案。规定计算顺序自下而上，先确定一个根，计算子树内的信息，之后再自上而下的根据父节点的答案算这个节点的答案即可。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int maxk = 20 + 2;const int maxm = 2 * maxn;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans = 0;int n, m, root = 1;int sum[maxn][maxk], res[maxn][maxk];// 从x出发不超过kvoid dfs1(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, x); for(rint k=1; k&lt;=m; k++) sum[x][k] += sum[y][k-1]; &#125;&#125;// void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; res[y][0] = sum[y][0]; res[y][1] = sum[y][1] + sum[x][0]; for(rint k=2; k&lt;=m; k++) &#123; res[y][k] = res[x][k-1] - sum[y][k-2] + sum[y][k]; &#125; dfs2(y, x); &#125;&#125;int main() &#123; readint(n), readint(m); int x, y; for(rint i=1; i&lt;n; i++) &#123; readint(x), readint(y); addedge(x, y), addedge(y, x); &#125; for(rint i=1; i&lt;=n; i++) &#123; readint(sum[i][0]); for(rint k=1; k&lt;=m; k++) sum[i][k] = sum[i][0]; &#125; dfs1(root, 0); for(rint k=0; k&lt;=m; k++) res[root][k] = sum[root][k]; dfs2(root, 0); for(rint i=1; i&lt;=n; i++) printf(\"%d\\n\", res[i][m]); return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"换根法","slug":"换根法","permalink":"http://arintaro.com/tags/换根法/"}]},{"title":"HNOI2003 消防局的设立","slug":"Answer/fire","date":"2019-10-30T08:24:46.725Z","updated":"2019-10-30T09:44:29.080Z","comments":true,"path":"2019/10/30/Answer/fire/","link":"","permalink":"http://arintaro.com/2019/10/30/Answer/fire/","excerpt":"少数几道贪心扩展性超过DP的题目","text":"少数几道贪心扩展性超过DP的题目 Description:@card{ 从树上选出最少的点，每个点可以覆盖与它距离不超过2的点，求最少需要选出多少点。 } Solution:@card{ 贪心做法扩展性强，且容易理解，但是这里不讲。本问题有很多前置形态，比如”每条边连接的两点必须任选一个”, 只需要记录每个点选不选就行了，但是此题影响的距离是2，这启发我们需要在DP状态上记录更多的信息便于转移。 树上问题一般要先确定计算顺序是自上而下还是自下而上，这里选择自上而下显然不容易设计出状态，所以选择每次从子树向上转移的自下而上。 确定计算顺序后，容易想到状态是”某范围中的点都被管辖所需要的最少点数”，按常规考虑是一个点子树中的点都被管辖，但是手玩几组数据发现，这样设计状态，一个点是可以从它的孙子甚至曾孙转移来的，这样设计状态难以转移，如果暴力追溯转移，时间上显然会爆炸。不容易优化转移，考虑重新设计状态，又想到附加儿子或孙子选不选的小范围状压维度，进一步考虑，我们事实上不关心子树中选了什么点，而是想通过知道这些点选没选而得知它向上覆盖的范围，所以我们规定状态为”某个点向上/向下覆盖了多少层选的最少点数”, 考虑一个节点$x$，它向下两层的节点必须在它这里被覆盖，否则按照我们的计算顺序，它以后都没机会被覆盖了，所以状态中记录的向上向下的最大层数为2。 接着考虑如何转移，$dp[x][0]$为它的孙子被完全覆盖, 1为儿子都被覆盖, 2为自己被覆盖, 3为父亲被覆盖, 4为祖父为覆盖。 下设$y$为$x$的儿子，显然有$$dp[x][0] = \\sum{dp[y][1]}$$与$$dp[x][1] = \\sum{dp[y][2]}$$ 先暂缓一下，这样转移可能会遗漏某些情况，这样转移状态的严谨定义就变成”刚好覆盖到某层的最少点数”，但是会不会有时往上多覆盖了反而用了更少的点？考虑一个边界情况，按照此定义，对于一个叶子节点$x$，$dp[x][2]$显然无法成立，需要设成inf，这显然会影响后续的转移，所以不妨直接将状态定义为”至少覆盖到这层”的最小点数，也可以理解为对状态求后缀min。按此定义，我们可以先按照上述的递推式计算，当$x$的所有状态计算完毕后，再扫一遍取后缀min。 当覆盖到$x$下面时，子树是分叉的，所有点都需要被覆盖，因此需要求和。但当覆盖到$x$时或以上，变成了只有一支，所以我们只需要覆盖一次，其余子树选最小能覆盖的即可。所以有：$$dp[x][2] = \\min(dp[y][3] + \\sum_{s \\not = y}{dp[s][2]})$$为了程序实现方便，上述方程可以改写为$$dp[x][2] = dp[x][1] + \\min(dp[y][3] - dp[y][2])$$当能覆盖$x$上一层时，需要某个子节点向上覆盖两层，需要注意这个覆盖对于其他子树也会成立，因此有$$dp[x][3] = \\min(dp[y][4] + \\sum_{s \\not = y}{dp[s][1]})$$当$x$向上覆盖两层，显然$x$一定是被选上的，所以有$$dp[x][4] = \\sum{dp[y][0]} + 1$$} Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int maxm = 2 * maxn;int n, root = 1;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;// 影响后续计算的放状态里// 树形问题计算顺序自下而上，自上而下// 自下而上// dp[x][0]表示x一层以下都被覆盖最少代价// dp[x][1] x以下都被覆盖// dp[x][2] x被覆盖// int dp[maxn][6];// dp[x][2] = dp[x][1] + min&#123;- dp[y][2] + dp[y][3]&#125;void dfs(int x, int fa) &#123; dp[x][2] = dp[x][3] = maxn; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs(y, x); dp[x][4] += dp[y][0]; // x一层以下都被覆盖 dp[x][0] += dp[y][1]; // x以下被覆盖 dp[x][1] += dp[y][2]; // x被覆盖 dp[x][2] = min(dp[x][2], dp[y][3] - dp[y][2]); // x上一层被覆盖 dp[x][3] = min(dp[x][3], dp[y][4] - dp[y][1]); &#125; dp[x][4]++, dp[x][2] += dp[x][1], dp[x][3] += dp[x][0]; for(rint k=3; k&gt;=0; k--) dp[x][k] = min(dp[x][k], dp[x][k+1]);&#125;int main() &#123; readint(n); for(rint x=2, y; x&lt;=n; x++) &#123; readint(y); addedge(x, y), addedge(y, x); &#125; dfs(root, 0); cout &lt;&lt; dp[root][2] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"后效性的处理","slug":"后效性的处理","permalink":"http://arintaro.com/tags/后效性的处理/"}]},{"title":"AC自动机","slug":"Template/字符串/ac","date":"2019-10-28T14:07:45.546Z","updated":"2019-10-28T22:38:49.434Z","comments":true,"path":"2019/10/28/Template/字符串/ac/","link":"","permalink":"http://arintaro.com/2019/10/28/Template/字符串/ac/","excerpt":"大概可以用来AC, 本文主要是记录性质, 大概会看不懂。","text":"大概可以用来AC, 本文主要是记录性质, 大概会看不懂。 一、概念@card{ AC自动机是基于Trie建立的, Trie上的一个节点到根节点的路径会确定唯一的一个字符串,表示的是插入Trie的某个字符串的前缀。 解决多模式串匹配问题时, 先把所有的模式串插入Trie中, 再进行建树。 AC自动机对于Trie上的每个节点构造fail指针, 其指向Trie上与这个节点的后缀匹配的最长真前缀的节点, 朴素的计算方法类似KMP或者是递推, 如果父节点的fail不能继续匹配自身, 就跳fail到次长, 如果找不到就连在根节点上, 时间复杂度显然不优, 优化后建出Trie图, 同时修改Trie上边的定义, 为当前节点加上这个字符后的后缀Trie上能匹配的最长前缀, 由于没有”真”, 这对原Trie上的边也是适用的。然后我们就可以递推地以深度作为状态去计算这两种指针, 当遍历到一个节点时, 遍历字符集, 当原Trie上有这条边时, 我们需要计算它的fail, 显然是$pv[fail[x]][c]$, 即与当前节点后缀匹配的最长真前缀再加上转移的字符的后缀在Trie上能匹配的最长前缀(大概用形式化的语言说出来就没有这么绕了), 感性的理解一下就是尝试给fail再加个字符去匹配, 需要对自身跳fail去找是因为fail需要是真前缀。 多模式串匹配时, 按序遍历主串, 每次当前节点跳Trie图上的边即可, 即对每个主串的前缀, 用它的后缀去找Trie上能匹配的最长前缀, 找到这个最长前缀后, 从它一直跳fail跳到根节点, 就能找到Trie上所有能与这个后缀匹配的前缀了。 注意每个节点有且仅有一条fail边, 那么其实所有fail边与点构成一棵树, 一个节点往上跳fail的过程其实就遍历它到根节点的路径, 基于这个性质, 我们可以在fail树上跑一些树形数据结构来维护一些东西。如维护出现次数树上差分等。 } 二、实现三、代码","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"字符串","slug":"模板/字符串","permalink":"http://arintaro.com/categories/模板/字符串/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"字符串","slug":"字符串","permalink":"http://arintaro.com/tags/字符串/"}]},{"title":"小型人类智慧题/脑筋急转弯汇总","slug":"Answer/brain","date":"2019-10-27T13:24:46.584Z","updated":"2019-10-27T13:37:28.570Z","comments":true,"path":"2019/10/27/Answer/brain/","link":"","permalink":"http://arintaro.com/2019/10/27/Answer/brain/","excerpt":"自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。","text":"自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。 T1: 盛最多水的容器@card{ site: https://leetcode-cn.com/problems/container-with-most-water/ 给定一个数组, 要求$O(n)$求出最大的$|i - j| \\times \\min(arr[i], arr[j])$。 考虑枚举一个端点, 用$O(1)$的时间求出另一端的最优决策, 发现很难维护, 没有决策单调性, 按照$arr[j]$的大小分组用斜率优化+数据结构维护复杂度势必要多个$log$。 考虑重排序, 发现无论按下标排序or按值排序$abs$与$min$都很难维护。 正解是左右两端指针往中间扫, 即不确定”主指针”, 而是每次考虑移动任意一个指针去掉不可能的答案。这里每次只要把值较小的指针往中间移动即可, 正确性显然, 考虑任意一个端点在当前指针区间$[l, r]$外的的决策已经被更新进答案, 不妨设$arr[l]$较小, 则移动$l$其实就是去掉了所有左端点为$l$, 右端点在$(l, r]$的决策, 这其中的决策显然没有$[l, r]$好, 所以就推到了指针区间$[l+1, r]$所有区间外的决策已经被正确更新, 由数学归纳法知这么做不会遗漏答案。 } Solution:","categories":[{"name":"题解","slug":"题解","permalink":"http://arintaro.com/categories/题解/"}],"tags":[{"name":"人类智慧","slug":"人类智慧","permalink":"http://arintaro.com/tags/人类智慧/"}]},{"title":"小工具合集","slug":"Template/小工具/small-tool","date":"2019-10-27T10:21:08.341Z","updated":"2019-10-27T10:35:40.796Z","comments":true,"path":"2019/10/27/Template/小工具/small-tool/","link":"","permalink":"http://arintaro.com/2019/10/27/Template/小工具/small-tool/","excerpt":"比较有用, 但比较简短懒得单独开一页的技巧。","text":"比较有用, 但比较简短懒得单独开一页的技巧。 1.二进制子集枚举@card{1234int S = 22; // 全集for(int i=S; i; i=(i-1)&amp;S) &#123; // 此时i即为S的子集&#125; 枚举$n$位二进制数, 再依次枚举它的子集, 复杂度为$O(3^n)$}","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]},{"title":"Luogu 买菜","slug":"Answer/vegetable","date":"2019-10-27T02:00:24.681Z","updated":"2019-10-27T02:26:48.142Z","comments":true,"path":"2019/10/27/Answer/vegetable/","link":"","permalink":"http://arintaro.com/2019/10/27/Answer/vegetable/","excerpt":"模拟赛里的题, 没有题面(","text":"模拟赛里的题, 没有题面( Description:@card{ 给定一个字符串 𝑆 和一个字符串集合 𝑇，询问 𝑆 中最短的包含 𝑇 的子串。 } Solution:@card{ 如果我们能够在不会T掉的时间内处理出所有字符串的出现位置, 这个问题就可以直接变成选区间问题, 从而应用双指针或其他算法解决。但我考场一想, 这个玩意不是$O(n^2)$级的么, 根本不可能。然而事实上远远不到这个级别, 考虑按长度分组, 去重后每个长度显然至多会有$O(n)$级的匹配数, 由于总长度给定, 不同长度的数量至多有$O(\\sqrt{n})$种, 所以是$O(n\\sqrt{n})$的。 算法1: 字符串hash + 双指针基于上述复杂度证明, 我们可以采用子串hash与hash表直接得到一个$O(n\\sqrt{m} + m)$的多模式串匹配算法, 其中$m$为模式串总长度。具体做法是去重后按长度分组, 扫描前把这个长度的字符串的hash值插入hash表, 然后匹配即可。所以问题转化为: 在长为m的直线上有n种区间, 求直线覆盖所有n种区间的最短线段 做法有很多, 我的做法是开两个vector记录区间起点与终点：如果左指针扫到了一个起点, 那么对应种类的计数直接减一(其中可能会有当前右指针尚未扫到这个区间的终点, 导致计数器变成负数的情况, 不过不要紧); 如果右指针扫到了一个终点, 计数器直接加一, 如果计数器当前为负数, 就相当于”还上了之前欠的债”。每个区间被选上的条件是它自己的出现计数器大于等于$1$。对每个左指针让右指针一直往右扫, 直到当前选上了全部的区间。 算法2: AC自动机/后缀平衡树 + 二叉堆我还不会, 待更。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define rint register int#define ull unsigned long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define lint long long#define eco(c) ((int)(c) - 3)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const ull base = 131;const int htmod = 5000087;struct mhash_set&#123; static const int maxnode = htmod + 2; int head[maxnode], nxt[2 * maxn], id[2 * maxn], totnode; int s[2 * maxn], stop; ull val[2 * maxn]; void clear() &#123; totnode = 0; while(stop) head[s[stop--]] = 0; &#125; void insert(ull x, int nid) &#123; int pos = x % htmod; s[++stop] = pos; val[++totnode] = x, id[totnode] = nid; nxt[totnode] = head[pos], head[pos] = totnode; &#125; int find(ull x) &#123; int pos = x % htmod; for(rint i=head[pos]; i; i=nxt[i]) &#123; if(val[i] == x) return id[i]; &#125; return 0; &#125;&#125;ht;ull calc_hash(const char s[], int len) &#123; ull res = 0; for(rint i=1; i&lt;=len; i++) res = res * base + eco(s[i]); return res;&#125;int n, m;ull prehash[maxn], basepow[maxn];char s1[maxn], temp[maxn];// 第一维编号， 第二维1表示开始，-1表示结束struct str&#123; ull x; int len; str() &#123;&#125; str(ull xx, int ll): x(xx), len(ll) &#123;&#125; bool operator &lt; (const str&amp; b) const &#123; return len &lt; b.len; &#125;&#125;s2[maxn];inline ull calc_hash(int L, int R) &#123; return prehash[R] - prehash[L - 1] * basepow[R - L + 1];&#125;void match(int len) &#123; for(rint i=1; i+len-1&lt;=m; i++) &#123; ull res = calc_hash(i, i + len - 1); int nid = ht.find(res); if(nid != 0) &#123; st[i].push_back(nid), ed[i + len - 1].push_back(nid); &#125; &#125;&#125;vector&lt;int&gt; st[maxn], ed[maxn];int cnt_color[maxn], cnt = 0;int ans_len, ans_l, ans_r;inline void update(int c, int x) &#123; int pre = (cnt_color[c] &gt;= 1); cnt_color[c] += x; cnt += (cnt_color[c] &gt;= 1) - pre;&#125;void solve() &#123; ans_len = m; for(rint i=1, j=0; i&lt;=m; i++) &#123; while(j &lt;= m &amp;&amp; cnt &lt; n) &#123; j++; for(rint k=0; k&lt;ed[j].size(); k++) update(ed[j][k], 1); &#125; if(j &gt; m) return; if(j - i + 1 &lt; ans_len) &#123; ans_len = j - i + 1, ans_l = i, ans_r = j; &#125; for(rint k=0; k&lt;st[i].size(); k++) update(st[i][k], -1); &#125;&#125;int main() &#123; basepow[0] = 1; scanf(\"%s\", s1+1), m = strlen(s1 + 1); for(rint i=1; i&lt;=m; i++) &#123; basepow[i] = basepow[i-1] * base; prehash[i] = prehash[i-1] * base + eco(s1[i]); &#125; readint(n); int tot = 0; for(rint i=1; i&lt;=n; i++) &#123; scanf(\"%s\", temp+1); int len = strlen(temp + 1); ull res = calc_hash(temp, len); if(!ht.find(res)) &#123; s2[++tot] = str(res, len), ht.insert(res, i); &#125; &#125; n = tot; sort(s2+1, s2+n+1); for(rint i=1; i&lt;=n; i++) &#123; int l = i, r = i; while(r &lt;= n &amp;&amp; s2[r].len == s2[l].len) r++; i = --r; ht.clear(); for(rint j=l; j&lt;=r; j++) ht.insert(s2[j].x, j); match(s2[l].len); &#125; solve(); for(rint i=ans_l; i&lt;=ans_r; i++) putchar(s1[i]); puts(\"\"); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://arintaro.com/tags/字符串/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://arintaro.com/tags/字符串匹配/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"}]},{"title":"Luogu P1121 环状最大两段子段和","slug":"Answer/sum","date":"2019-10-24T13:24:25.109Z","updated":"2019-10-24T14:09:04.321Z","comments":true,"path":"2019/10/24/Answer/sum/","link":"","permalink":"http://arintaro.com/2019/10/24/Answer/sum/","excerpt":"大概特判才是主要难点(","text":"大概特判才是主要难点( Description:@card{ 给定一个环状序列, 可以选其中两段连续不相交的子段, 求它们的最大和 } Solution:@card{ 对于这种”两段”问题的处理, 一般有两种方法：第一种是枚举切点, 用前后两段的”一段”的最优去组合答案；第二种是在DP状态内记录当前选了几段, 从而进行转移。 算法1: 枚举切点, 正难则反考虑序列上怎么做, 显然可以枚举切点用前后两段的最大子段和组合答案。顺着想到可以破环成链跑类似的算法, 然而可能前后两段的长度加起来超过$n$, 从而使答案变大, 这里可以用数据结构维护不同长度的答案(eg. 可持久化平衡树), 然而无论怎么样, 复杂度都会多个$log$。 考虑在序列上跑完遗落了什么情况, 显然是前后两段接到一起和中间的一段组成答案, 发现这其实在序列上体现为三段, 这三段又分出来了两段, 最优解中这两段之和显然是最小的, 那么用总和减去”序列上最小两段子段和”, 一定能覆盖这种情况。 然而到这里还远没有结束, 考虑边界情况, 第一种情况只要我们枚举的”两个数之间的断点”在序列中间, 前后两段加起来至少会有两个数字, 因此是没有问题的。但是第二种情况, 我们求出的”序列上最小两段子段和”的长度$len &gt; n-2$的话, 求出来的解就是没有意义的, 由于特判范围较小, 考虑进行讨论。当$len = n$时, 显然序列中必然全是负数, 否则我们在一个正数两边切点就能得到更小的解; 当$len = n-1$时, 我们用来更新答案的值必然是序列中最大的正数, 如果存在另外一个正数, 那么第一种情况一定会比第二种情况求出的答案优秀, 不影响答案, 如果不存在另外一个正数, 那么序列中有且仅有一个正数, 我们显然可以直接得到答案。 综上, 当序列中正数只有$0$个或$1$个时, 答案为序列中的最大值加次小值, 否则可以应用我们上述的算法, 正确求出答案。 算法2: 动态规划, 一次断开, 一次强制连接考虑序列上怎么做, 显然我们可以在状态内记录当前选了几个, 以及上个选没选(其实记录上个选没选可以理解为一种小范围的状态压缩去解决一定的后效性)来转移。如果破环成链势必又面临维护麻烦的长度限制的问题, 所以考虑强制连接。 强制连接后前后两个视为一段, 在中间找第三段即可, 即求出不强制连接时的两段答案, 和强制连接后的三段答案就可覆盖所有情况。 这种方法常数不太好, 但是不用考虑麻烦的边界情况, 是考场比较优秀的算法。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2e5 + 10;const int inf = 2e9 + 10;int n;int arr[maxn], cnt = 0;int ans = -inf, sum, max1 = -inf, max2 = -inf;int presum[maxn], sufsum[maxn];void calc() &#123; for(rint i=1; i&lt;=n; i++) presum[i] = max(presum[i-1], 0) + arr[i]; for(rint i=n; i&gt;=1; i--) sufsum[i] = max(sufsum[i+1], 0) + arr[i]; for(rint i=2; i&lt;=n; i++) presum[i] = max(presum[i-1], presum[i]); for(rint i=n-1; i&gt;=1; i--) sufsum[i] = max(sufsum[i+1], sufsum[i]); &#125;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]), sum += arr[i]; if(arr[i] &gt;= 0) cnt++; &#125; for(rint i=1; i&lt;=n; i++) &#123; if(arr[i] &gt;= max1) max2 = max1, max1 = arr[i]; else if(arr[i] &gt; max2) max2 = arr[i]; &#125; ans = max1 + max2; if(cnt &lt; 2) &#123; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; calc(); for(rint i=1; i&lt;=n-1; i++) ans = max(ans, presum[i] + sufsum[i+1]); for(rint i=1; i&lt;=n; i++) arr[i] = -arr[i]; calc(); for(rint i=1; i&lt;=n-1; i++) ans = max(ans, sum + presum[i] + sufsum[i+1]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"经典模型","slug":"经典模型","permalink":"http://arintaro.com/tags/经典模型/"},{"name":"正难则反","slug":"正难则反","permalink":"http://arintaro.com/tags/正难则反/"},{"name":"两段处理","slug":"两段处理","permalink":"http://arintaro.com/tags/两段处理/"},{"name":"环形处理","slug":"环形处理","permalink":"http://arintaro.com/tags/环形处理/"}]},{"title":"Luogu P1654 OSU!","slug":"Answer/osu","date":"2019-10-24T05:40:42.504Z","updated":"2019-10-30T08:28:01.841Z","comments":true,"path":"2019/10/24/Answer/osu/","link":"","permalink":"http://arintaro.com/2019/10/24/Answer/osu/","excerpt":"感觉期望还是比较冷门的考察方向","text":"感觉期望还是比较冷门的考察方向 Description:@card{ 给定一个$n$个位置, 每个位置有$p_i$的概率为$1$, 否则为0, 每一段极大连续的$1$会产生长度的三次方的分数, 求分数的期望值 } Solution:@card{ 考虑逐个把1加入计算贡献, 不妨假设前$i-1$个位置的得分期望已经正确求出,。当该位为0时, 显然答案直接累加$i-1$的即可；当该位为1时, 会增大所有”后缀连续1”的贡献, 而对其他贡献没有影响: 对于一个长度在这之前已经为$x$的后缀1段, 增大的贡献显然为$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$, 对于所有这样的串考虑显然只需要代入期望值即可, 所以需要分别维护后缀长度平方的期望和后缀长度的期望。 注意后缀长度平方的期望不能直接由后缀长度的期望直接平方得到, 因为它自身显然是不独立的, 不能直接用期望的乘法性质, 乘法要求两个随机变量相互独立。则有: $$E(A^3_n) = p_i (E(A^3_n-1) + 3E(B^2_n-1) + 3E(B_n-1) + 1) + (1 - p_i) E(A^3_n-1)$$$$E(B^2_n) = p_i (E(B^2_n-1) + 2E(B_n-1) + 1) + (1 - p_i) \\times 0$$$$E(B_n) = p_i(E(B_n-1) + 1) + (1 - p_i) \\times 0$$ Luogu上的题解也有很多从另外的角度思考了, 复习的时候可以看一下：https://www.luogu.org/problemnew/solution/P1654} Code:@card{ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define ldob long double#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n;ldob EA3[maxn], EB1[maxn], EB2[maxn], p[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; scanf(\"%Lf\", &amp;p[i]); EB1[i] = p[i] * (EB1[i-1] + 1) + (1 - p[i]) * 0; EB2[i] = p[i] * (EB2[i-1] + 2 * EB1[i-1] + 1) + (1 - p[i]) * 0; EA3[i] = p[i] * (EA3[i-1] + 3 * EB2[i-1] + 3 * EB1[i-1] + 1) + (1 - p[i]) * EA3[i-1]; &#125; printf(\"%.1Lf\\n\", EA3[n]); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"递推","slug":"递推","permalink":"http://arintaro.com/tags/递推/"},{"name":"期望","slug":"期望","permalink":"http://arintaro.com/tags/期望/"}]},{"title":"NOIP2013 花匠","slug":"Answer/flower","date":"2019-10-23T11:53:29.869Z","updated":"2019-11-01T00:02:57.951Z","comments":true,"path":"2019/10/23/Answer/flower/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/flower/","excerpt":"与黄题斗智斗勇","text":"与黄题斗智斗勇 Description:@card{ 求一个整数序列的最长波峰序列, 详见https://www.luogu.org/problem/P1970 } Solution:@card{ 这个题思路没什么难的, 主要是实现细节与边界处理。 做法显然是划分出每个单调递增单调递减的子段, 选上峰点和开头结尾即可。 问题在于其中会有相等的数字, 对于一个区间内的很好处理, 相等是不影响当前区间的单调性的。然而我们在设初值时, 会设为$a[1], a[2]$的关系, 我一开始没有考虑$a[1]$, $a[i]$相等了该怎么办。另外, 当$n=1$和$n = 2 and a[1] == a[2]$时, “选上开头结尾”是无法做到的, 需要特判。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, ans = 2;int arr[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) readint(arr[i]); if(n == 1) cout &lt;&lt; 1 &lt;&lt; endl; else if(n == 2) cout &lt;&lt; 1 + (arr[2] != arr[1]) &lt;&lt; endl; else &#123; int x = -1; for(rint i=2; i&lt;=n; i++) &#123; if(arr[i] == arr[i-1]) continue; if(x == -1) x = (arr[i] &gt; arr[i-1]); else if((arr[i] &gt; arr[i-1]) != x) ans++, x ^= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"边界处理","slug":"边界处理","permalink":"http://arintaro.com/tags/边界处理/"}]},{"title":"NOIP2010 观光公交","slug":"Answer/bus","date":"2019-10-23T09:33:02.040Z","updated":"2019-11-01T00:02:51.743Z","comments":true,"path":"2019/10/23/Answer/bus/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/bus/","excerpt":"你以为我是DP,其实我是贪心啦dio","text":"你以为我是DP,其实我是贪心啦dio Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1315要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。 } Solution:@card{ 对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。 接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(事实上远远跑不到); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。 我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(这两个名词都是我瞎编的) 算法1：贪心直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。 同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。 算法2：优化后的贪心发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(然而并没有), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。 算法3: 数据结构优化贪心考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int inf = 1e9;int n, m, k;int cnt[maxn], leave[maxn], arrive[maxn], w[maxn];lint sum[maxn];int main() &#123; readint(n), readint(m), readint(k); for(rint i=2; i&lt;=n; i++) readint(w[i]); for(rint i=1; i&lt;=m; i++) &#123; int t, st, ed; readint(t), readint(st), readint(ed); cnt[ed]++, sum[ed] += t; leave[st] = max(leave[st], t); &#125; for(rint i=2; i&lt;=n; i++) arrive[i] = max(arrive[i-1], leave[i-1]) + w[i]; while(k != 0) &#123; int res_st = 0, res_ed = 0, res_w = 0, res_cnt = 0; for(rint i=2; i&lt;=n; ) &#123; if(w[i] == 0) &#123; i++; continue; &#125; int now_w = min(w[i], k), now_cnt = 0; rint j = i; for(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123; now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]); &#125; now_cnt += cnt[j]; if(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt; i = j + 1; &#125; if(res_w == 0) break; w[res_st] -= res_w, k -= res_w; for(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w; &#125; lint ans = 0; for(rint i=1; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"迭代","slug":"迭代","permalink":"http://arintaro.com/tags/迭代/"}]},{"title":"NOIP2009 道路游戏","slug":"Answer/road","date":"2019-10-23T02:52:08.757Z","updated":"2019-11-01T00:02:46.515Z","comments":true,"path":"2019/10/23/Answer/road/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/road/","excerpt":"千万不要以为普及组都是水题","text":"千万不要以为普及组都是水题 Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1070要点: 在任意时间必须有且仅有一个机器人,可以赔钱 } Solution:@card{ 分析一下思路,发现有明显的时间顺序,又是一个最优化问题,可以确定是动态规划。费用比较奇怪,题面描述是个边权,不过我们显然可以下放到到点上,比如$1 -&gt; 2 -&gt; 3$,从1走两次到3,累加了两段路上金币,可以发现从$i$走$p$次就是累加$[i, i + x - 1]$的金币。手玩一下可以发现只要对费用矩阵斜着求前缀和即可。由于是环形问题,为了方便最好把行上的编号重编至$[0, n-1]$。如果沿用$[1, n]$, 需要在每次”可能越界前”,先把编号-1取模再+1映射回来。 算法1：暴力DP题里没什么影响决策的限制条件,记录时间即可,转移显然需要枚举出发点和走多远,稍微算下复杂度$O(nmp)$。期望得分90pts, 实际得分100pts 算法2：转移优化DP由于给了较多的部分分,我们可以相信这与正解已经相差不远,所以先考虑转移优化,而不是状态优化。 这种求前缀和的分段转移模型,一般写出”我从哪里来”形式的方程,显然我们有: $$dp[i] = min{dp[j] + sum[x][i] - sum[(x - (i - j)) mod n][j] - val[(x - (i - j) + 1) mod n] } ( i - p &lt;= j &lt;= i - 1) $$ 注意一个细节, 序列上的”前缀和”求$[l, r]$的和时需要用$sum[r] - sum[l - 1]$,在方程中体现的是”出发点事实上是$x + 1$”。另外具体实现时,由于涉及到模意义下的减法,尽量加模数后再取模防止负数。 决策变量两维, 发现$n^2$可以接受, 考虑先枚举一维, 涉及$x$的量较多, 考虑先确定$x$, 略去$mod n$后 $$dp[i] = min{dp[j] - sum[x - (i - j)][j] - val[x - (i - j) + 1] } + sum[x][i] ( i - p &lt;= j &lt;= i - 1)$$ 可以发现与常规的优化DP不同, 一个决策$j$的价值可能与$x, i$有关,使得我们无法高效的维护决策集合,如果我们能使得$j$的价值与$x, i$无关,就可以用单调队列或平衡树等数据结构直接维护价值,每次直接转移,而不需要在得到$x, i$后对决策集合中的每个决策重新计算价值。 把确定的变量$x, i$整理到一起后, 发现内层价值数组中的下标只与$x - i$有关, 而在$mod n$意义下$x - i$的值显然至多只有$n$种,从多重背包在剩余系下的优化转移得到启发,我们可以按其在剩余系的模数分类,开$n$个不同的决策集合,这样对于决策$j$来讲关于$x - i$的部分即可化为定值。限制条件中上界下界单调递增, 显然可以用单调队列把转移的时间摊到$O(1)$ 从实际含义上讲,这对应了在费用矩阵上不同的”斜列”转移(即我们斜着求前缀和的$n$个不同序列), 每次内层$x$增加时, 对应在不同斜列上的移动。 此题启发我们可以对决策集合进行”分类”, 从而消除状态变量对一个决策价值的影响。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define eco(x) ((x) % n == 0 ? n : (x) % n)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;int n, m, p;int id[maxn][maxn], w[maxn][maxn], c[maxn];int dp[maxn], ql[maxn], qr[maxn];pii mq[maxn][maxn];int main() &#123; memset(dp, 0xc0, sizeof(dp)); readint(n), readint(m), readint(p); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(w[i][j]); &#125; &#125; for(rint i=1; i&lt;=n; i++) readint(c[i]); for(rint j=1; j&lt;=m; j++) &#123; for(rint i=1; i&lt;=n; i++) &#123; w[i][j] += w[eco(i-1)][j-1]; &#125; &#125; for(rint i=1; i&lt;=n; i++) &#123; int x = i, y = 1; ql[i] = 1, qr[i] = 1; mq[i][1] = mp(-c[i], 0); while(y &lt;= m) &#123; id[x][y] = i; x = eco(x + 1), y++; &#125; &#125; dp[0] = 0; for(rint t=1; t&lt;=m; t++) &#123; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; t - q[l].second &gt; p) l++; dp[t] = max(dp[t], w[x][t] + q[l].first); &#125; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; q[r].first &lt; dp[t] - w[x][t] - c[eco(x+1)]) r--; q[++r] = mp(dp[t] - w[x][t] - c[eco(x+1)], t); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"环形处理","slug":"环形处理","permalink":"http://arintaro.com/tags/环形处理/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"单调队列","slug":"单调队列","permalink":"http://arintaro.com/tags/单调队列/"}]},{"title":"算法学习资料汇总","slug":"Essay/算法学习资料汇总","date":"2019-10-01T05:19:49.561Z","updated":"2019-11-01T13:55:22.292Z","comments":true,"path":"2019/10/01/Essay/算法学习资料汇总/","link":"","permalink":"http://arintaro.com/2019/10/01/Essay/算法学习资料汇总/","excerpt":"主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有","text":"主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有 一、数学@card{ 线性基 https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://blog.csdn.net/a_forever_dream/article/details/83654397 博弈论 https://www.cnblogs.com/Wolfycz/p/8430991.html 2007国家集训队论文：王晓珂《解析一类组合游戏》 2009国家集训队论文：贾志豪《组合游戏略述——浅谈SG游戏的若干拓展及变形》 奇异的数列 斐波那契数列：https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、 $f[n+m]=f[m−1]∗f[n]+f[m]∗f[n+1]$ 初等数论 https://sshwy.tk/2019/01/52170/ 康托展开 https://www.luogu.org/blog/abc123-yummy/huoxingren 其实是规定了一种新的进制 } 二、图论@card{ 负环与差分约束 求最大值:初始化inf, 跑最短路、求最小值:初始化-inf, 跑最长路 SPFA的三种优化: 大于队头从队尾入队、每次队列变化时检查队头队尾距离swap、卡时2e7 双联通分量 https://linkfqy.github.io/posts/BCC_and_Tarjan/ 求点双联通分量，根节点在搜索树上需要有两个子树才能被判定为割点 } 三、字符串@card{ AC自动机https://ouuan.github.io/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/https://oi-wiki.org/string/ac-automaton/ } 四、数据结构@card{ 莫队 https://www.cnblogs.com/WAMonster/p/10118934.html 《算法竞赛中的分块思想》 杭州学军中学 ⾕晟 } 五、动态规划@card { 悬线法 2003国家集训队论文《浅谈用极大化思想解决最大子矩形问题》王知昆 树形背包的优化 https://ouuan.github.io/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/ }","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"}]},{"title":"基础数学总结","slug":"Algorithm/基础数学总结","date":"2019-09-25T07:56:33.502Z","updated":"2019-10-01T06:52:50.957Z","comments":true,"path":"2019/09/25/Algorithm/基础数学总结/","link":"","permalink":"http://arintaro.com/2019/09/25/Algorithm/基础数学总结/","excerpt":"","text":"一、数论@card{ (一) 质数与因子相关1.对于一个足够大的整数N，不超过N的质数大约有$\\frac{N}{ln(n)}$个2.一个数至少有一个小于$\\sqrt{n}$的因子，至多存在一个超过$\\sqrt{n}$的因子，因此不少算法可以只跑到$\\sqrt{n}​$3.埃筛(1) 每个数从$x^2​$开始筛即可 (2) 用$\\sqrt{r}$内的数就可以对$[l, r]$进行区间筛 4.线筛(1) 通过“积累最小质因子”的方法，去除合数 5.质因数分解(1) 不少题可以通过算术基本定理找出想法 (2) 试除法最后需要特判剩下来个大于$\\sqrt{n}$的质数的情况 (3) 有时候也可以反过来统计，不考虑它有什么因子，而是考虑“每个因子有多少个”，阶乘快速分解和倍数法基于此思想 } @card{ (二) 同余、取模相关1.不少模非质数的题目，需要对模数分解成质因子，最后用CRT/EXCTR合并答案}","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"数学","slug":"算法/数学","permalink":"http://arintaro.com/categories/算法/数学/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"}]},{"title":"基础数论","slug":"Template/基础算法/base","date":"2019-09-23T13:41:18.234Z","updated":"2019-10-28T14:06:53.665Z","comments":true,"path":"2019/09/23/Template/基础算法/base/","link":"","permalink":"http://arintaro.com/2019/09/23/Template/基础算法/base/","excerpt":"","text":"1.归并排序求逆序对@card{ $Test Site:$ https://www.acwing.com/problem/content/109/ $Code:$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e5 + 10;// 9 1 0 5 4int n;lint ans = 0;int arr[maxn], temp[maxn];void msort(int l, int r) &#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; msort(l, mid), msort(mid+1, r); // 在后面还小 for(rint i=l, j=mid+1, p=l; p&lt;=r; p++) &#123; // 一定要讨论选完的情况 if(j &gt; r || i &lt;= mid &amp;&amp; arr[i] &lt;= arr[j]) temp[p] = arr[i++]; else temp[p] = arr[j++], ans += mid - i + 1; &#125; for(rint i=l; i&lt;=r; i++) arr[i] = temp[i];&#125;int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; ans = 0; for(rint i=1; i&lt;=n; i++) readint(arr[i]); msort(1, n); printf(\"%lld\\n\", ans); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"}]},{"title":"基础数论","slug":"Template/数学/数论/基础数论","date":"2019-09-23T11:05:47.314Z","updated":"2019-09-23T11:12:04.557Z","comments":true,"path":"2019/09/23/Template/数学/数论/基础数论/","link":"","permalink":"http://arintaro.com/2019/09/23/Template/数学/数论/基础数论/","excerpt":"","text":"1.判断素数@card{ $Test Site:$ https://www.luogu.org/problem/P3383 $Code:$ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define read3(x,y,z) scanf(\"%d %d %d\",&amp;(x),&amp;(y),&amp;(z))#define putint(x) printf(\"%d \",(x))#define rint register intusing namespace std;bool isprime(int x)&#123; if(x==2||x==3) return 1; if(x==0||x==1||(x%6!=1&amp;&amp;x%6!=5)) return 0; int t = sqrt(x); for(rint i=5; i&lt;=t; i+=6) if(x%i==0||x%(i+2)==0) return 0; return 1;&#125;int main()&#123; int x , n; readint(x) , readint(n); while(n--)&#123; readint(x); puts(isp(x) ? \"Yes\" : \"No\"); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"}]},{"title":"小型冷门知识点汇总","slug":"Algorithm/小型冷门知识点汇总","date":"2019-04-28T06:06:16.512Z","updated":"2019-05-05T03:33:51.723Z","comments":true,"path":"2019/04/28/Algorithm/小型冷门知识点汇总/","link":"","permalink":"http://arintaro.com/2019/04/28/Algorithm/小型冷门知识点汇总/","excerpt":"","text":"图论 Johnson 算法 /原始对偶算法 $site:$ https://zhuanlan.zhihu.com/p/48523094、https://www.cnblogs.com/tkandi/p/10532774.html 用途：用下界$O(NM)$的时间跑一遍$SPFA$消除图内所有负权边，用以之后跑$DJ$的全源最短路径或者跑费用流。适用于需要多次求最短路的问题，有时候甚至可以带来级 ##","categories":[],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"}]},{"title":"EX数据结构","slug":"Template/数据结构/ex","date":"2019-04-28T02:46:22.952Z","updated":"2019-10-28T14:07:02.441Z","comments":true,"path":"2019/04/28/Template/数据结构/ex/","link":"","permalink":"http://arintaro.com/2019/04/28/Template/数据结构/ex/","excerpt":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。","text":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。 EX堆-配对堆@card{ 请不要对我抱有会写斐波那契堆的期望。 $test\\ site: $&lt; https://lydsy.com/JudgeOnline/problem.php?id=3040&gt; $task:$ 实现配对堆完成最短路，每次$push$输入节点编号，$top$返回最短点的节点编号，注意空间要求$O(n)$，也就是说您要实现一个内存池。 $note: $维护这种多重编号映射，一定要列表需要维护的东西 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pii pair&lt;int, int&gt;template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000000 + 10;const int maxm = 10000000 + 10;const int inf = 0x7f7f7f7f;lint dist[maxn];struct Heap&#123;&#125;q;int n, m, s;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;void calc_sp() &#123; memset(dist, 0x7f, sizeof(lint) * (n+1)); dist[s] = 0, q.push(s); while(!q.empty()) &#123; int x = q.top(); q.pop(); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &gt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; q.update(y); &#125; &#125; &#125;&#125;int main() &#123; int T, nu, nv, nw; lint x = 0, y = 0, a, b; lint rxa, rxc, rya, ryc, rp; readint(n), readint(m), s = 1; readint(T), readint(rxa), readint(rxc), readint(rya), readint(ryc), readint(rp); while(T--) &#123; x=(x*rxa+rxc)%rp; y=(y*rya+ryc)%rp; a=min(x%n+1,y%n+1); b=max(y%n+1,y%n+1); addedge(a, b, 1e8 - 100 * a); &#125; while(m--) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); &#125; calc_sp(); printf(\"%lld\\n\", dist[n]); return 0;&#125; } 2.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/categories/数据结构/"}],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"新科技","slug":"新科技","permalink":"http://arintaro.com/tags/新科技/"}]},{"title":"基础图论模板","slug":"Template/图论/基础图论","date":"2019-04-27T13:23:23.969Z","updated":"2019-05-08T08:04:19.163Z","comments":true,"path":"2019/04/27/Template/图论/基础图论/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/图论/基础图论/","excerpt":"需要$3min$内实现任意一个","text":"需要$3min$内实现任意一个 负环的判定@card{ $test\\ site: $https://www.luogu.org/problemnew/show/P3385 $task: $ 600ms以内判定负环，请注意，有多组数据，要求实现clear函数（包括邻接表 $tips: $ 对于$O(NM)$能跑过去复杂度正确的，建议写$BFS_SPFA + SLF_SWAP$，复杂度不对的写$DFS$ $extra:?$?”同时记录节点入队次数”、”卡时” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int arr[maxn]; int l, r, size; inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125; inline void push(int x) &#123; if(r == size) r = 0; arr[++r] = x; &#125; inline int pop() &#123; if(l == size) &#123;l = 1; return arr[size]; &#125; return arr[l++]; &#125; inline bool empty() &#123; return l == r + 1; &#125;&#125;q;void clear() &#123; &#125;bool check() &#123; &#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? &quot;YE5&quot; : &quot;N0&quot;); &#125; return 0;&#125; } 邻接表的删除操作card{ 可以维护一个删除标记，但是这么做在有些算法里会导致复杂度(空间or时间)退化，具体测试可以去写即时删除的配对堆。 显然我们可以再维护一个$pre$域，像普通链表一样删除，但是过于麻烦，我们可以直接把这条边的数据与表头交换，然后让表头指向下一个，但是这么做会导致边序号乱序，需要注意成对变换等对边序号有要求的信息。 } SPFA求最长路card{ 我们经常写$DJ$，也经常写最短路，但是最长路+$SPFA$我第一次写的时候却挂了。。 $test\\ stie: $ https://www.acwing.com/activity/content/code/content/34854/ $task:$ 实现循环队列，初始化$dist[1] = 0$，求最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair(x, y)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * (maxn + maxn);int n, max_val;int dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int q[maxn]; int l, r, size;&#125;q;void calc_sp() &#123; &#125;int main() &#123; int nu, nv, nw; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); nu += 1, nv += 2; // 节点编号[1, 50002] addedge(nu, nv, nw); max_val = max(max_val, max(nu, nv)); &#125; for(rint i=1; i&lt;=max_val-1; i++) addedge(i, i+1, 0), addedge(i+1, i, -1); calc_sp(); printf(\"%d\\n\", dist[max_val] - dist[1]); return 0;&#125; } 无向图的割边card{ $test\\ site: $https://www.acwing.com/problem/content/365/ $task: $实现判断割边，处理出搜索树的$deep$，$fa$数组，并在割边的子节点上标记$val[y] = 1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * 2 * maxn;int n, m, root = 1;int ans = 0;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int dfn[maxn], low[maxn], tot = 0;int deep[maxn], val[maxn], fa[maxn];void dfs(int x, int ind) &#123; low[x] = dfn[x] = ++tot; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == ind) continue; if(!dfn[y]) &#123; deep[y] = deep[x] + 1, fa[y] = x, dfs(y, i ^ 1); low[x] = min(low[x], low[y]); if(low[y] &gt; dfn[x]) val[y] = 1, ans++; &#125;else low[x] = min(low[x], dfn[y]); &#125;&#125;void clear() &#123; ans = tot = 0, totedge = 1; memset(head, 0, sizeof(int) * (n+1)); memset(dfn, 0, sizeof(int) * (n+1)); memset(val, 0, sizeof(int) * (n+1));&#125;int mem[maxn];void ask(int x, int y) &#123; int res = 0, s = 0; if(deep[x] &lt; deep[y]) swap(x, y); while(deep[x] &gt; deep[y]) &#123; mem[++s] = x, x = fa[x]; &#125; while(x != y) &#123; mem[++s] = x, mem[++s] = y; x = fa[x], y = fa[y]; &#125; for(rint i=1; i&lt;=s; i++) &#123; res += val[mem[i]], val[mem[i]] = 0; fa[mem[i]] = x; &#125; ans -= res;&#125;int main() &#123; int T = 0; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; clear(); printf(\"Case %d:\\n\", ++T); while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(root, 0); readint(m); while(m--) &#123; readint(nu), readint(nv); ask(nu, nv); printf(\"%d\\n\", ans); &#125; puts(\"\"); &#125; return 0;&#125; $Solution:$ 注意父节点来的边不能更新，具体用成对变换实现，割点不用记录，都能更新，但是要注意，按照常规割点定义，根节点必须有俩儿子“大于等于”，才能判断是，割边则是“大于”。 } 无向图的$v-dcc$缩点 + 二分图判定@card{ $test\\ site:​$ https://www.acwing.com/problem/content/367/ $task:$ 划分出图中的每个$vdcc$，并判定其是否是二分图（是否存在奇环），是的话将其每个节点的$suc$值设为$1$，并实现多组数据的清空函数 $note:$ 现用现标记，解决割点重叠问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e6 + 4 * maxn;int n, m;int edge[maxn][maxn];int head[maxn], nxt[maxm], ev[maxm], totedge = 1;inline void addedge(int x, int y) &#123; ev[++totedge] = y, nxt[totedge] = head[x], head[x] = totedge;&#125;int main() &#123; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; while(m--) readint(nu), readint(nv), edge[nu][nv] = edge[nv][nu] = 1; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=i+1; j&lt;=n; j++) &#123; // 虽然在完全图上用邻接表十分弱智,但可以降低常数 if(!edge[i][j]) addedge(i, j), addedge(j, i); &#125; &#125; int ans = 0; for(rint i=1; i&lt;=n; i++) ans += (suc[i] == 0); printf(\"%d\\n\", ans); clear(); &#125; return 0;&#125; } 欧拉回路的具体方案 $test\\ site:$ https://www.acwing.com/problem/content/368/ $task:$ 寻找一个从$1$出发，遍历所有边两次的具体方案，保证有解。 $tips:$ 注意入栈方法的实际含义。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e4 + 10;const int maxm = 1e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans[maxm], tot = 0;int s[maxm], top = 0;void solve() &#123; &#125;int main() &#123; int nu, nv; readint(n), readint(m); while(m--) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu); solve(); for(rint i=1; i&lt;=tot; i++) printf(\"%d\\n\",ans[i]); return 0;&#125; 7.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"基础数据结构","slug":"Template/数据结构/base","date":"2019-04-27T12:44:23.105Z","updated":"2019-10-28T14:06:59.668Z","comments":true,"path":"2019/04/27/Template/数据结构/base/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/数据结构/base/","excerpt":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。","text":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。 循环队列@card{ $test \\ site:$https://www.luogu.org/problemnew/show/P3385 $task:$实现一个循环队列，要求有$empty \\ \\ push\\ init(O(1))\\ \\ pop\\ \\ front $ $note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// test site: https://www.luogu.org/problemnew/show/P3385// task: 实现一个循环队列，要求有empty push init(O(1)) pop front // note: 一般用于需要多次清空队列且已知\"队列里同时存在的最多元素数量\"，// 比起STL的queue，手写的可以O(1)清空。 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; &#125;q;int cnt_path[maxn], dist[maxn];bool inq[maxn];void clear() &#123; totedge = 0; q.init(); memset(head, 0, sizeof(int) * (n+1)); memset(inq, 0, sizeof(bool) * (n+1)); memset(cnt_path, 0, sizeof(int) * (n+1)); memset(dist, 0x3f, sizeof(int) * (n+1));&#125;bool check() &#123; q.push(start), dist[start] = 0; while(!q.empty()) &#123; int x = q.pop(); inq[x] = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[x] + ew[i] &lt; dist[y]) &#123; dist[y] = dist[x] + ew[i]; cnt_path[y] = cnt_path[x] + 1; if(cnt_path[y] &gt; n) return 1; if(!inq[y]) q.push(y), inq[y] = 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? \"YE5\" : \"N0\"); &#125; return 0;&#125; $Solution:$ 懒得写了，自己看代码吧 } 2.#### 整数hash表@card{ $Test Site:https://www.luogu.org/problem/CF670C $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pll pair&lt;lint, lint&gt;#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 200000 * 3 + 10;const int mod = 599899;int arr[maxn];int n, m, totid;struct mhash&#123; int head[maxn], nxt[maxn], eco[maxn], tot; int pre[maxn], suf[maxn]; int find(int x) &#123; int nu = x % mod + 1; //别忘了+1 for(rint i=head[nu]; i; i=nxt[i]) &#123; if(pre[i] == x) return suf[i]; &#125; return 0; &#125; void insert(int x, int y) &#123; int nu = x % mod + 1; nxt[++tot] = head[nu], head[nu] = tot, pre[tot] = x, suf[tot] = y; &#125;&#125;ht;int ry[maxn], dz[maxn], dy[maxn];int cnt[maxn];int ansid = 1, ansy = -1, ansz = -1;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(ry[i]); int t = ht.find(ry[i]); if(t == 0) t = ++totid, ht.insert(ry[i], t); cnt[t]++; &#125; readint(m); for(rint i=1; i&lt;=m; i++) readint(dy[i]), dy[i] = ht.find(dy[i]); for(rint i=1; i&lt;=m; i++) readint(dz[i]), dz[i] = ht.find(dz[i]); for(rint i=1; i&lt;=m; i++) &#123; if(cnt[dy[i]] &gt; ansy || (cnt[dy[i]] == ansy &amp;&amp; cnt[dz[i]] &gt; ansz)) ansid = i, ansy = cnt[dy[i]], ansz = cnt[dz[i]]; &#125; printf(\"%d\\n\", ansid); return 0;&#125; }3.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数据结构","slug":"模板/数据结构","permalink":"http://arintaro.com/categories/模板/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://arintaro.com/tags/队列/"}]},{"title":"LNOI2019 & 多省联考 游记","slug":"Essay/LNOI2019 & 多省联考 游记","date":"2019-04-27T09:01:25.797Z","updated":"2019-04-27T13:03:09.425Z","comments":true,"path":"2019/04/27/Essay/LNOI2019 & 多省联考 游记/","link":"","permalink":"http://arintaro.com/2019/04/27/Essay/LNOI2019 & 多省联考 游记/","excerpt":"","text":"Day1:待更，鸽了","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"无病呻吟","slug":"无病呻吟","permalink":"http://arintaro.com/tags/无病呻吟/"}]},{"title":"综合技巧与实践","slug":"Detail/综合技巧与实践","date":"2019-04-27T09:01:25.547Z","updated":"2019-10-29T02:43:20.285Z","comments":true,"path":"2019/04/27/Detail/综合技巧与实践/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/综合技巧与实践/","excerpt":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。","text":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。 一、STL相关@card{ 1.algorithm1234567891011121314151.lower_bound &amp; upper_bound //我就算饿死，死外面，也不会自己写一个二分查找的 int pos = lower_bound(arr+1,arr+n+1,val) - arr; //在有序数组[1,n]中查第一个 &gt;=val的数 // 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater2.unique //常用于离散化 n = unique(arr+1,arr+n+1) - (arr+1); //去重，新元素存在[1,n] 3.inplace_merge merge // 常用于CDQ分治中，不要cdq里套sort了！！ // 数组 arr分为有序的两部分 [1,mid] [mid+1,n] inplace_merge(arr+1,arr+mid+1,arr+n+1); merge(first1,last1,first2,last2,result,compare);4.nth_element //数组中O(n)找第k大，前k个数一定都在[1，k], 内部不一定有序 nth_element(arr+1,arr+k,arr+n+1);5.sort stable_sort // 后一个可以稳定排序 6.reverse // 跟sort传参一样，序列反转 7.next_permutation, prev_permutation //排列8.partial_sort // nth_element加强版, O(nlogk)排序前k个数, [1, k]内一定有序 2.vector121.vector的clear不会释放空间，需要释放空间的话，需要: vector&lt;int&gt;().swap(a); // 但是几乎比clear慢一倍 3.输入输出相关11.cin.getline(s+1, len+1, '\\0'); // 字符数组、长度、结束字符 4.cmath11.round(double x); // 返回四舍五入的整数 %.0lf也可以 5.其他1231.fill(begin, end, val); // 填充数组long long arr[maxn][maxn];fill(arr[0], arr[0]+maxn*maxn, inf); } 二、NOI Linux相关@card{ ​ 1.Emacs相关（M为Alt键，C为Ctrl键 - M+x输入命令 C+x+k关闭当前窗口 - Options-Use CUA Keys (转换复制粘贴快捷键) - Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题） - Options-Set Default Font - Ubuntu Mono 20-30（变更字体 - C-x-2 水平切分当前Buffer, C-x-3 左右切分 - M-% 替换 - C-R 查找 - 命令 Find-file后， ~/.emacs 可以直接打开配置文件 123456789101112131415161718192021(global-linum-mode t) ;;line num 显示行号(setq c-basic-offset 3) ;; 变更缩进(setq default-tab-width 3) (electric-pair-mode t) ;;electric pair 括号补全(electric-layout-mode t)(electric-indent-mode t)(setq-default cursor-type 'bar) ;;光标竖线(show-paren-mode t) ;;show paren 括号配对(global-set-key [f4] 'shell) ;;摁F4进入shell(defun compile-file()(interactive)(compile(format \"g++ -o '%s' '%s' -lm -Wall -g\"(file-name-sans-extension(buffer-name))(buffer-name))))(global-set-key [f5] 'compile-file) ;;摁F5编译(global-set-key [f6] 'gdb) ;;摁F6进入gdb调试(global-set-key (kbd \"C-s\") 'save-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"C-a\") 'mark-the-whole-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"RET\") 'newline-and-indent) ;;回车自动缩进 } 四、对拍相关@card{ 1.程序运行时间12double t = clock();cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl; 1234#### 2.diff命令```diff -b -B test.out ans.out``` }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"STL","slug":"STL","permalink":"http://arintaro.com/tags/STL/"},{"name":"Linux","slug":"Linux","permalink":"http://arintaro.com/tags/Linux/"},{"name":"Emacs","slug":"Emacs","permalink":"http://arintaro.com/tags/Emacs/"}]},{"title":"常见代码实现细节","slug":"Detail/常见代码实现细节","date":"2019-04-27T09:01:25.528Z","updated":"2019-10-31T23:59:15.383Z","comments":true,"path":"2019/04/27/Detail/常见代码实现细节/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/常见代码实现细节/","excerpt":"","text":"这里记录的问题，全是我调过的问题orz。 &lt;!– more – &gt; @card{ 我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码 } 一、变量溢出问题@card{ 乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘 int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long， unsigned类型：值域$[0,2^{8size}-1]$溢出后对$2^{8size}$取模。 signed类型: 值$[-2^{8size-1},2^{8size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。 long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数 double用memset初始化时，跟int型一样的最值用max: 0x42, min: 0xc2,，极限值max: 0x7f, min: 0xfe。 在long long数据范围使用左移时，一定得用1LL防止溢出。 设inf时一定要小心, 0x3f最多加两次, 0x7f不能加, 有时正常数据不会爆int, 但你设的两个inf之间运算爆了int } 二、运算问题@card{ 有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数 要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除 做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值， 维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf 注意非负整数与“正整数”的区别，值域里可能会有0 有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。 } 三、语言问题@card{ 有时需要注意\\n \\r的问题，建议写手动读入的时候直接特判掉, scanf和getline混用时尤其要注意 宏定义千万别忘了括号，调一辈子，一般来说”有分割”的东西，不用加括号 lint 输入输出 %lld，ldob输入输出 %Lf 数组作为形参会退化成指针，不能再用sizeof求大小 题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0 程序中常量默认是INT型，设定 long long a = 10000 9999 9998 等一定要注意常量爆INT的问题 使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉 写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等 维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义 计算某些东西时，如果计算后需要移动指针，注意别先移动指针了（Acwing 294, 倍增LCA等） 写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧 维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。 } 四、数学相关@card{ BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$ 123if(Z == 1) return 0; //Luogu P2485 [SDOI2011]计算器if(Y % P == 0) return Z%P == 0 ? 1 : -1; i*len - ht[Yk] &gt;= 0 无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况 exgcd会求出负数解，如果求出的东西需要最小非负整数解，或者作逆元等，一定要取模到正数。 如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的 计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\\ ||\\ m&lt;0\\ ||\\ n&lt;0$时0种方案 试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于 } 五、数据结构相关@card{ 维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1] 分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错 分块题开数组不要开混了 在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数” 常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2 静态线段树空间直接开4n防越界，动态开点的范围为 $[mlog_2m, 2n-1]$ 翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放 下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响 pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去 在操作任何“实点”前需要pushdown，在修改后需要pushup 将操作重新排序后，注意是删除操作优先，还是增加操作优先 邻接表 i=nxt[i], 千万别写成 i=nxt[x] 如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。 有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。 有时需要特判“不存在”、”没找到“的情况 写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空相关指针，大部分情况数据清不清无所谓。 值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域。 树链剖分第二次$DFS$别忘了跳过重儿子。 Trie树是信息存在边的数据结构, 我们一般把其边上的信息下放到其深度较大的节点, 由于与其他我们常写的数据结构信息存储方式不同, 写的时候一定要注意。 Trie空树是有一个节点的, 即初始化时要设totnode为1 Trie节点维护信息时, 最后一次跳转后跳转终止, 但是访问到了最后一个节点, 也要更新最后一个节点的信息 12345678910111213141516171819// Accepted 由于根节点不需要存储信息void insert(int x) &#123; int p = 1, t = x; while(x != 0) &#123; int v = x % 10; x /= 10; if(pv[p][v] == 0) pv[p][v] = ++totnode, val[totnode] = t; p = pv[p][v], val[p] = min(val[p], t); &#125;&#125;// Wrong Answer 最后一个节点未被更新void insert(int x) &#123; int p = 1, t = x; while(x != 0) &#123; int v = x % 10; x /= 10; val[p] = min(val[p], t); if(pv[p][v] == 0) pv[p][v] = ++totnode, val[totnode] = t; p = pv[p][v]; &#125;&#125; 维护不相交区间的问题，可以定义小于号为$a.r &lt; b.l$，这样完全在左为小于，完全在右为大于，剩下的相等即相交 单调队列或平衡树等结构进行操作前一定要判空！！ } 六、图论相关@card{ 如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。 邻接矩阵注意初值是0还是inf，无向边一定要记得加两遍！！ 在有负权边时，树的直径不能通过两次DFS求。 无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。 带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。 在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。 建虚点，平移编号后一定要注意读入后别忘平移，节点数别忘增加。 有向图的$scc$，注意更新$low[x]$时，需要判断节点是否在栈里，回溯时判断并出栈。 无向图的$e-dcc$, 需要注意记录的是“来的边”，而不是父节点，来处理重边问题，回溯时判断并出栈，解决根节点的问题 无向图的$v-dcc$，需要注意按常规割点定义，搜索树的根节点需要有俩儿子判定成功，且割点会属于多个$v-dcc$，建议回溯到父节点时判断儿子，根节点需要特判。 缩点相关的题注意边界情况，缩成一个点等特殊情况。 找环后别忘了$tot+1$存的是最后一个节点到第一个节点的长度 用奇数偶数存正反边建正反图时, 注意对常数的影响。 } 七、动态规划相关@card{ 要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \\forall j \\ \\ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。 状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$ 有不合法状态的递推时，一定要考虑“某个现在不合法的状态”，能否在以后变成一个合法状态，能的话不能直接不计算它，为了它后置状态的正确转移必须要计算它。 维护单调队列时, 从队头出队判断合法性一定要在入队操作之后。 1234567891011121314151617181920212223// Wrong Answerfor(int i=1; i&lt;=n; i++) &#123; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++; if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]);&#125;// Acceptedfor(int i=1; i&lt;=n; i++) &#123; while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]);&#125;// Acceptedfor(int i=1; i&lt;=n; i++) &#123; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]); while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++;&#125; 在动态规划中应用单调队列时，队列最大可能是值域，别顺手写成maxn了 动态规划中用队列or变量单独维护决策时，注意上下界剪枝可能导致该入队的决策没有入队 1234567891011121314// Acceptedfor(rint j=arr[i].s+arr[i].len-1; j&gt;=m; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len));&#125;for(rint j=min(arr[i].s+arr[i].len-1, m); j&gt;=arr[i].s; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len)); dp[j] = max(dp[j], res + j * arr[i].w);&#125; // Wrong Answerfor(rint j=min(arr[i].s+arr[i].len-1, m); j&gt;=arr[i].s; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len)); dp[j] = max(dp[j], res + j * arr[i].w);&#125; 初值不要瞎填，求最大值/最小值尽量初始化-inf/inf。} 八、杂项@card{ 题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;= 一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1 在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。 交换变量时，注意变量的附带属性别忘了一起交换。 有时候题目中可能不存在“能解决所有数据、能处理所有情况“的单一算法，注意大力讨论。 进行思考、推导时，一定要注意前提条件，例如“一定可以从这个点出发找到另一个点”，这个点真的存在么？$n=1$时还存在么？ 数组复用时，一定得是“赋值”，才不用清零，如果直接用++了，别忘了清零。 用前缀和时，千万别忘了还可以取整个前缀即“ - arr[0]” 写搜索时，中间的剪枝立即回溯前也别忘了还原现场。 开邻接矩阵时，有时会有重边，注意后面覆盖前面的问题 无论是倍增还是二分答案，尽量让指针保持在定义域内，不要让其自然溢出。 我们常用的1-index下标遇上模循环节的时候一定要注意，多举反例 一定要考虑边界状况, $n = 1$或$m = 1$时算法是否还能成立。 有多个上限$n$, $m$, $t$等, 循环时一定要分清上限是哪个 一定要注意$set$是无重集合，$multiset$才能重复，我们一般用$multiset$。 } 九、奇异的语言细节@card{ 1234567// 形参中的表达式一定会被计算，但是C++标准并没有规定参数的求值顺序void test(int x,int y)&#123; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;&#125;int x = 0;test(++x,x); // 输出 1 1test(++x,x-1); // 输出1 -1 } 十、Final Check@card{ 为了防止某题正解挂的连暴力都不如, 提交前必须检查。 对拍: 写正解的题必须拍, 包括T1, 虽然暴力可能写挂, 但是正解与暴力挂的一模一样的概率极低 极限数据: 在暴力的数据范围拍完后, 必须造一组极限数据检查是否会TLE/RE/MLE 数据类型检查: double, long long与int, 尤其是经常被忽略的函数返回值 运算溢出检查: 某个地方会不会有int之间的运算, 结果却需要long或double 数组越界检查: 数组是否开的不够大？ }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"OI中的常见解题思路与技巧（更新中）","slug":"Detail/OI中的常见解题思路与技巧","date":"2019-04-27T09:01:25.509Z","updated":"2019-11-01T23:12:22.083Z","comments":true,"path":"2019/04/27/Detail/OI中的常见解题思路与技巧/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/OI中的常见解题思路与技巧/","excerpt":"也许很有用，也许没什么卵用。","text":"也许很有用，也许没什么卵用。 一、最优化问题@card{ 二分答案：答案具有“单调性”，外层花费$log\\ ans$的时间转化为判定性问题 答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的 二分出的答案对check的进行有所帮助 动态规划：一定要有最优子结构性质，和易于确定的计算顺序 贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件。 可以小范围搜索+多重限制贪心乱搞，说不定就骗到了100pts呢，考试的时候要勇于乱搞，敢于乱搞 一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质。 出题人是傻的，数据是水的，贪心+暴力是能过的，是能$AC$的。 排序、邻项交换：注意严格弱序, 没有关系没有传递性肯定不行, 没有不可比传递性可以双关键字排序。性质证明可以枚举证明。 后悔法：先选上一组可行解, 再迭代的后悔选出最优解 } 二、计数概率期望问题@card{ 思路 绝大多数是动态规划, 少部分是纯数学推式子 计数 构造划分基点, 确立无重分类 概率 讨论所有情况, 应用全概率公式与条件概率 期望 状态设计绝大多数采用逆推, 即在DAG上该点到终点的期望价值 逆推转移即为每种转移的概率乘(转移代价与后续的期望价值), 注意概率和一定要为1 若有存在多种决策影响价值计算, 求一种最优期望的决策, 状态中记录影响价值计算的决策即可, 注意不能记录”概率成功”的决策结果 一定要确定给出的概率是”顺推概率”, 还是”逆推概率” } 三、数据结构题@card{ 思路 并查集也可以用来维护序列, 有着优秀的常数和时间。 } 四、数学题@card{ 求和题：核心思想：[交换求和顺序] } 五、图论问题@card{ } 六、搜索优化策略@card{ 优化搜索顺序 即从“后续变化较少”的状态开始搜 搜前排序 排除等效亢余 给搜索固定一个顺序，例如二元组(x, y)与(y, x)不要反复搜 例如往盒子里放东西，一个东西放在不同的“空盒子”即是等效的 贪心 考虑在一个状态下做了什么决策比另一些决策更优秀 可行性、最优性剪枝 / 估价函数 即“最理想的方法”都无法满足可行或可更新答案 估价函数必须比实际路径非严格更优 有时候与范围相关的可以通过不等式放缩来去掉一些状态 双向搜索 } 七、动态规划优化策略@card{ 费用提前/延后计算 没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算 环形的处理 一次断开、一次强制连接，以覆盖所有情况 破环成链、倍增环长 后效性的处理 有分阶段后效性，阶段内部按环形处理 高斯消元（构造复杂度更优的消元方式） 对某个值域范围特别小的部分进行状压压缩, 部分状压解决有限后效性 状态压缩的优化 预处理合法状态和每个状态合法的前置状态 矩阵快速幂 递推轮数很长，方程不变 快速幂与倍增 $dp[x]$与$dp[y]$ 能推出 $dp[x + y]$ 就可应用倍增或者快速幂 DAG上的多次询问问题经常需要倍增，“预处理与拼凑” 分离无关变量 让每个决策$j$的价值只与$j$有关，在$i$增大时，每个决策的价值不变，这样就容易维护最优决策 分段转移时，方程里尽量别写“段的长度”，而是写成$i-j$，即当前与决策点的距离 确定计算顺序 DP的核心是分阶段，高度有序的计算，一般可以利用贪心先确定计算顺序，以此应用DP 决策单调性 一维状态下尽量打表，不考虑证明，具体可用一个队列维护最优决策，每次状态更新后二分地去更新后面的最优决策 二维区间DP的决策单调性 $P[i, j-1] &lt;= P[i, j] &lt;= P[i+1，j]$ 确定划分基点，构造无重分类 } 七、常见有用思想与技巧、性质@card{ 正难则反：广泛应用于各种问题 答案不容易求、不容易划分，利用全集减去补集从而求出答案 字典序最小的方案：结合性质7，倒序处理 对某个点关于其他点的计算问题，可以转化为其余点对它的贡献 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数 凹凸性（二阶导数）：凸壳优化 对称性：优化枚举顺序、减少计算量 等效转换：常见于需要计算一些奇怪的东西，找出性质转化成别的问题。 递归处理：原问题可以划分为几个相同的子问题 “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于 例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于 试填法、字典序 树上、序列上的差分与前缀和 某些计数问题可以转化为 F(x)为至少满足x的有多少个，则满足X的答案为F(x) - F(x+1). 不对原数据处理，而是“对询问” 确定计算顺序 在某些“每个点都需要满足xx条件”时，如果确定了一种“如果这个条件现在不满足，以后都满足不了”的计算顺序，就可以贪心的考虑了 离散化 不关心集合中的数的具体大小，只关心其相对大小，映射成1-size的整数 在计数问题中作为等效性的一种应用 先考虑去掉限制条件、缩小数据范围的情况 之后再逐步扩大，如DP先考虑没有限制条件的情况，再通过转移范围约束 考虑退化情况，树转化成图 “要是这样就好了” =&gt; “怎么样能变成这样” 用适当的枚举与计算顺序覆盖所有情况 有时候会有错误的转移更新答案, 但肯定没有答案优秀, 所以不影响结果 调整法 先求出一组可行解, 在逐步调整至最优解 划分决策集合, 及时排除不可能的决策 全部决策集合不容易维护, 考虑按某种性质划分成多个集合, 集合内部满足单调性等优秀性质 价值转化 直接从题面描述的价值计算方式不容易计算，考虑对每个单元计算贡献。 有时候已知全集，并且全集被划分为了两部分，知道一个部分即可求出另一个部分。 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"NOIP2018 D1T3 赛道修建","slug":"Contest/NOIP 2018/road","date":"2019-04-27T09:01:25.456Z","updated":"2019-11-01T00:04:33.469Z","comments":true,"path":"2019/04/27/Contest/NOIP 2018/road/","link":"","permalink":"http://arintaro.com/2019/04/27/Contest/NOIP 2018/road/","excerpt":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。","text":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。 Description:@card{ 给定一棵带权树，要求从树上划分出$m$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \\times 10^4$级别（实际上可以出到$5\\times10^5$左右，边权再缩小点甚至能更大，卡$sort$?(雾 } Solution:@card{ 分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助。 发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。 能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。考虑性质1：每条路径对答案的贡献其实是相同的，都是$1$，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之性质2：父节点只能有一条路径到当前节点，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在保证配对数最大的同时，还要保证剩下的深度最大，从而上传给父节点。 至此，我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下： 给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。 这里网上通常有三种实现形式，我从复杂到简洁讲： 算法1：贪心+平衡树/双向链表、删除标记首先，我们显然有性质1：应该优先配对较小的深度。 如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。 然后，我们有性质2：最优方案中，每个最小值都应该与能配对的最小的数配对，显然，不证了。基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \\ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（期望得分：55分，实际得分：100分 算法2：双指针+栈一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是能配对的最小的数。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。 STD算法：双指针那么有没有不用栈，常数更加优秀（并没有，更加简洁的算法呢？有，就是本题的std1。基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j$，配对到了左指针$i$，如果$j-1$不能与$i$配对，那么剩下的右指针也显然配对不了，所以$i$必须得与$j$配对，这时我们更新$last = j - 1$即可，如果最后考虑一个右指针$j$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]$成功配对的右指针平移到$[j,last-1]$，然后用$last$对应的值更新上传的最大值。由于网上$blog$没有对这个算法的讲解，$std$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std$在干什么。。 这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\\frac{\\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，从而实现了卡sort的可能。还有俩剪枝，二分上界可以设到$min{\\frac{\\sum{w_i}}{m}}{d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;const int rid = 8;int n, m;int root = 1, sumw = 0;int temp[maxn], rcnt[1&lt;&lt;rid], rmod = (1 &lt;&lt; rid) - 1;inline void rsort(int arr[], int n) &#123; if(n &lt; 256) &#123; sort(arr+1, arr+n+1); return; &#125; for(rint i=0; i&lt;=31; i+=rid) &#123; memset(rcnt, 0, sizeof(rcnt)); for(rint k=1; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++; for(rint j=1; j&lt;=rmod; j++) rcnt[j] += rcnt[j-1]; for(rint k=n; k&gt;=1; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k]; memcpy(arr, temp, sizeof(int) * (n+1)); &#125;&#125;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;int arr[maxn], dist[maxn];int dfs(int x, int fa, int mid) &#123; int res = 0, tot = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else arr[++tot] = dist[ev[i]] + ew[i]; &#125; rsort(arr, tot), dist[x] = 0; for(rint i=1, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123; while(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++]; if(i == j) &#123; dist[x] = arr[last]; break; &#125; if(j &amp;&amp; arr[i] + arr[j-1] &lt; mid) last = j-1; if(res &gt;= m) return res; &#125; return res;&#125;int maxd, dp[maxn];void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]); dp[x] = max(dp[x], dp[y] + ew[i]); &#125;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs2(root, root); int l = 1, r = min(maxd, sumw / m); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; } @card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define sit multiset&lt;int&gt;::iteratortemplate&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;int n, m;int root = 1;int sumw = 0, dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;multiset&lt;int&gt; s;int dfs(int x, int fa, int mid) &#123; int res = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; dist[x] = 0, s.clear(); for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else s.insert(dist[ev[i]] + ew[i]); &#125; for(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; // nxt一定在it后面 sit nxt = s.lower_bound(mid - (*it)); if(nxt == it &amp;&amp; nxt != s.end()) nxt++; if(nxt == s.end()) &#123; it++; continue; &#125; s.erase(nxt), s.erase(it++), res++; // 注意先删nxt, 不然it++可能等于nxt if(res &gt;= m) return res; &#125; if(!s.empty()) dist[x] = *s.rbegin(); return res;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; int l = 1, r = sumw / 2; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"}]},{"title":"树的相关性质(更新中)","slug":"Algorithm/树的相关性质","date":"2019-04-27T09:01:25.373Z","updated":"2019-09-26T09:29:08.998Z","comments":true,"path":"2019/04/27/Algorithm/树的相关性质/","link":"","permalink":"http://arintaro.com/2019/04/27/Algorithm/树的相关性质/","excerpt":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。","text":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。 一、树的直径@card{ （一）求法： 两次DFS比较容易求出具体路径，缺点是实现比树形DP麻烦，并且要求树的边权非负。 树形DP实现简单，但求具体路径比较麻烦，适用于只需要直径长度的情况（如二分答案的上界剪枝等），对边权没有要求。 （二）性质： 基本思想：分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。 任意一个节点作根，直径两端点一定是叶子节点。 距离任意点最远的点一定是直径的一个端点。（相当有用的性质 设从A出发找到最远点B 如果A已经是直径上一个端点，正确性显然。 如果不是，考虑反证，设直径为CD。 由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。 则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。 树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分(必须边，且除这部分外，无其他公共部分)，并且共侧的直径一段长度必然相等。 显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。 如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。 如果除这部分还有公共部分，就会形成一个环。 对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。 如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。 往一棵树里加一个点，直径的端点最多改变一个 先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。 （三）在具体题目下的证明例子 NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，然而原题不要求证明这些东西 在任意直径上求最小偏心距都相等 考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。 考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。 逃学的小孩 题意为树上要求选一个起始点与俩终点，要求最大化“起始点到两终点距离较小的+两终点的距离” 显然我们应该让直径作为这个“两个终点的距离”（如果你觉得并不显然：可以考虑三个点$A、B、C$，有三条路径$AB, BC, AC$，可以发现，如果令其中次长或最小的作为“两终点间的距离“，都没有令最长的作为优） 然后分别从直径上各个点出发暴力找起点即可。 } 二、树上点集路径","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://arintaro.com/categories/算法/图论/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"优雅的O(1)下取整log2","slug":"Template/小工具/log2","date":"2019-04-27T09:01:25.331Z","updated":"2019-10-27T10:21:41.707Z","comments":true,"path":"2019/04/27/Template/小工具/log2/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/小工具/log2/","excerpt":"还能不能再给力点呢？","text":"还能不能再给力点呢？ 1.转double法@card{ double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，是$O(1)$的。请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可） 123456#define lint long longinline lint mlog2(lint x)&#123; if(x == 1) return 0; double t = (double)x; return (lint)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1; // 注意最前面还要再转一次long long&#125; Luogu ST表 传统打表法 1011ms https://www.luogu.org/recordnew/show/13493959Luogu ST表 double法 1009ms https://www.luogu.org/recordnew/show/18155615实测后发现速度差异不大, 开了O2打表会快一些 } 2.打表法@card{ 显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论 $$\\forall k \\in [0,35], 2^kmod\\ 37,\\ 取遍[1,36]$$ } 3.double法的具体测试@card{ $test\\ site:$https://www.luogu.org/problemnew/show/P3865 $task:$ 实现函数mlog2，需要$O(1)$返回$\\lfloor log_2{x} \\rfloor​$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// test site: https://www.luogu.org/problemnew/show/P3865// 要求：实现函数mlog2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define rint register int#define lint long longusing namespace std;const int maxn = 1e5 + 10;int n, m, logn;int arr[maxn];inline lint mlog2(lint x) &#123; &#125;int rmq[20][maxn];inline void getrmq() &#123; for(rint i=1; i&lt;=n; i++) rmq[0][i] = arr[i]; for(rint d=1; d&lt;=logn; d++) &#123; int len = (1 &lt;&lt; d), half = (1 &lt;&lt; (d-1)); for(rint i=1; i+len-1&lt;=n; i++) &#123; rmq[d][i] = max(rmq[d-1][i], rmq[d-1][i+half]); &#125; &#125;&#125;inline int ask(int l, int r) &#123; int loglen = mlog2(r - l + 1); return max(rmq[loglen][l], rmq[loglen][r-(1&lt;&lt;loglen)+1]);&#125;int main() &#123; readint(n), readint(m); logn = ceil(log2(n)); for(rint i=1; i&lt;=n; i++) readint(arr[i]); getrmq(); int nl, nr; while(m--) &#123; readint(nl), readint(nr); printf(\"%d\\n\",ask(nl,nr)); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]}]}