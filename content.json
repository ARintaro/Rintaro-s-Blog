{"meta":{"title":"Rintaro's Blog","subtitle":"Algorithm and Anime","description":"某弱省一弱校高一OIer","author":"Rintaro","url":"http://arintaro.com","root":"/"},"pages":[{"title":"","date":"2019-10-31T02:20:18.129Z","updated":"2019-04-27T07:31:21.041Z","comments":false,"path":"categories/index.html","permalink":"http://arintaro.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CQOI2018 异或序列","slug":"Answer/xor","date":"2020-01-05T14:13:35.729Z","updated":"2020-01-05T14:17:47.068Z","comments":true,"path":"2020/01/05/Answer/xor/","link":"","permalink":"http://arintaro.com/2020/01/05/Answer/xor/","excerpt":"","text":"Description:@card{ 懒得写了，https://www.luogu.com.cn/problem/P4462。 } Solution:@card{ 这题其实比较水，莫队的套路题。 但是为什么我还要开个页面写一下呢？因为我第一次做的时候没有注意可以直接转化成序列中两个数异或之和，而是分了从左面加入和右面加入两种情况，写的非常麻烦，记录一下教训，转化问题要彻底，不要觉得睿智题转化一下能做就开始写，很可能有更简单的写法。 对于写法来说，长短无所谓，重要是不容易写挂和写完能跑过去。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2e5 + 10;int n, m, k;int len;int arr[maxn], bid[maxn];struct qry&#123; int id, l, r; bool operator &lt; (const qry&amp; b) const &#123; return bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; 1 ? r &lt; b.r : r &gt; b.r); &#125;&#125;q[maxn];int lcnt[maxn], rcnt[maxn];lint nowans = 0, ans[maxn];inline void move(int i, int f, bool dir) &#123; int a = arr[i] ^ k, b = arr[i-1] ^ k; if(f == 1) lcnt[a]++, rcnt[b]++; if(dir == 0) nowans += f * lcnt[arr[i-1]]; else nowans += f * rcnt[arr[i]]; if(f == -1) lcnt[a]--, rcnt[b]--; &#125;int main() &#123; readint(n), readint(m), readint(k); len = n / sqrt(m); for(int i=1; i&lt;=n; i++) &#123; readint(arr[i]), arr[i] ^= arr[i-1], bid[i] = (i - 1) / len + 1; &#125; for(int i=1; i&lt;=m; i++) readint(q[i].l), readint(q[i].r), q[i].id = i; sort(q+1, q+m+1); int l = q[1].l, r = q[1].l; move(l, 1, 0); for(int i=1; i&lt;=m; i++) &#123; while(l &lt; q[i].l) move(l++, -1, 0); while(l &gt; q[i].l) move(--l, 1, 0); while(r &lt; q[i].r) move(++r, 1, 1); while(r &gt; q[i].r) move(r--, -1, 1); ans[q[i].id] = nowans; &#125; for(int i=1; i&lt;=m; i++) printf(\"%lld\\n\", ans[i]); return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"异或问题","slug":"异或问题","permalink":"http://arintaro.com/tags/异或问题/"},{"name":"分块","slug":"分块","permalink":"http://arintaro.com/tags/分块/"},{"name":"莫队","slug":"莫队","permalink":"http://arintaro.com/tags/莫队/"}]},{"title":"HNOI2016 大数","slug":"Answer/number","date":"2020-01-05T13:35:58.533Z","updated":"2020-01-05T13:42:19.689Z","comments":true,"path":"2020/01/05/Answer/number/","link":"","permalink":"http://arintaro.com/2020/01/05/Answer/number/","excerpt":"","text":"Description:@card{ 给定一个由$0-9$中的整数构成的字符串，每次给一个子串，询问这个子串的子串中有多少在一个给定的模数的模意义下为$0$。 $1 \\leq n, m \\leq 10^5$，$1 \\leq mod \\leq 10^9$ } Solution:@card{ 难以维护的信息+可以离线，可以考虑莫队，莫队每次只要以新加入的点为端点产生的贡献即可，于是可以套路的左右两边推一下式子。 但是由于我最后忘了「由于$\\gcd(10, mod) = 1$，模意义的$10$可以随意除下去」，导致最终的式子带着与$10$有关的次幂。更睿智的是我没有提前离散化，而是开了一个哈希表，这导致了我第一次交上去$\\text{TLE}$了两个点，最终懒得思考如何优化，在写出数据生成器玄学地调了一下哈希模数和块长以$995ms$成功卡过。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define isch(x) ((x) != '\\n' &amp;&amp; (x) != '\\r' &amp;&amp; (x) != ' ')#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;inline int readstr(char s[]) &#123; int len = 0; char ch = getc(); while(!isch(ch)) ch = getc(); for(; isch(ch); ch = getc()) s[len++] = ch; return s[len] = '\\0', len;&#125;using namespace std;const int maxn = 4e5;struct mHash_table&#123; static const int htmod = 397751; int head[htmod], nxt[maxn], key[maxn], val[maxn]; int totnode; inline pii find(int nkey) &#123; int p = nkey % htmod; for(int i=head[p]; i; i=nxt[i]) &#123; if(key[i] == nkey) return mp(val[i], i); &#125; return mp(0, 0); &#125; inline void add(int nkey, int nval) &#123; int now = find(nkey).second; if(now != 0) &#123; val[now] += nval; return; &#125; int p = nkey % htmod; key[++totnode] = nkey, val[totnode] = nval; nxt[totnode] = head[p], head[p] = totnode; &#125;&#125;lht, rht;int n, m, bid[maxn], mod;int len, arr[maxn];char str[maxn];lint ans[maxn];struct qry&#123; int id, l, r; bool operator &lt; (const qry&amp; b) const &#123; return bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; 1 ? r &lt; b.r : r &gt; b.r); &#125;&#125;q[maxn];int qpow(int a, int b) &#123; int res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;namespace two_five&#123; bool vis[maxn]; int cnt[maxn]; // 结尾为特殊数字的数量 lint nowans = 0; int l, r; void move(int pos, int f, bool dir) &#123; if(f == 1) cnt[arr[pos]]++; if(dir == 0) &#123; if(mod == 2) nowans += f * (cnt[0] + cnt[2] + cnt[4] + cnt[6] + cnt[8]); else nowans += f * (cnt[0] + cnt[5]); &#125; else &#123; if(arr[pos] == 0 || (mod == 2 &amp;&amp; (arr[pos] == 2 || arr[pos] == 4 || arr[pos] == 6 || arr[pos] == 8)) || (mod == 5 &amp;&amp; arr[pos] == 5)) nowans += f * (pos - l + 1); &#125; if(f == -1) cnt[arr[pos]]--; &#125; void work() &#123; for(int i=1; i&lt;=n; i++) arr[i] = str[i] - '0'; l = q[1].l, r = q[1].l; move(l, 1, 0); for(int i=1; i&lt;=m; i++) &#123; while(l &lt; q[i].l) move(l++, -1, 0); while(l &gt; q[i].l) move(--l, 1, 0); while(r &lt; q[i].r) move(++r, 1, 1); while(r &gt; q[i].r) move(r--, -1, 1); ans[q[i].id] = nowans; &#125; &#125;&#125;;namespace others&#123; lint nowans = 0; int divpow[maxn], div10; // 在左边加 x * pow10[len] + y = 0 // 在右边加 y * 10 + x = 0 void move(int pos, int f, bool dir) &#123; // 0左边 1右边 int a = (lint)arr[pos] * divpow[pos] % mod, b = (lint)arr[pos - 1] * divpow[pos - 1] % mod; if(f == 1) lht.add(a, 1), rht.add(b, 1); if(dir == 0) nowans += f * lht.find(b).first; // 左边 else nowans += f * rht.find(a).first; if(f == -1) lht.add(a, -1), rht.add(b, -1); &#125; void work() &#123; divpow[0] = 1, div10 = qpow(10, mod - 2); for(int i=1; i&lt;=n; i++) divpow[i] = (lint)divpow[i-1] * div10 % mod; for(int i=1; i&lt;=n; i++) arr[i] = ((lint)arr[i-1] * 10 + str[i] - '0') % mod; int l = q[1].l, r = q[1].l; move(l, 1, 0); for(int i=1; i&lt;=m; i++) &#123; while(l &lt; q[i].l) move(l++, -1, 0); while(l &gt; q[i].l) move(--l, 1, 0); while(r &lt; q[i].r) move(++r, 1, 1); while(r &gt; q[i].r) move(r--, -1, 1); ans[q[i].id] = nowans; &#125; &#125;&#125;;int main() &#123; double t = clock(); readint(mod), n = readstr(str + 1); readint(m); len = (n &gt; 5e4 ? 600 : sqrt(n)); for(int i=1; i&lt;=m; i++) &#123; readint(q[i].l), readint(q[i].r), q[i].id = i; bid[i] = (i - 1) / len + 1; &#125; sort(q+1, q+m+1); if(mod == 2 || mod == 5) two_five::work(); else others::work(); for(int i=1; i&lt;=m; i++) printf(\"%lld\\n\", ans[i]); cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"分块","slug":"分块","permalink":"http://arintaro.com/tags/分块/"},{"name":"莫队","slug":"莫队","permalink":"http://arintaro.com/tags/莫队/"},{"name":"剩余系","slug":"剩余系","permalink":"http://arintaro.com/tags/剩余系/"}]},{"title":"HNOI2010 弹飞绵羊","slug":"Answer/sheep","date":"2020-01-05T10:08:20.711Z","updated":"2020-01-05T10:24:43.946Z","comments":true,"path":"2020/01/05/Answer/sheep/","link":"","permalink":"http://arintaro.com/2020/01/05/Answer/sheep/","excerpt":"","text":"Description:@card{ 给定一个序列$a_i$，每次给序列中的一个位置$p$，每次跳到$p + a_p$，直到跳出整个序列为止，问需要跳多少次，要求支持$a_i$单点修改。 $1 \\leq n, m \\leq 2 \\times 10^5$ } Solution:@card{ 此题正解$\\text{LCT}$，这里说一下分块做法。 显然我们需要利用类似「路径压缩」的思想，来平衡修改和查询的复杂度，像并查集一样直接压到终点查询$O(1)$，修改自闭，所以考虑根号平衡。 显然的想法是对每个点只压$len$步，修改一个点时重构到它距离小于$len$的节点，然而复杂度是错的，弄个菊花图反复修改菊花中心就会自闭，似乎加一些剪枝或者懒惰标记可以令复杂度正确，但是非常麻烦。 看了题解发现是直接按序列分块，每次只要保证至少跳到下一个块即可，这样修改时就比较方便，由于规定了至少跳到下一个块，这样它的前驱节点只能跟它在同一块中，于是暴力重构这个块即可。 似乎是这种类似带修改「跳节点」问题的通用分块法，按拓扑序分块一下，确保转移能至少能转移到下一块即可。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2e5 + 10;const int maxt = 500;int n, m;int len, tot;int arr[maxn], bnxt[maxn], bcnt[maxn];#define bl(x) ((x - 1) * len + 1)#define br(x) ((x) == tot ? n : (x) * len)#define bid(x) (((x) - 1) / len + 1)void build(int t) &#123; for(int i=br(t); i&gt;=bl(t); i--) &#123; int j = i + arr[i]; if(j &gt; br(t)) bnxt[i] = j, bcnt[i] = 1; else bnxt[i] = bnxt[j], bcnt[i] = bcnt[j] + 1; &#125;&#125;int main() &#123; readint(n); for(int i=1; i&lt;=n; i++) readint(arr[i]); len = sqrt(n), tot = ceil((double)n / len); for(int i=1; i&lt;=tot; i++) build(i); readint(m); int ins, x; while(m--) &#123; readint(ins); if(ins == 1) &#123; readint(x), x++; int res = 0; while(x &lt;= n) res += bcnt[x], x = bnxt[x]; printf(\"%d\\n\", res); &#125; else &#123; readint(x), x++, readint(arr[x]); build(bid(x)); &#125; &#125; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"分块","slug":"分块","permalink":"http://arintaro.com/tags/分块/"},{"name":"LCT","slug":"LCT","permalink":"http://arintaro.com/tags/LCT/"},{"name":"转移分块","slug":"转移分块","permalink":"http://arintaro.com/tags/转移分块/"}]},{"title":"Luogu 3676 小清新数据结构题","slug":"Answer/free","date":"2020-01-04T14:48:21.098Z","updated":"2020-01-04T15:00:38.973Z","comments":true,"path":"2020/01/04/Answer/free/","link":"","permalink":"http://arintaro.com/2020/01/04/Answer/free/","excerpt":"","text":"Description:@card{ 在很久很久以前，有一棵$n$个点的树，每个点有一个点权。 现在有$m$次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。 $1 \\leq n \\leq 2 \\times 10^5$ } Solution:@card{ 先想如何不换根带修改地做出答案。 一开始想了很久如何维护原权值做出来，想不出来，遂翻题解。 发现如果在数据结构上直接维护原权值，不容易计算答案，发现只有单点修改，那不妨记录每个点子树的点权和，修改一个点时只需要修改它到根链上的部分，问题转化成区间修改，区间询问平方和，显然能做。 再想如何换根，发现树中有很大一部分的答案是不变的，变的答案只有这个点到根这部分，除它自己单独计算外，发现这部分中的其他点的贡献可以通过整体减去局部后平方计算出来，由于整体和是个定值，平方后打开括号可以消除其影响，从而用之前维护的信息分别计算。 感觉这题不难，但是我还是翻了题解+调了很久，我在打开$\\sum_{1 \\leq i \\leq n}{(a_i + x)^2}$时，把它变成了$\\sum{a_i^2} + 2x\\sum{a_i} + x^2$，这问题不是我第一次犯了，以后要注意。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 4e5 + 10;const int maxm = 2 * maxn;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int arr[maxn], dfn_val[maxn];struct SMT&#123; int lson[maxn], rson[maxn], sum[maxn], ladd[maxn]; lint sum_pow[maxn]; int root, totnode; inline void pushup(int p) &#123; sum[p] = sum[lson[p]] + sum[rson[p]]; sum_pow[p] = sum_pow[lson[p]] + sum_pow[rson[p]]; &#125; inline void pushdown(int p, int l, int r) &#123; if(ladd[p] != 0) &#123; int mid = (l + r) &gt;&gt; 1; sum_pow[lson[p]] += (lint)2 * ladd[p] * sum[lson[p]] + (lint)(mid - l + 1) * ladd[p] * ladd[p]; sum_pow[rson[p]] += (lint)2 * ladd[p] * sum[rson[p]] + (lint)(r - mid) * ladd[p] * ladd[p]; sum[lson[p]] += (mid - l + 1) * ladd[p], sum[rson[p]] += (r - mid) * ladd[p]; ladd[lson[p]] += ladd[p], ladd[rson[p]] += ladd[p]; ladd[p] = 0; &#125; &#125; void build(int&amp; p, int l, int r) &#123; p = ++totnode; if(l == r) &#123; sum[p] = dfn_val[l], sum_pow[p] = (lint)sum[p] * sum[p]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(lson[p], l, mid), build(rson[p], mid + 1, r); pushup(p); &#125; void add(int p, int l, int r, int L, int R, int x) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; sum_pow[p] += (lint)2 * x * sum[p] + (lint)(r - l + 1) * x * x, sum[p] += (r - l + 1) * x; ladd[p] += x; return; &#125; pushdown(p, l, r); int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid) add(lson[p], l, mid, L, R, x); if(R &gt; mid) add(rson[p], mid + 1, r, L, R, x); pushup(p); &#125; inline void add(int L, int R, int x) &#123; add(root, 1, n, L, R, x); &#125; lint ask_sum(int p, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[p]; pushdown(p, l, r); int mid = (l + r) &gt;&gt; 1; lint res = 0; if(L &lt;= mid) res += ask_sum(lson[p], l, mid, L, R); if(R &gt; mid) res += ask_sum(rson[p], mid + 1, r, L, R); return res; &#125; inline lint ask_sum(int L, int R) &#123; return ask_sum(root, 1, n, L, R); &#125; lint ask_pow(int p, int l, int r, int L, int R) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum_pow[p]; pushdown(p, l, r); int mid = (l + r) &gt;&gt; 1; lint res = 0; if(L &lt;= mid) res += ask_pow(lson[p], l, mid, L, R); if(R &gt; mid) res += ask_pow(rson[p], mid + 1, r, L, R); return res; &#125; inline lint ask_pow(int L, int R) &#123; return ask_pow(root, 1, n, L, R); &#125;&#125;smt;int root = 1;int size[maxn], deep[maxn], dfa[maxn];int wson[maxn], wtop[maxn];int dfn[maxn], dfr[maxn], totdfn = 0;int color[maxn], sum[maxn];void dfs1(int x, int d, int fa, int nc) &#123; deep[x] = d, dfa[x] = fa, size[x] = 1, sum[x] = arr[x]; color[x] = nc; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, d + 1, x, x == root ? y : nc); size[x] += size[y], sum[x] += sum[y]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125;&#125;void dfs2(int x, int top) &#123; dfn[x] = ++totdfn, wtop[x] = top, dfn_val[totdfn] = sum[x]; if(wson[x]) dfs2(wson[x], top); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == wson[x] || y == dfa[x]) continue; dfs2(y, y); &#125; dfr[x] = totdfn;&#125;// 首先累加不在它到根链上点的总贡献 和它和它子树内部的贡献，用总体权值-链上权值lint ask(int x) &#123; if(x == root) return smt.ask_pow(1, n); lint sumr = smt.ask_sum(dfn[root], dfn[root]), now = 0; lint res = smt.ask_pow(1, n) + (deep[x] - 1) * sumr * sumr; while(wtop[x] != wtop[color[x]]) &#123; now += smt.ask_sum(dfn[wtop[x]], dfn[x]); x = dfa[wtop[x]]; &#125; now += smt.ask_sum(dfn[color[x]], dfn[x]); res -= 2 * sumr * now; return res;&#125;void change(int x, int nval) &#123; int d = nval - arr[x]; arr[x] = nval; while(wtop[x] != wtop[root]) &#123; smt.add(dfn[wtop[x]], dfn[x], d); x = dfa[wtop[x]]; &#125; smt.add(dfn[root], dfn[x], d);&#125;int main() &#123; readint(n), readint(m); int nu, nv; for(int i=1; i&lt;n; i++) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; for(int i=1; i&lt;=n; i++) readint(arr[i]); dfs1(root, 1, 0, 0), dfs2(root, root); smt.build(smt.root, 1, n); int ins, x, y; while(m--) &#123; readint(ins); if(ins == 1) readint(x), readint(y), change(x, y); else readint(x), printf(\"%lld\\n\", ask(x)); &#125; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"换根法","slug":"换根法","permalink":"http://arintaro.com/tags/换根法/"},{"name":"线段树","slug":"线段树","permalink":"http://arintaro.com/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://arintaro.com/tags/树链剖分/"}]},{"title":"SCOI2016 美味","slug":"Answer/meal","date":"2020-01-04T12:07:07.179Z","updated":"2020-01-04T12:18:30.941Z","comments":true,"path":"2020/01/04/Answer/meal/","link":"","permalink":"http://arintaro.com/2020/01/04/Answer/meal/","excerpt":"","text":"Description:@card{ 给一个序列$a_j$，每次询问给定$b_i$，$x_i$，$L, R$，要求对于$j \\in[L, R]$，使$b_i \\ xor\\ (x_i + a_j)$最大 } Solution:@card{ 首先暴力肯定不行，不暴力又发现$x_i + a_j$对于$xor$结果的影响并不容易计算。 一开始一直考虑怎么在可持久化$Trie$上做，然后发现完全做不了，（对每个$Trie$节点维护一个可持久化平衡树。 题解是考虑一个类似过程，与位运算有关的问题一般要拆位考虑，对每一位考虑，判断这一位能否选与$b_i$这位不同的数字。 关键在于这个判断能否选的过程，判断是否存在一个$x_i + a_j$使得这位为$0$或$1$，与位运算不同，我一开始考虑这个东西怎么按位拆开判断，然而根本不用，对于加法和减法，最简单的约束条件就是转化成不等式，考虑使得这位$0$或这位为$1$的范围，不妨归纳地考虑，考虑之前的位的$x_i + a_j$已经选好设为$pre$。下面考虑这位$t$要选$0$的情况，其中$*$是前面的位，显然上面是下界，下面是上界。 **000000 **011111 雾，所以我们可以列出$x_i + a_j \\in [pre, pre + (1 &lt;&lt; t) - 1]$这个不等式，把$x_i$移过去即消除了询问的影响，加上$[L, R]$，即转化成一个二维平面上的偏序问题，可以直接解决。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;inline int mlog2(int x) &#123; if(x &lt;= 1) return 0; double t = x; return (int)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1;&#125;using namespace std;const int maxn = 2e5 + 10;const int maxd = 19;const int maxnode = maxn * maxd;int n, m, maxv = 1e5;int lson[maxnode], rson[maxnode], sum[maxnode];int root[maxn], totnode;void add(int&amp; p, int pre, int l, int r, int pos, int nval) &#123; p = ++totnode; if(l == r) &#123; sum[p] = sum[pre] + nval; return; &#125; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) rson[p] = rson[pre], add(lson[p], lson[pre], l, mid, pos, nval); else lson[p] = lson[pre], add(rson[p], rson[pre], mid + 1, r, pos, nval); sum[p] = sum[lson[p]] + sum[rson[p]];&#125;bool ask(int p, int pre, int l, int r, int L, int R) &#123; if(L &gt; R) return 0; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[p] - sum[pre]; int mid = (l + r) &gt;&gt; 1; if(L &lt;= mid &amp;&amp; ask(lson[p], lson[pre], l, mid, L, R)) return 1; if(R &gt; mid &amp;&amp; ask(rson[p], rson[pre], mid + 1, r, L, R)) return 1; return 0;&#125;inline bool ask(int L, int R, int l, int r) &#123; return ask(root[R], root[L-1], 0, maxv, max(l, 0), min(r, maxv));&#125; int main() &#123; readint(n), readint(m); int x = 0; for(int i=1; i&lt;=n; i++) readint(x), add(root[i], root[i-1], 0, maxv, x, 1); int b, L, R; while(m--) &#123; readint(b), readint(x), readint(L), readint(R); int pre = 0, ans = 0; // 找 a + x for(int t=maxd; t&gt;=0; t--) &#123; if((b &gt;&gt; t) &amp; 1) &#123; // a + x这位需要为0 // *****00000 // *****01111 // a + x \\in [pre, pre + (1 &lt;&lt; t) - 1] bool suc = ask(L, R, pre - x, pre + (1 &lt;&lt; t) - 1 - x); if(suc) ans += (1 &lt;&lt; t); else pre += (1 &lt;&lt; t); &#125; else &#123; // a + x这为需要为1 // ****10000 // ****11111 bool suc = ask(L, R, pre + (1 &lt;&lt; t) - x, pre + (1 &lt;&lt; (t + 1)) - 1 - x); if(suc) ans += (1 &lt;&lt; t), pre += (1 &lt;&lt; t); &#125; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"可持久化数据结构","slug":"可持久化数据结构","permalink":"http://arintaro.com/tags/可持久化数据结构/"},{"name":"异或问题","slug":"异或问题","permalink":"http://arintaro.com/tags/异或问题/"}]},{"title":"HNOI2015 开店","slug":"Answer/shop","date":"2020-01-04T11:05:48.020Z","updated":"2020-01-04T11:15:25.509Z","comments":true,"path":"2020/01/04/Answer/shop/","link":"","permalink":"http://arintaro.com/2020/01/04/Answer/shop/","excerpt":"","text":"Description:@card{ 给一棵带边权和点权的树，每次询问一个点到所有点权范围为$[L, R]$的点的距离和，强制在线。 $n \\leq 1.5 \\times 10^5$，$m \\leq 2 \\times 10^5$ } Solution:@card{ 显然可以建出点分树，每次查询即可，如果可以离线就点分治就行。 重点说一下树剖的思路，这题显然是套了一个查点权范围的壳，以卡掉一些做法。所以先考虑不带点权怎么做，推一下式子发现重点是维护$\\sum_{1 \\leq j \\leq n}{d_{\\text{lca}(i, j)}}$，其中$d$表示某个节点到根的距离，从题解中学到一种做法，对每个点考虑它的贡献为「这两个点从到根的路径交集」，所以我们可以先对所有的$j$覆盖一次它到根的路径，查询时只查询问点到根就行。 然而树剖空间复杂度是错的，不少主席树的题空间两个$\\log$，跑到上界大概都需要几G的空间，然而没人卡.. 下面的代码是点分树的，由于我写的时候大脑短路，觉得好像要修改点权，就敲了个平衡树。。实际上不带修用$\\text{vector}$即可，但是这样复杂度是一样，常数不太好。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define pii pair&lt;int, lint&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1.5e5 + 10;const int maxm = 2 * maxn;const int maxd = 20;const int maxnode = maxn * maxd;int n, m, maxa;struct SBT&#123; static int ch[maxnode][2], size[maxnode], key[maxnode], val[maxnode], totnode; static lint sum[maxnode]; int root; inline void rotate(int&amp; x, bool c) &#123; int y = ch[x][c]; ch[x][c] = ch[y][c ^ 1], ch[y][c ^ 1] = x; size[y] = size[x], sum[y] = sum[x]; size[x] = size[ch[x][0]] + size[ch[x][1]] + 1; sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; x = y; &#125; void maintain(int&amp; x, bool c) &#123; if(size[ch[ch[x][c]][c]] &gt; size[ch[x][c ^ 1]]) rotate(x, c); else if(size[ch[ch[x][c]][c ^ 1]] &gt; size[ch[x][c ^ 1]]) rotate(ch[x][c], c ^ 1), rotate(x, c); else return; maintain(ch[x][0], 0), maintain(ch[x][1], 1); maintain(x, 0), maintain(x, 1); &#125; inline int newnode(int nkey, int nval) &#123; size[++totnode] = 1, key[totnode] = nkey, val[totnode] = sum[totnode] = nval; return totnode; &#125; void insert(int&amp; p) &#123; if(p == 0) &#123; p = totnode; return; &#125; size[p]++, sum[p] += val[totnode]; insert(ch[p][key[totnode] &gt;= key[p]]); maintain(p, key[totnode] &gt;= key[p]); &#125; inline void insert(int nkey, int nval) &#123; newnode(nkey, nval), insert(root); &#125; // 第一维cnt，第二维sum pii getsum(int p, int nkey) &#123; if(p == 0) return mp(0, 0); if(nkey &gt;= key[p]) &#123; pii res = getsum(ch[p][1], nkey); res.first += size[ch[p][0]] + 1, res.second += sum[ch[p][0]] + val[p]; return res; &#125; else return getsum(ch[p][0], nkey); &#125; pii ask(int L, int R) &#123; pii rt = getsum(root, R), lt = getsum(root, L - 1); rt.first -= lt.first, rt.second -= lt.second; return rt; &#125;&#125;;int SBT::ch[maxnode][2], SBT::size[maxnode], SBT::key[maxnode], SBT::val[maxnode], SBT::totnode;lint SBT::sum[maxnode];int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;bool vis[maxn];int rmax, nrot, ntot;int size[maxn];void dfs1(int x, int fa) &#123; size[x] = 1; int nmax = 0; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa || vis[y]) continue; dfs1(y, x), size[x] += size[y]; nmax = max(nmax, size[y]); &#125; nmax = max(nmax, ntot - size[x]); if(nmax &lt; rmax) rmax = nmax, nrot = x;&#125;int arr[maxn];int totbst = 0;SBT bst[maxnode];vector&lt;int&gt; prt[maxn], pdis[maxn], bstid[maxn];vector&lt;int&gt; rtbst[maxn];void dfs2(int x, int d, int fa) &#123; prt[x].push_back(nrot), pdis[x].push_back(d), bstid[x].push_back(totbst); bst[totbst].insert(arr[x], d), size[x] = 1; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa || vis[y]) continue; dfs2(y, d + ew[i], x); size[x] += size[y]; &#125;&#125;void dfs3(int x) &#123; vis[x] = 1; // cerr &lt;&lt; x &lt;&lt; endl; prt[x].push_back(x), pdis[x].push_back(0), bstid[x].push_back(0); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y]) continue; rtbst[x].push_back(++totbst), dfs2(y, ew[i], x); &#125; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y] || size[y] == 1) continue; rmax = maxn, nrot = 0, ntot = size[y]; dfs1(y, x), dfs3(nrot); &#125;&#125;lint ask(int x, int L, int R) &#123; lint res = 0; for(int i=0; i&lt;prt[x].size(); i++) &#123; if(prt[x][i] == x) &#123; // 为根 for(int j=0; j&lt;rtbst[x].size(); j++) res += bst[rtbst[x][j]].ask(L, R).second; &#125; else &#123; // 不为根 int rt = prt[x][i]; for(int j=0; j&lt;rtbst[rt].size(); j++) &#123; if(rtbst[rt][j] == bstid[x][i]) continue; pii now = bst[rtbst[rt][j]].ask(L, R); res += (lint)now.first * pdis[x][i] + now.second; &#125; if(L &lt;= arr[rt] &amp;&amp; arr[rt] &lt;= R) res += pdis[x][i]; &#125; &#125; return res;&#125;int main() &#123; readint(n), readint(m), readint(maxa); for(int i=1; i&lt;=n; i++) readint(arr[i]); int nu, nv, nw; for(int i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; rmax = maxn, nrot = 0, ntot = n; dfs1(1, 0), dfs3(nrot); int x, a, b; lint res = 0; while(m--) &#123; readint(x), readint(a), readint(b); int l = (a + res) % maxa, r = (b + res) % maxa; if(l &gt; r) swap(l, r); res = ask(x, l, r); printf(\"%lld\\n\", res); // res = 0; &#125; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"动态点分治","slug":"动态点分治","permalink":"http://arintaro.com/tags/动态点分治/"}]},{"title":"ZJOI2007 捉迷藏","slug":"Answer/hide","date":"2020-01-04T09:08:14.865Z","updated":"2020-01-04T09:30:54.099Z","comments":true,"path":"2020/01/04/Answer/hide/","link":"","permalink":"http://arintaro.com/2020/01/04/Answer/hide/","excerpt":"","text":"Description:@card{ 给定一颗树，分两类点，一类黑点一类白点，要求支持两种操作，查询当前所有黑点两两间距离的最大值，和改变一个点的颜色。 $1 \\leq n \\leq 2000$ } Solution:@card{ 点分治做法不提了，大概是动态模拟点分治的过程，开很多个堆维护答案，代码见下面。 括号序列做法难以想到，技巧性强，代码比点分治做法短很多，但是也不是很好写，非常容易写挂。 括号序列是像$(1(2)(3))$这样的东西，这表示它遍历点$1$，然后依次遍历了$2,3$两个儿子。 首先有一个结论，对于边权为$1$的树，跑一个它的括号序，两点间的距离即为对应括号序列子段不匹配的括号数。这个显然可以用线段树维护，类似摩尔投票法？但是一般我们求距离都用$LCA$，跑的比线段树快多了，所以这个结论就比较鸡肋。 但是本题中，我们考虑如何动态维护两个黑点间的最大距离，也就是在分治结构上，必须以较低代价合并左右两个儿子的信息，就能利用线段树维护答案。 显然在一次合并信息中，我们只需要考虑跨区间的答案，不妨对一段区间设$(x, y)$，其中$x$表示它未匹配的右括号数量，$y$表示左括号的。 显然可以快速合并这两个区间，并得到新区间的答案，大概是类似$x_l + y_l - x_r + y_r$或$x_l - y_l + x_r + y_r$，对应两种$y_l$和$x_r$大小关系不同的情况，但是问题是：在分治结构上，左边和右边都各有$O(n)$个区间，暴力匹配是$O(n^2)$，拆拆式子用单调队列似乎可以做到$O(n)$？这对不修改是可以接受的，但是对于修改后合并信息完全不行，单次修改的复杂度会变成$O(n)$。 所以，要想快速合并信息，我们必然要拆开左右两边的信息，使其独立，我们就可以分别找两面$\\max$，然后简单的相加从而合并信息。 问题在于合并信息时，由于$y_l$和$x_r$的大小关系，会产生不同的贡献。容易想到是否存在一种计算方式使得不合法的信息不会被统计。 简单来说，我们发现一个区间合并信息对答案的贡献只有三种，即$x + y$，$x - y$， $y - x$。可以分别求出它们在各个情况下的最大值，然后直接相加合并。正确性是由于：考虑$x_l + y_l - x_r + y_r$的情况，这代表$y_l &gt; x_r$，如果存在一个$y_l &lt; x_r$，并且这样的式子成为了我们的答案，就会对答案造成影响，但是在这种情况下$x_l - y_l + x_r + y_r$显然会比它更大，只要我们考虑了这种情况，不合法的情况就不会影响答案。 这种「虽然当前统计了不合法的方案，但是在取最优的过程中不会影响答案」的方法，降低了限制条件的要求，从而可以在线段树上高效维护。 我们可以直接对于不合法的位置，把它节点三种答案贡献都设为$-inf$，即可简单的只求黑点间的答案，注意这个$inf$可能会被多次相加相减，因此千万不要开太大，比$maxn$大即可。 这种方法的代码在我写出来后，没过样例，于是准备拍个小数据调一下，把之前的数据生成器和暴力复制过来后，一不小心把之前的代码也复制过来了，导致这份代码被覆盖，也就是说：丢了。。丢了。。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define isch(x) ((x) != '\\n' &amp;&amp; (x) != '\\r' &amp;&amp; (x) != ' ')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch -'0'; x *= f;&#125;inline void readstr(char s[]) &#123; int len = 0; char ch = getc(); while(!isch(ch)) ch = getc(); for(; isch(ch); ch = getc()) s[len++] = ch; s[len] = '\\0';&#125;using namespace std;const int maxn = 1e5 + 10;const int maxm = 2 * maxn;const int maxd = 20;const int maxnode = maxn * maxd;const int inf = 1e9;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;struct Heap&#123; static int son[maxnode], bro[maxnode], fa[maxnode], val[maxnode]; static int s[maxnode], stop, totnode; int root, cnt; int merge(int x, int y) &#123; if(x == 0 || y == 0) return x + y; if(val[x] &gt; val[y]) swap(x, y); // 大根堆 bro[x] = son[y], fa[son[y]] = x; son[y] = x, fa[x] = y; return y; &#125; int merge(int x) &#123; fa[x] = 0; if(x == 0 || bro[x] == 0) return x; int y = bro[x], p = bro[y]; bro[x] = bro[y] = fa[y] = 0; return merge(merge(x, y), merge(p)); &#125; inline int push(int nval) &#123; int p = stop ? s[stop--] : ++totnode; son[p] = bro[p] = fa[p] = 0, val[p] = nval; root = merge(root, p), cnt++; return p; &#125; inline int top1() &#123; return root ? val[root] : -inf; &#125; inline int top2(int p) &#123; return bro[p] ? max(top2(bro[p]), val[p]) : val[p]; &#125; inline int top2() &#123; return son[root] ? top2(son[root]) : -inf;&#125; inline void pop() &#123; s[++stop] = root, root = merge(son[root]), cnt--; &#125; inline void erase(int x) &#123; if(x == 0) return; if(x == root) &#123; pop(); return; &#125; s[++stop] = x, cnt--; int&amp; p = son[fa[x]] == x ? son[fa[x]] : bro[fa[x]]; p = bro[x], fa[p] = fa[x]; root = merge(root, merge(son[x])); &#125; inline int size() &#123; return cnt; &#125; inline void print(int p) &#123; if(p == 0) return; print(bro[p]), printf(\"%d \", val[p]), print(son[p]); &#125; inline void print() &#123; printf(\"print: \"), print(root), putchar('\\n'); &#125;&#125;q[maxnode];int Heap::son[maxnode], Heap::bro[maxnode], Heap::fa[maxnode];int Heap::val[maxnode];int Heap::s[maxnode], Heap::stop, Heap::totnode;bool vis[maxn];int size[maxn];int rmax = 0, nrot = 0, ntot = 0;void dfs1(int x, int fa) &#123; size[x] = 1; int nmax = 0; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa || vis[y]) continue; dfs1(y, x); size[x] += size[y]; nmax = max(nmax, size[y]); &#125; nmax = max(nmax, ntot - size[x]); if(nmax &lt; rmax) rmax = nmax, nrot = x;&#125;bool dark[maxn];int totq, rt;vector&lt;int&gt; mqid[maxn], qid[maxn], qpos[maxn], dist[maxn];int ntpos[maxnode], mtpos[maxnode], mtlast[maxnode];void dfs2(int x, int fa, int d, int mt, int nt) &#123; dist[x].push_back(d), mqid[x].push_back(mt), qid[x].push_back(nt); qpos[x].push_back(dark[x] ? q[nt].push(d) : 0); size[x] = 1; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa || vis[y]) continue; dfs2(y, x, d + 1, mt, nt); size[x] += size[y]; &#125;&#125;void dfs3(int x) &#123; vis[x] = 1; // 先声明主堆 int mt = ++totq; mqid[x].push_back(mt), qid[x].push_back(mt), dist[x].push_back(0); qpos[x].push_back(dark[x] ? q[mt].push(0) : 0); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y]) continue; int nt = ++totq; dfs2(y, x, 1, mt, nt); ntpos[nt] = q[mt].push(q[nt].top1()); &#125; if(q[mt].size() &gt; 1) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2()); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y] || size[y] == 1) continue; rmax = maxn, nrot = 0, ntot = size[y]; dfs1(y, x), dfs3(nrot); &#125;&#125;inline void recalc(int mt) &#123; if(mtpos[mt]) q[rt].erase(mtpos[mt]); if(q[mt].size() &gt; 1) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2()); else mtpos[mt] = 0;&#125;inline void change(int x) &#123; if(dark[x]) &#123; for(int i=0; i&lt;mqid[x].size(); i++) &#123; int mt = mqid[x][i], nt = qid[x][i], pos = qpos[x][i]; if(mt == nt) &#123; // 是中心点 q[mt].erase(pos), recalc(mt); &#125; else &#123; if(q[nt].top1() == dist[x][i]) &#123; // 不是中心点 q[nt].erase(pos), q[mt].erase(ntpos[nt]); if(q[nt].size()) ntpos[nt] = q[mt].push(q[nt].top1()); recalc(mt); &#125; else q[nt].erase(pos); &#125; &#125; &#125; else &#123; for(int i=0; i&lt;mqid[x].size(); i++) &#123; int mt = mqid[x][i], nt = qid[x][i], &amp;pos = qpos[x][i], d = dist[x][i]; // 注意更新pos if(mt == nt) &#123; pos = q[mt].push(0), recalc(mt); &#125; else &#123; int pre = q[nt].top1(); if(d &gt; pre) &#123; pos = q[nt].push(d); if(pre != -inf) q[mt].erase(ntpos[nt]); ntpos[nt] = q[mt].push(d); recalc(mt); &#125; else pos = q[nt].push(d); &#125; &#125; &#125; dark[x] ^= 1;&#125;int main() &#123; readint(n); int nu, nv; for(int i=1; i&lt;n; i++) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; rt = ++totq; for(int i=1; i&lt;=n; i++) dark[i] = 1; rmax = maxn, nrot = 0, ntot = n; dfs1(1, 0), dfs3(nrot); char ins[10]; int x = 0; readint(m); while(m--) &#123; readstr(ins); if(ins[0] == 'G') printf(\"%d\\n\", q[rt].size() ? q[rt].top1() : -1); else readint(x), change(x); &#125; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"http://arintaro.com/tags/线段树/"},{"name":"动态点分治","slug":"动态点分治","permalink":"http://arintaro.com/tags/动态点分治/"},{"name":"点分治","slug":"点分治","permalink":"http://arintaro.com/tags/点分治/"},{"name":"括号序列","slug":"括号序列","permalink":"http://arintaro.com/tags/括号序列/"}]},{"title":"HNOI2015 接水果","slug":"Answer/fruit","date":"2020-01-03T01:26:59.528Z","updated":"2020-01-03T01:57:25.053Z","comments":true,"path":"2020/01/03/Answer/fruit/","link":"","permalink":"http://arintaro.com/2020/01/03/Answer/fruit/","excerpt":"","text":"Description:@card{ 给定树上一些路径，每个路径有一些权值，构成一个集合。每次询问给出一条路径，回答之前那个集合中为其子路径的所有路径中，权值第$k$大的路径。 $n, m, q \\leq 4\\times10^4$ } Solution:@card{ 首先需要转化，看见这个数据范围，我们可以选择用手写$\\text{bitset}$水过去。 考虑一个路径什么时候是另一个路径的子路径，正常思路是考虑一个询问，再考虑之前集合中有哪些满足的，可以跑一遍$\\text{DFS}$序从而转化成序列上的问题 显然需要分类讨论，即这个路径是否在树上「转弯」了，已知$x, y$是这条询问路径的两个端点 当$\\text{lca}(x, y) = y$时，需要集合路径的两个端点$u, v$都在这里面，即$dfn[y] \\leq dfn[u] \\leq dfn[x] \\leq dfr[u] \\leq dfr[y]$，$v$也同样要满足这些条件，拆下不等式可以发现每个物品有$4$个属性，为两个端点开始和结束的时间戳，外层还有个$kth$，这种问题显然没法维护，整体二分套KDT的优秀做法。 所以我们需要反过来考虑，考虑离线之后，对集合中的每个路径考虑它可以被哪些询问统计： 这样对于询问两端点的$\\text{lca}$是其中一个的情况，可以直接想象出为「一个端点在$x$的子树中，另一个端点在「把树横过来」$y$的子树中」，第一个条件可以直接用深度较大的节点开始和结束时间戳限制，第二个条件利用补集思想转化为「不在$y \\rArr x$路径上的一个节点的子树中」即可；不是的情况，可以直接转化成两个端点子树内，更加简单。 这样我们发现我们只需要考虑询问两端点的$dfn$，这样就只有两个属性了，问题即转化成「二维平面上，每次选一个矩形，往这个矩形的每个格子中多放一个权值，结束后询问一些点中第$k$大的矩形」，对于外层的$kth$，我们可以直接整体二分去掉，问题变为二维矩形加，单点询问，可以直接$\\text{KDT}$解决，但是由于这根本是个离线问题，我们可以用先排序，内层再扫描线维护矩形加的形式，把一个二维问题的两个$\\log$分离，从做到$O(nlog^2n)$的复杂度。 实现时仍然需要注意细节，此问题中的点对是无序的，也就是说，如果不规定顺序把什么样的节点放第一维上，什么样的放第二维上，很可能会导致「在矩形加时，你规定第一维的节点在$x$的子树中，第二维在$y$的子树中，而一个询问它第一维的节点在$y$的子树中，而第二维在$x$的子树中」，就无法统计贡献，直接的想法是在矩形加时两种顺序都加，或者是询问时两种都计算贡献，然而都会多个二倍常数。 更好的办法是利用本题的性质，本题中的两维矩形加的区间都是「相互不包含的」，这样对于一个询问点$x, y$，如果存在一种顺序使这个矩形可以覆盖到它，那么一定是较小的点对应较小区间，也就是我们可以给它强行规定一个顺序。 代码写的比较麻烦，听人说封装结构体排序很慢，所以故意规避掉了在整体二分部分的封装，所以代码变得很长，但是速度似乎没怎么提升。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 4e4 + 10;const int maxm = 8 * maxn;int n, m, totq;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int root = 1;int dfn[maxn], dfr[maxn], totdfn = 0;int size[maxn], deep[maxn], dfa[maxn];int wson[maxn], wtop[maxn];void dfs1(int x, int d, int fa) &#123; dfn[x] = ++totdfn, size[x] = 1, deep[x] = d, dfa[x] = fa; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, d + 1, x); size[y] += size[x]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125; dfr[x] = totdfn;&#125;void dfs2(int x, int top) &#123; wtop[x] = top; if(wson[x]) dfs2(wson[x], top); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == wson[x] || y == dfa[x]) continue; dfs2(y, y); &#125;&#125;int ask_anc(int x, int anc) &#123; while(wtop[x] != wtop[anc]) &#123; if(dfa[wtop[x]] == anc) return wtop[x]; x = dfa[wtop[x]]; &#125; return wson[anc];&#125;struct Bint&#123;#define lowbit(x) ((x) &amp; -(x)) int c[maxn]; int s[maxm], stop; // 可能有很多次单点增加 inline void add(int pos, int nval) &#123; s[++stop] = pos; while(pos &lt;= n) c[pos] += nval, pos += lowbit(pos); &#125; inline void add(int L, int R, int nval) &#123; add(L, nval), add(R + 1, -nval); &#125; inline int ask(int pos) &#123; int res = 0; while(pos) res += c[pos], pos -= lowbit(pos); return res; &#125; inline void reset() &#123; while(stop) &#123; int pos = s[stop--]; while(pos &lt;= n &amp;&amp; c[pos] != 0) c[pos] = 0, pos += lowbit(pos); &#125; &#125; &#125;bint;int ht[maxn], toth;inline int eco(int x) &#123; return lower_bound(ht+1, ht+toth+1, x) - ht;&#125;int px[maxm], py1[maxm], py2[maxm], pval[maxm], pf[maxm], totins;int qx[maxn], qy[maxn], qaim[maxn], ans[maxn];inline void insert(int x1, int x2, int y1, int y2, int nval) &#123; if(x1 &gt; x2 || y1 &gt; y2) return; if(x1 &gt; y1) swap(x1, y1), swap(x2, y2); // cerr &lt;&lt; x1 &lt;&lt; \" \" &lt;&lt; x2 &lt;&lt; \" \" &lt;&lt; y1 &lt;&lt; \" \" &lt;&lt; y2 &lt;&lt; \" \" &lt;&lt; nval &lt;&lt; endl; px[++totins] = x1, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = 1; if(x2 != n) px[++totins] = x2 + 1, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = -1;&#125;inline bool cmp(int i, int j) &#123;#define cmpval(x) ((x) &gt; totins ? qx[(x) - totins] : px[(x)]) return cmpval(i) &lt; cmpval(j);&#125;int temp[maxm];// 1为修改，2为询问int q[maxm], qc[maxm];int lq[maxm], lqc[maxm], rq[maxm], rqc[maxm];void solve(int l, int r, int L, int R) &#123; bool suc = 1; for(int i=L; i&lt;=R; i++) if(qc[i] == 1) &#123; suc = 0; break;&#125; if(suc || l == r) &#123; for(int i=L; i&lt;=R; i++) if(qc[i] == 2) ans[q[i]] = l; return ; &#125; int mid = (l + r) &gt;&gt; 1, lt = 0, rt = 0; bool lc = 0, rc = 0; bint.reset(); for(int i=L; i&lt;=R; i++) &#123; int k = q[i]; if(qc[i] == 1) &#123; if(pval[k] &lt;= mid) bint.add(py1[k], py2[k], pf[k]), lq[++lt] = k, lqc[lt] = 1; else rq[++rt] = k, rqc[rt] = 1; &#125; else &#123; int lcnt = bint.ask(qy[k]); if(qaim[k] &gt; lcnt) qaim[k] -= lcnt, rq[++rt] = k, rqc[rt] = 2, rc = 1; else lq[++lt] = k, lqc[lt] = 2, lc = 1; &#125; &#125; if(lc) for(int i=1; i&lt;=lt; i++) q[i + L - 1] = lq[i], qc[i + L - 1] = lqc[i]; if(rc) for(int i=1; i&lt;=rt; i++) q[L + lt + i - 1] = rq[i], qc[L + lt + i - 1] = rqc[i]; if(lc) solve(l, mid, L, L + lt - 1); if(rc) solve(mid + 1, r, L + lt, R);&#125;int main() &#123; readint(n), readint(m), readint(totq); int nu, nv; for(int i=1; i&lt;n; i++) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs1(root, 1, 0), dfs2(root, root); int x, y, nval; for(int i=1; i&lt;=m; i++) &#123; readint(x), readint(y), readint(nval), ht[i] = nval; if(deep[x] &lt; deep[y]) swap(x, y); if(dfn[y] &lt;= dfn[x] &amp;&amp; dfn[x] &lt;= dfr[y]) &#123; // 链 y = ask_anc(x, y); insert(dfn[x], dfr[x], 1, dfn[y] - 1, nval); insert(dfn[x], dfr[x], dfr[y] + 1, n, nval); &#125; else insert(dfn[x], dfr[x], dfn[y], dfr[y], nval); &#125; // ([dfn[x], dfr[x]], [dfn[y], dfr[y]]) // ([dfn[x], dfr[x]], [1, dfn[y] - 1]) ([dfn[x], dfr[x]], [dfn[y] + 1, n]) sort(ht+1, ht+m+1), toth = unique(ht+1, ht+m+1) - (ht + 1); for(int i=1; i&lt;=totins; ) &#123; int j = i + 1, res = eco(pval[i]); while(j &lt;= totins &amp;&amp; pval[j] == pval[i]) j++; for(; i &lt; j; i++) pval[i] = res; &#125; for(int i=1; i&lt;=totq; i++) &#123; readint(qx[i]), readint(qy[i]), readint(qaim[i]); qx[i] = dfn[qx[i]], qy[i] = dfn[qy[i]]; if(qx[i] &gt; qy[i]) swap(qx[i], qy[i]); // cerr &lt;&lt; qx[i] &lt;&lt; \" \" &lt;&lt; qy[i] &lt;&lt; endl; &#125; for(int i=1; i&lt;=totins+totq; i++) temp[i] = i; stable_sort(temp+1, temp+totins+totq+1, cmp); for(int i=1; i&lt;=totins+totq; i++) &#123; if(temp[i] &gt; totins) q[i] = temp[i] - totins, qc[i] = 2; // else q[i] = temp[i], qc[i] = 1; &#125; solve(1, toth, 1, totins + totq); for(int i=1; i&lt;=totq; i++) printf(\"%d\\n\", ht[ans[i]]); return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"整体二分","slug":"整体二分","permalink":"http://arintaro.com/tags/整体二分/"},{"name":"扫描线","slug":"扫描线","permalink":"http://arintaro.com/tags/扫描线/"}]},{"title":"NOIP2010 观光公交","slug":"Answer/bus copy","date":"2019-12-31T15:59:40.569Z","updated":"2019-12-31T15:59:40.571Z","comments":true,"path":"2019/12/31/Answer/bus copy/","link":"","permalink":"http://arintaro.com/2019/12/31/Answer/bus copy/","excerpt":"你以为我是DP,其实我是贪心啦dio","text":"你以为我是DP,其实我是贪心啦dio Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1315要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。 } Solution:@card{ 对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。 接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(事实上远远跑不到); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。 我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(这两个名词都是我瞎编的) 算法1：贪心直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。 同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。 算法2：优化后的贪心发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(然而并没有), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。 算法3: 数据结构优化贪心考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int inf = 1e9;int n, m, k;int cnt[maxn], leave[maxn], arrive[maxn], w[maxn];lint sum[maxn];int main() &#123; readint(n), readint(m), readint(k); for(rint i=2; i&lt;=n; i++) readint(w[i]); for(rint i=1; i&lt;=m; i++) &#123; int t, st, ed; readint(t), readint(st), readint(ed); cnt[ed]++, sum[ed] += t; leave[st] = max(leave[st], t); &#125; for(rint i=2; i&lt;=n; i++) arrive[i] = max(arrive[i-1], leave[i-1]) + w[i]; while(k != 0) &#123; int res_st = 0, res_ed = 0, res_w = 0, res_cnt = 0; for(rint i=2; i&lt;=n; ) &#123; if(w[i] == 0) &#123; i++; continue; &#125; int now_w = min(w[i], k), now_cnt = 0; rint j = i; for(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123; now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]); &#125; now_cnt += cnt[j]; if(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt; i = j + 1; &#125; if(res_w == 0) break; w[res_st] -= res_w, k -= res_w; for(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w; &#125; lint ans = 0; for(rint i=1; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"迭代","slug":"迭代","permalink":"http://arintaro.com/tags/迭代/"}]},{"title":"APIO2015 八邻旁之桥","slug":"Answer/bridge2","date":"2019-12-29T12:03:36.663Z","updated":"2019-12-29T12:14:04.924Z","comments":true,"path":"2019/12/29/Answer/bridge2/","link":"","permalink":"http://arintaro.com/2019/12/29/Answer/bridge2/","excerpt":"又一道在APIO中的$k=2$的题目","text":"又一道在APIO中的$k=2$的题目 Description:@card{ 给定一些在坐标轴上的线段，再让你确定一个或两个点，每条线段可以选一个点，答案累加它两个端点到这个点的距离，要求答案最小。 } Solution:@card{ 先考虑确定一个点怎么做，发现一条线段左右端点的贡献是可以拆开的，这样就变成货仓选址了。 再考虑两个点怎么做，如果像一个点的做法，拆开两个点的贡献，这样两个端点容易选不到一个点，导致答案偏小，如果我们能划分成两个集合，一个集合内的线段只去一个点，即可按照$k=1$的做法做。 考虑其贡献函数，如果一个线段到的点在它内部，贡献为常数，即这个线段长，如果在外部，可以发现是是$|l + r - 2x|$，其中$x$是点的坐标，显然它是关于$\\frac{l + r}{2}$对称的，且两侧都是单调的，那么对它来说，肯定是选去一个离它对称轴近的点，那么即可把所有线段按$l + r$排序，枚举两个集合间的划分点，前后分别动态维护中位数。 动态中位数有很多做法，离线链表，对顶堆，$\\set$等做法，离线链表应该跑的是最快的，但是我最近平衡树写的比较多，写起来虽然长一点，但是可能也比其他做法写的要快。抱着这种想法，我选择了无旋$\\text{Treap}$，然后成功被卡常，换成$\\text{SBT}$后才水过去。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define isch(x) ((x) != '\\n' &amp;&amp; (x) != '\\r' &amp;&amp; (x) != ' ')#define sit set&lt;pii&gt;::iterator#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;inline void readstr(char s[]) &#123; int len = 0; char ch = getc(); while(!isch(ch)) ch = getc(); for(; isch(ch); ch = getc()) s[len++] = ch; s[len] = '\\0';&#125;using namespace std;const int maxn = 4e5 + 10;const int inf = 2e9;int n, k;int arr[maxn];struct Seg&#123; int l, r; inline bool operator &lt; (const Seg&amp; b) const &#123; return l + r &lt; b.l + b.r; &#125;&#125;seg[maxn];int tot = 0;lint ans = 0;struct SBT&#123; int ch[maxn][2], val[maxn], size[maxn]; lint sum[maxn]; int root, totnode; inline int newnode(int nval) &#123; size[++totnode] = 1, val[totnode] = nval, sum[totnode] = nval; return totnode; &#125; inline void pushup(int p) &#123; if(p == 0) return; sum[p] = sum[ch[p][0]] + sum[ch[p][1]] + val[p]; size[p] = size[ch[p][0]] + size[ch[p][1]] + 1; &#125; inline void rotate(int&amp; x, bool c) &#123; int y = ch[x][c]; ch[x][c] = ch[y][c ^ 1], ch[y][c ^ 1] = x; sum[y] = sum[x], size[y] = size[x], pushup(x); x = y; &#125; void maintain(int&amp; x, bool c) &#123; if(size[ch[ch[x][c]][c]] &gt; size[ch[x][c ^ 1]]) rotate(x, c); else if(size[ch[ch[x][c]][c ^ 1]] &gt; size[ch[x][c ^ 1]]) rotate(ch[x][c], c ^ 1), rotate(x, c); else return; maintain(ch[x][0], 0), maintain(ch[x][1], 1); maintain(x, 0), maintain(x, 1); &#125; void insert(int&amp; p, int nval) &#123; if(p == 0) &#123; p = newnode(nval); return; &#125; insert(ch[p][nval &gt;= val[p]], nval), pushup(p); maintain(p, nval &gt;= val[p]); &#125; inline void insert(int nval) &#123; insert(root, nval); &#125; int res; inline int merase(int&amp; p) &#123; if(ch[p][0] == 0) &#123; res = val[p], p = ch[p][1]; return res; &#125; int res = merase(ch[p][0]); pushup(p); return res; &#125; inline void erase(int&amp; p, int nval) &#123; if(p == 0) return; if(val[p] == nval) &#123; if(ch[p][0] == 0 || ch[p][1] == 0) p = ch[p][0] + ch[p][1]; else val[p] = merase(ch[p][1]); &#125; else erase(ch[p][nval &gt;= val[p]], nval); pushup(p); &#125; inline void erase(int nval) &#123; erase(root, nval); &#125; void ask_rank(int p, int k, int&amp; pos, lint&amp; now) &#123; if(size[ch[p][0]] == k) &#123; pos = p, now += sum[ch[p][0]]; return; &#125; if(k &gt; size[ch[p][0]]) now += sum[ch[p][0]] + val[p], ask_rank(ch[p][1], k - size[ch[p][0]] - 1, pos, now); else ask_rank(ch[p][0], k, pos, now); &#125; inline lint ask() &#123; int p, lsize = (size[root] + 1) / 2 - 1, rsize = size[root] - lsize - 1; lint lsum = 0, rsum = 0; ask_rank(root, lsize, p, lsum), rsum = sum[root] - lsum - val[p]; return (lint)lsize * val[p] - lsum + rsum - (lint)rsize * val[p]; &#125;&#125;lt, rt;int main() &#123; readint(k), readint(n); char a[5], b[5]; int x, y; for(int i=1; i&lt;=n; i++) &#123; readstr(a), readint(x), readstr(b), readint(y); if(a[0] == b[0]) ans += abs(y - x); else seg[++tot].l = min(x, y), seg[tot].r = max(x, y), ans++; &#125; n = tot, tot = 0; if(n == 0) printf(\"%lld\\n\", ans); else if(k == 1) &#123; for(int i=1; i&lt;=n; i++) arr[++tot] = seg[i].l, arr[++tot] = seg[i].r; int pos = (tot + 1) / 2; nth_element(arr+1, arr+pos, arr+tot+1); for(int i=1; i&lt;=tot; i++) ans += abs(arr[i] - arr[pos]); printf(\"%lld\\n\", ans); &#125; else &#123; lint res = 1e18; sort(seg+1, seg+n+1); for(int i=1; i&lt;=n; i++) rt.insert(seg[i].l), rt.insert(seg[i].r); for(int i=1; i&lt;=n-1; i++) &#123; rt.erase(seg[i].l), rt.erase(seg[i].r); lt.insert(seg[i].l), lt.insert(seg[i].r); res = min(res, lt.ask() + rt.ask()); &#125; printf(\"%lld\\n\", res + ans); &#125; return 0;&#125; }","categories":[{"name":"APIO","slug":"APIO","permalink":"http://arintaro.com/categories/APIO/"},{"name":"题解","slug":"APIO/题解","permalink":"http://arintaro.com/categories/APIO/题解/"}],"tags":[{"name":"货仓选址","slug":"货仓选址","permalink":"http://arintaro.com/tags/货仓选址/"},{"name":"单调性","slug":"单调性","permalink":"http://arintaro.com/tags/单调性/"},{"name":"动态中位数","slug":"动态中位数","permalink":"http://arintaro.com/tags/动态中位数/"}]},{"title":"ZJOI2006 书架","slug":"Answer/book","date":"2019-12-28T06:47:05.784Z","updated":"2019-12-28T06:57:25.636Z","comments":true,"path":"2019/12/28/Answer/book/","link":"","permalink":"http://arintaro.com/2019/12/28/Answer/book/","excerpt":"","text":"Description:@card{ 懒得写了，写个平衡树，要求支持以下操作https://www.luogu.com.cn/problem/P2596 } Solution:@card{ 本题涉及到”移动幅度不大的”区间操作，即$\\text{insert}$中只有$-1, 1$，因此可以直接用树状数组水过，倍增即可单$\\log$查排名。 平衡树怎么写呢，要用$\\text{Splay}$ 或者是无旋$\\text{Treap}$，常数都比较大。 前者无法高效单次操作分裂出序列中前$k$个数字，必须先查一次第$k$个数的节点编号，然后把它旋转上来。而后者无法高效的已知某个节点编号，分裂出在它前面的节点。当然，如果各多实现几个函数，也是可以做到的，比如在一棵$\\text{Splay}$上跑无旋$\\text{Treap}$的$\\text{Split}$，但是写起来比较麻烦。 我写了后者，维护父指针，即可实现一个辅助函数，给节点指针查排名，再用$\\text{Split}$分裂出节点。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define isch(x) ((x) != '\\n' &amp;&amp; (x) != '\\r' &amp;&amp; (x) != ' ')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;inline void readstr(char s[]) &#123; int len = 0; char ch = getc(); while(!isch(ch)) ch = getc(); for(; isch(ch); ch = getc()) s[len++] = ch; s[len] = '\\0';&#125;using namespace std;const int maxn = 1e5 + 10;const int maxnode = 1e5 + 10;int n, m;int arr[maxn];struct Treap&#123; int lson[maxnode], rson[maxnode], dfa[maxnode]; int rnd[maxnode], id[maxnode], size[maxnode]; int pos[maxnode]; int root, totnode; Treap() &#123; rnd[0] = rand(); &#125; inline void pushup(int p) &#123; if(p == 0) return; size[p] = size[lson[p]] + size[rson[p]] + 1; &#125; void merge(int&amp; p, int a, int b, int fa) &#123; if(a == 0 || b == 0) p = a + b; else if(rnd[a] &gt; rnd[b]) p = a, merge(rson[p], rson[a], b, p); else p = b, merge(lson[p], a, lson[b], p); dfa[p] = fa, pushup(p); &#125; inline void merge(int&amp; p, int a, int b) &#123; merge(p, a, b, 0); &#125; void split_rank(int p, int&amp; a, int fa, int&amp; b, int fb, int k) &#123; if(p == 0) a = b = 0; else if(k &gt; size[lson[p]]) a = p, dfa[p] = fa, split_rank(rson[p], rson[a], p, b, fb, k - size[lson[p]] - 1); else b = p, dfa[p] = fb, split_rank(lson[p], a, fa, lson[b], p, k); pushup(p); &#125; inline void split_rank(int p, int&amp; a, int&amp; b, int k) &#123; split_rank(p, a, 0, b, 0, k); &#125; void build(int&amp; p, int l, int r, int fa) &#123; if(l &gt; r) return; int mid = (l + r) &gt;&gt; 1; p = ++totnode; id[p] = arr[mid], size[p] = 1, pos[arr[mid]] = p, dfa[p] = fa; rnd[p] = rnd[fa] - (rand() &amp; ((1 &lt;&lt; 12) - 1)); build(lson[p], l, mid-1, p), build(rson[p], mid+1, r, p); pushup(p); &#125; void print(int p, int fa) &#123; if(p == 0) return; print(lson[p], p); printf(\"%d \", id[p]); print(rson[p], p); &#125; inline void print() &#123; print(root, 0), putchar('\\n'); &#125; int getrank(int p) &#123; int res = size[lson[p]]; while(dfa[p] != 0) &#123; if(rson[dfa[p]] == p) res += size[lson[dfa[p]]] + 1; // 注意这里要+1 p = dfa[p]; &#125; return res; &#125; inline void move_top(int nid) &#123; int k = getrank(pos[nid]), lt, mid, rt; split_rank(root, lt, 0, rt, 0, k), split_rank(rt, mid, 0, rt, 0, 1); merge(lt, mid, lt, 0), merge(root, lt, rt, 0); &#125; inline void move_bot(int nid) &#123; int k = getrank(pos[nid]), lt, mid, rt; split_rank(root, lt, 0, rt, 0, k), split_rank(rt, mid, 0, rt, 0, 1); merge(root, lt, rt, 0), merge(root, root, mid, 0); &#125; inline void insert(int nid, int det) &#123; if(det == 0) return; int k = getrank(pos[nid]), lt, mid, t, rt; split_rank(root, lt, 0, rt, 0, k), split_rank(rt, mid, 0, rt, 0, 1); if(det &gt; 0) &#123; split_rank(rt, t, 0, rt, 0, det); merge(lt, lt, t, 0), merge(rt, mid, rt, 0); merge(root, lt, rt, 0); &#125; else &#123; split_rank(lt, lt, 0, t, 0, size[lt] + det); merge(lt, lt, mid, 0), merge(rt, t, rt, 0); merge(root, lt, rt, 0); &#125; &#125; inline int ask(int nid) &#123; return getrank(pos[nid]); &#125; inline int getid(int k) &#123; int lt, mid, rt; split_rank(root, lt, rt, k-1), split_rank(rt, mid, rt, 1); int res = id[mid]; merge(lt, lt, mid), merge(root, lt, rt); return res; &#125;&#125;bst;int main() &#123; srand(42); readint(n), readint(m); for(int i=1; i&lt;=n; i++) readint(arr[i]); bst.build(bst.root, 1, n, 0); // return 0; char ins[10]; int x, d; while(m--) &#123; readstr(ins), readint(x); // cerr &lt;&lt; ins &lt;&lt; \" \" &lt;&lt; x &lt;&lt; endl; if(ins[0] == 'T') bst.move_top(x); if(ins[0] == 'B') bst.move_bot(x); if(ins[0] == 'I') readint(d), bst.insert(x, d); if(ins[0] == 'A') printf(\"%d\\n\", bst.ask(x)); if(ins[0] == 'Q') printf(\"%d\\n\", bst.getid(x)); // bst.print(); &#125; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://arintaro.com/tags/平衡树/"},{"name":"树状数组","slug":"树状数组","permalink":"http://arintaro.com/tags/树状数组/"}]},{"title":"SDOI2016 游戏","slug":"Answer/game","date":"2019-12-28T04:20:40.997Z","updated":"2019-12-28T04:34:02.331Z","comments":true,"path":"2019/12/28/Answer/game/","link":"","permalink":"http://arintaro.com/2019/12/28/Answer/game/","excerpt":"","text":"Description:@card{ 给定一棵带点权和边权的树，两种操作，边权给定，点权初始为$\\text{inf}$ 给定树上一条路径，路径上每个点的点权与$a \\times dis + b$，取$\\text{min}$，其中$\\text{dis}$为该点与起点的距离 给定一条路径，查询其中的最小点权。 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 10^5$，值域为$\\text{long long}$ } Solution:@card{ 这种与等差数列取$\\text{min}$或$\\text{max}$的操作显然可以用李超线段树维护，放在树上就套个树链剖分而已，推下式子显然可以转换成只与到根节点的距离有关，剩下到起点的距离放在常数项上即可，这样一条重链上的横坐标仍然是递增的，可以直接维护。 之前写的模版题只有单点查询，这题要求支持区间查询，所以我们需要格外维护一个标记，表示这个区间以及所有子区间中在区间中能取到的最小值，显然有递推式 $$minval_p = \\min(f_p(l), f_p(r), minval_{lson}, minval_{rson})$$ 查询时如果查询区间完全覆盖了当前区间，直接返回标记即可，未完全覆盖就再让子节点返回的答案与当前节点上的函数在定义域上两个端点的值取较小的返回即可。 另外本题$10^5$跑三个$\\log$，有些不稳，但是李超线段树常数非常小，两个$\\log$实际上是没法跑满的。 由于本题只维护链上信息，我们可以对每条重链单独开一棵线段树，减少无用信息的合并和递归次数，只开一棵线段树，合并两条重链的信息显然是毫无意义的。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;iostream&gt;#include &lt;cstdio&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int maxm = 2 * maxn;const int maxnode = 3 * maxn;const lint inf = 1e18 + 10;int n, m;int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;int totdfn = 0;int dfa[maxn], size[maxn], deep[maxn], root = 1;lint dist[maxn];int dfn[maxn], wson[maxn], wtop[maxn];int sid[maxn];lint dis[maxnode];struct func&#123; lint k, b; func() &#123; k = 0, b = inf; &#125; func(lint kk, lint bb): k(kk), b(bb) &#123;&#125; inline lint operator () (int x) const &#123; return k * dis[x] + b; &#125;&#125;;struct SMT&#123; static int lson[maxnode], rson[maxnode], totnode; static func f[maxnode]; static lint minval[maxnode]; int root, sl, sr; void insert(int&amp; p, int l, int r, int L, int R, const func&amp; g) &#123; if(p == 0) p = ++totnode, minval[p] = inf; int mid = (l + r) &gt;&gt; 1; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; bool lt = g(l) &lt; f[p](l), mt = g(mid) &lt; f[p](mid), rt = g(r) &lt; f[p](r); if(lt &amp;&amp; rt) f[p] = g; else if(!lt &amp;&amp; !rt) return; else if(mt) &#123; // 下放f if(lt) insert(rson[p], mid+1, r, L, R, f[p]); else insert(lson[p], l, mid, L, R, f[p]); f[p] = g; &#125; else &#123; if(lt) insert(lson[p], l, mid, L, R, g); else insert(rson[p], mid+1, r, L, R, g); &#125; &#125; else &#123; if(L &lt;= mid) insert(lson[p], l, mid, L, R, g); if(R &gt; mid) insert(rson[p], mid+1, r, L, R, g); &#125; minval[p] = min(min(f[p](l), f[p](r)), min(minval[lson[p]], minval[rson[p]])); &#125; inline void insert(int L, int R, const func&amp; g) &#123; if(L &gt; R) swap(L, R); insert(root, sl, sr, L, R, g); &#125; lint ask(int&amp; p, int l, int r, int L, int R) &#123; if(p == 0) return inf; if(L &lt;= l &amp;&amp; r &lt;= R) return minval[p]; int mid = (l + r) &gt;&gt; 1; lint res = inf; if(L &lt;= mid) res = min(res, ask(lson[p], l, mid, L, R)); if(R &gt; mid) res = min(res, ask(rson[p], mid+1, r, L, R)); return min(res, min(f[p](max(L, l)), f[p](min(R, r)))); &#125; inline lint ask(int L, int R) &#123; if(L &gt; R) swap(L, R); return ask(root, sl, sr, L, R); &#125;&#125;smt[maxn];int SMT::lson[maxnode], SMT::rson[maxnode], SMT::totnode;func SMT::f[maxnode];lint SMT::minval[maxnode];int totsmt = 0;void dfs1(int x) &#123; size[x] = 1; for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == dfa[x]) continue; deep[y] = deep[x] + 1, dist[y] = dist[x] + ew[i], dfa[y] = x; dfs1(y); size[x] += size[y]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125;&#125;void dfs2(int x, int top, int nid) &#123; dfn[x] = ++totdfn, wtop[x] = top; dis[totdfn] = dist[x], sid[x] = nid; if(smt[nid].sl == 0) smt[nid].sl = totdfn; smt[nid].sr = totdfn; if(wson[x]) dfs2(wson[x], top, nid); for(int i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == dfa[x] || y == wson[x]) continue; dfs2(y, y, ++totsmt); &#125;&#125;inline int lca(int x, int y) &#123; while(wtop[x] != wtop[y]) &#123; if(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y); x = dfa[wtop[x]]; &#125; return deep[x] &lt; deep[y] ? x : y;&#125;inline void insert_lian(int x, int anc, lint k, lint b) &#123; func g = func(k, b); while(deep[wtop[x]] &gt;= deep[anc]) &#123; smt[sid[x]].insert(dfn[x], dfn[wtop[x]], g); x = dfa[wtop[x]]; &#125; if(deep[x] &gt;= deep[anc]) smt[sid[x]].insert(dfn[x], dfn[anc], g);&#125;inline void insert(int st, int ed, lint k, lint b) &#123; int nlca = lca(st, ed); insert_lian(st, nlca, -k, k * dist[st] + b); insert_lian(ed, nlca, k, b + k * dist[st] - 2 * k * dist[nlca]);&#125;inline lint ask(int x, int y) &#123; lint res = inf; while(wtop[x] != wtop[y]) &#123; if(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y); res = min(res, smt[sid[x]].ask(dfn[x], dfn[wtop[x]])); x = dfa[wtop[x]]; &#125; return min(res, smt[sid[x]].ask(dfn[x], dfn[y]));&#125;int main() &#123; SMT::minval[0] = inf; readint(n), readint(m); int nu, nv, nw; for(int i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; deep[root] = 1; dfs1(root), dfs2(root, root, ++totsmt); int ins, st, ed, a, b; while(m--) &#123; readint(ins), readint(st), readint(ed); // cerr &lt;&lt; ins &lt;&lt; \" \" &lt;&lt; st &lt;&lt; \" \" &lt;&lt; ed &lt;&lt; endl; if(ins == 1) readint(a), readint(b), insert(st, ed, a, b); else &#123; lint res = ask(st, ed); if(res == inf) puts(\"123456789123456789\"); else printf(\"%lld\\n\", res); &#125; &#125; return 0;&#125; }","categories":[{"name":"各省省选","slug":"各省省选","permalink":"http://arintaro.com/categories/各省省选/"},{"name":"题解","slug":"各省省选/题解","permalink":"http://arintaro.com/categories/各省省选/题解/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://arintaro.com/tags/树链剖分/"},{"name":"李超线段树","slug":"李超线段树","permalink":"http://arintaro.com/tags/李超线段树/"},{"name":"标记永久化","slug":"标记永久化","permalink":"http://arintaro.com/tags/标记永久化/"}]},{"title":"ARC089E GraphXY","slug":"Answer/xy","date":"2019-12-25T06:44:23.273Z","updated":"2019-12-25T06:59:08.341Z","comments":true,"path":"2019/12/25/Answer/xy/","link":"","permalink":"http://arintaro.com/2019/12/25/Answer/xy/","excerpt":"","text":"Description:@card{ 构造一张有向图,并给出 $st, ed$ 每条边的权值是一个确定的整数,或者 $X$,或者 $Y$ $d, x, y$ 表示当 $X = x, Y = y$ 时 $st$ 到 $ed$ 的最短路长度 给出 $d$ 数组,构造出这个有向图 $n \\leq 300$ , $x, y \\leq 10$ } Solution:@card{ 考虑先求出把$X, Y$的影响排除在外的最短路，以此方便构造，发现至多会走$100$个$X$或$Y$，所以我们可以在状态上记录当前走了几个$X$，$Y$，定义$f_{i, j}$为走了$i$个$X$和$j$个$Y$的最短路。 像这种已知答案构建问题的构造，可以考虑已知问题如何求出答案，即有$dist_{x, y} = \\min(i \\times x + j \\times y + f_{i, j})$，考虑移项，$$dist_{x, y} \\leq i \\times x + j \\times y + f_{i, j}$$$$dist_{x, y} - i \\times x - j \\times y \\leq + f_{i, j}$$$$f_{i, j} = \\max(dist_{x, y} - i \\times x - j \\times y)$$ 这里的不等号只作「符号」上的转换，以便我们确定移项后是$\\min$还是$\\max$，由于等号在原式一定取到，所以并不是真正的放缩，以此可以求出$f$数组，显然可以构造只有$X$和只有$Y$的两条链，使走一定数量的$X,Y$的路径唯一，在连接点处放计算出的$f$即可。 注意这样不一定成立，解可能不存在，因为由$d$求出$f$的时候，我们这样的推导并不能保证由$f$还能计算出一样的$d$，即我们计算出的$f$是$d$的一个必要条件。所以我们还要判断由$f$是否还能计算出一样的$d$，按照公式计算即可，我代码里写了最短路，实际上不必要。 至于为什么这样构造出的$f$不满足就一定不存在满足题意的图，我感性理解一下就是对于一个$d$来说，它的$f$按照上述计算方法是唯一的，唯一的$f$构造出来的图都不满足，那么一定也不存在其他满足题意的图。实际上不太严谨，我也没看到其他题解有详细论证的，希望有人会可以告诉我。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxa = 12;const int maxn = 204;// dist[x][y] = min&#123;i * x + j * y + f[i][j]&#125;// dist[x][y] - i * x - j * y &lt;= f[i][j]// f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125;// f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125;int n = 202, m = 100;int A, B;int dist[maxa][maxa], f[maxn][maxn];int edge[maxn][maxn];int now[maxn];bool vis[maxn];int main() &#123; memset(f, -1, sizeof(f)), memset(edge, -1, sizeof(edge)); readint(A), readint(B); for(int i=1; i&lt;=A; i++) &#123; for(int j=1; j&lt;=B; j++) readint(dist[i][j]); &#125; int cnt = 0; for(int i=0; i&lt;=m; i++) &#123; for(int j=0; j&lt;=m; j++) &#123; for(int x=1; x&lt;=A; x++) &#123; for(int y=1; y&lt;=B; y++) &#123; f[i][j] = max(f[i][j], dist[x][y] - i * x - j * y); &#125; &#125; // i个x, j个y的最短路 edge[i + 1][202 - j] = f[i][j]; if(edge[i + 1][202 - j] != -1) cnt++; &#125; &#125; // dist[x][y] = min&#123;i * x + j * y + f[i][j]&#125; // dist[x][y] - i * x - j * y &lt;= f[i][j] // f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125; // f[i][j] &gt;= dist[x][y] - i * x - j * y for(int a=1; a&lt;=A; a++) &#123; for(int b=1; b&lt;=B; b++) &#123; for(int i=1; i&lt;=100; i++) edge[i][i+1] = a; for(int i=102; i&lt;=201; i++) edge[i][i+1] = b; memset(vis, 0, sizeof(vis)), memset(now, 0x3f, sizeof(now)); now[1] = 0; while(true) &#123; int x = 0; for(int i=1; i&lt;=n; i++) if(!vis[i] &amp;&amp; now[i] &lt; now[x]) x = i; if(x == 0) break; vis[x] = 1; for(int y=1; y&lt;=n; y++) if(edge[x][y] != -1 &amp;&amp; now[y] &gt; now[x] + edge[x][y]) now[y] = now[x] + edge[x][y]; &#125; if(now[n] != dist[a][b]) &#123; puts(\"Impossible\"); return 0; &#125; &#125; &#125; puts(\"Possible\"); printf(\"%d %d\\n\", n, cnt + 200); for(int i=1; i&lt;=100; i++) printf(\"%d %d X\\n\", i, i+1); for(int i=102; i&lt;=201; i++) printf(\"%d %d Y\\n\", i, i+1); for(int i=0; i&lt;=m; i++) &#123; for(int j=0; j&lt;=m; j++) &#123; if(f[i][j] == -1) continue; printf(\"%d %d %d\\n\", i + 1, 202 - j, f[i][j]); &#125; &#125; printf(\"%d %d\\n\", 1, 202); return 0;&#125; }","categories":[{"name":"atcoder","slug":"atcoder","permalink":"http://arintaro.com/categories/atcoder/"},{"name":"题解","slug":"atcoder/题解","permalink":"http://arintaro.com/categories/atcoder/题解/"}],"tags":[{"name":"构造","slug":"构造","permalink":"http://arintaro.com/tags/构造/"},{"name":"思维","slug":"思维","permalink":"http://arintaro.com/tags/思维/"}]},{"title":"CF566E Restoring Map","slug":"Answer/map","date":"2019-12-25T03:34:37.002Z","updated":"2019-12-25T04:58:43.837Z","comments":true,"path":"2019/12/25/Answer/map/","link":"","permalink":"http://arintaro.com/2019/12/25/Answer/map/","excerpt":"神奇的题目","text":"神奇的题目 Description:@card{ 给出一棵树，定义一个点的邻居集合为距离不超过$2$的点的集合 乱序给出每个点的邻居集合，构造出原树，即不知道$n$个集合中每个集合对应哪个点 $n \\leq 1000$，保证有解，多解任意输出 } Solution:@card{ 由于不知道哪个集合对应哪个点，信息难以利用。 考虑取交集，发现当有一条$4$个点构成的链时，对两头的点集取交集，集合中的点一定为中间的两个点，直接连边即可。 这样即可求出树中所有非叶节点之间的连边，并确定至少两个非叶节点，之后考虑非叶节点连在哪里即可。 同时需要注意这里推导的前提条件，可能图中只有一个非叶节点即不存在一条由$4$个点构成的链，容易发现即为菊花图，需要特判。 考虑菊花图的情况，容易发现所有点集都是一样的，即所有点都是等价的，随便选一个作根即可。 接着考虑，我们仍不知道集合与点的对应关系，需要继续利用集合信息，考虑叶子节点的特殊性质，叶子节点跳到它的父亲，离它距离小于等于$2$的点肯定不会减少，又因为它的父亲是非叶节点，可知点的数量会增多，如果再从它的父亲跳到其他非叶节点，结合性质发现至少比在它的父亲时不会减少，综合以上讨论，可以发现一个叶子节点对应的点集是包含它的集合元素最少的那个。如果有多个，可以发现其都是等价的，是挂在同一个节点上的叶子节点，不会影响答案。 接着考虑，对于一个叶子节点，跳到它的父亲相当于花费了$1$的距离，那么离父亲距离为$1$的节点也肯定都在离叶子节点距离为$2$的点集中，注意我们这里处理离父亲节点距离为$1$的节点是依靠上面所有非叶节点之间的连边，所以集合中要无视掉其余叶子节点，于是我们得到了一个必要条件。 无视掉其他叶子节点后，如果存在一个非叶节点距离父亲为$1$，且不连接任何其余任何非叶节点，那么只依靠上述条件这个点与父亲节点都会判定成立。结合样例发现，这种情况只存在于有且仅有两个非叶节点的时候，且这两个点是等价的，其余叶子节点的点集只有两种，我们把点集一样的叶子节点分在同一边即可。 讨论完上述情况后，可以发现满足条件的点是唯一的，变成充要条件，我们可以直接利用这个条件判断谁是父亲，解决问题。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 代码比较丑#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;vector&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1002;int n;bitset&lt;maxn&gt; s[maxn], edge[maxn];int bsize[maxn];bool nleaf[maxn], vis[maxn];int sid[maxn];int main() &#123; readint(n); for(int i=1; i&lt;=n; i++) &#123; int x = 0, t = 0; readint(t); while(t--) readint(x), s[i][x] = 1; &#125; int cnt = 0, r1 = 0, r2 = 0; bitset&lt;maxn&gt; now; for(int i=1; i&lt;=n; i++) bsize[i] = s[i].count(); bsize[0] = maxn; for(int i=1; i&lt;=n; i++) &#123; for(int j=i+1; j&lt;=n; j++) &#123; now = s[i] &amp; s[j]; if(now.count() != 2) continue; int x = now._Find_first(), y = now._Find_next(x); // 这里也可以暴力查找，这个过程只会执行O(n)次 edge[x][y] = edge[y][x] = 1, nleaf[x] = nleaf[y] = 1; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123; edge[i][i] = 1; for(int j=i+1; j&lt;=n; j++) if(edge[i][j]) printf(\"%d %d\\n\", i, j), cnt++; &#125; if(cnt == 0) &#123; for(int i=2; i&lt;=n; i++) printf(\"1 %d\\n\", i); return 0; &#125; if(cnt == 1) &#123; for(int i=1; i&lt;=n; i++) if(nleaf[i]) r1 ? r2 = i : r1 = i; &#125; int flag = 0; for(int x=1; x&lt;=n; x++) &#123; if(nleaf[x]) continue; int pos = 0; for(int j=1; j&lt;=n; j++) if(s[j][x] &amp;&amp; bsize[j] &lt; bsize[pos]) pos = j; if(cnt == 1) &#123; if(flag &amp;&amp; s[pos] == now) continue; for(int j=1; j&lt;=n; j++) &#123; if(!s[pos][j] || j == r1 || j == r2) continue; if(!flag) printf(\"%d %d\\n\", r1, j); else printf(\"%d %d\\n\", r2, j); &#125; flag++, now = s[pos]; &#125; else &#123; for(int j=1; j&lt;=n; j++) if(!nleaf[j] &amp;&amp; s[pos][j]) s[pos][j] = 0; for(int y=1; y&lt;=n; y++) &#123; if(!nleaf[y]) continue; if(s[pos] == edge[y]) printf(\"%d %d\\n\", x, y); &#125; &#125; if(flag == 2) break; &#125; return 0;&#125; }","categories":[{"name":"codeforces","slug":"codeforces","permalink":"http://arintaro.com/categories/codeforces/"},{"name":"题解","slug":"codeforces/题解","permalink":"http://arintaro.com/categories/codeforces/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"构造","slug":"构造","permalink":"http://arintaro.com/tags/构造/"},{"name":"具体方案","slug":"具体方案","permalink":"http://arintaro.com/tags/具体方案/"}]},{"title":"OI知识点","slug":"Detail/OI知识点","date":"2019-12-24T13:33:28.385Z","updated":"2019-12-24T13:39:07.864Z","comments":true,"path":"2019/12/24/Detail/OI知识点/","link":"","permalink":"http://arintaro.com/2019/12/24/Detail/OI知识点/","excerpt":"好多呀..","text":"好多呀.. @card{ 引用自：https://www.luogu.com.cn/blog/SSerxhs/oi-zhi-shi-dian-zong-jie } 一、基本算法二、库函数及语言三、数学四、数据结构五、动态规划六、图论七、字符串八、计算几何","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"CF993E Nikita and Order Statistics","slug":"Answer/nikita","date":"2019-12-10T00:28:55.830Z","updated":"2019-12-10T00:40:23.650Z","comments":true,"path":"2019/12/10/Answer/nikita/","link":"","permalink":"http://arintaro.com/2019/12/10/Answer/nikita/","excerpt":"","text":"Description:@card{ 给你一个数组 $a_{1 \\sim n}$，对于 $k = 0 \\sim n$，求出有多少个数组上的区间满足：区间内恰好有 $k$ 个数比 $x$ 小。$x$ 为一个给定的数。 $n \\le 2 \\times 10^5$。值域没有意义。 } Solution:@card{ 一个套壳的卷积题，需要先进行问题转化，由于$x$给定，问题转化为一个$01$数组上有多少个区间和为$k$，容易想到求前缀和，问题变为有多少对数差为$k$，由于此数组单调递增，对值域考虑发现前缀和较大的位置一定在后面，于是可以统计每个值的出现次数$cnt$，对一个$k$考虑每个$i$，即可得到答案为$ans_k = \\sum{cnt_i \\times cnt_{i-k}, k \\leq i \\leq n}$。 由于需要对每个$k$进行上述计算，朴素会$\\text{TLE}$，容易发现是卷积形式，不妨定义负下标和超过$n$的下标上的值均为$0$，即可去掉和式后的限制条件，由于卷积形式需要两指标变量和为一个定值，于是需要把一个$i$的符号变为负数，一般我们反转数组来进行这个变换，于是反转数组再$\\text{fft}$即可。 注意一个边界情况，对$0$计算时会产生$cnt_i \\times cnt_i$，这样无法保证前后顺序，正确的计算式应该是$cnt_i \\times (cnt_i - 1) / 2$，需要特判。 另外，本题答案值域可能至$n^2$，刚好超过$\\text{int}$，如果选用$\\text{ntt}$，需要选两模数多次进行，或者选一个$\\text{long long}$范围内的模数，并且需要写快速乘，效率不如用$\\text{fft}$ } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;char buf[1&lt;&lt;21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = (1 &lt;&lt; 19) + 10;const double pi = acos(-1);struct cp&#123; double x, y; cp() &#123;&#125; cp(double xx, double yy): x(xx), y(yy) &#123;&#125; inline cp operator + (const cp&amp; b) const &#123; return cp(x + b.x, y + b.y); &#125; inline cp operator - (const cp&amp; b) const &#123; return cp(x - b.x, y - b.y); &#125; inline cp operator * (const cp&amp; b) const &#123; return cp(x * b.x - y * b.y, x * b.y + y * b.x); &#125;&#125;;int n, x, t = 1, tc = 0;int arr[maxn], cnt[maxn], br[maxn];cp a[maxn], b[maxn];lint ans_zero = 0;void fft(cp arr[], int f, int n) &#123; for(int i=0; i&lt;n; i++) if(i &lt; br[i]) swap(arr[i], arr[br[i]]); for(int len=2; len&lt;=n; len&lt;&lt;=1) &#123; int mid = len &gt;&gt; 1; cp w = cp(cos(pi / mid), f * sin(pi / mid)); for(cp *now=arr; now!=arr+n; now+=len) &#123; cp k = cp(1, 0); for(int i=0; i&lt;mid; i++) &#123; cp x = k * now[i + mid]; now[i + mid] = now[i] - x; now[i] = now[i] + x; k = k * w; &#125; &#125; &#125;&#125;int main() &#123; readint(n), readint(x); for(int i=1; i&lt;=n; i++) &#123; readint(arr[i]); arr[i] = (arr[i] &lt; x) + arr[i-1]; &#125; for(int i=0; i&lt;=n; i++) cnt[arr[i]]++; for(int i=0; i&lt;=n; i++) ans_zero += (lint)cnt[i] * (cnt[i] - 1) / 2; for(int i=0; i&lt;=n; i++) a[i].x = cnt[i], b[n-i].x = cnt[i]; while(t &lt; 2 * n + 2) t &lt;&lt;= 1, tc++; for(int i=0; i&lt;t; i++) br[i] = (br[i&gt;&gt;1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (tc - 1)); fft(a, 1, t), fft(b, 1, t); for(int i=0; i&lt;t; i++) a[i] = a[i] * b[i]; fft(a, -1, t); printf(\"%lld \", ans_zero); for(int i=1; i&lt;=n; i++) printf(\"%lld \", (lint)(a[n+i].x / t + 0.5)); puts(\"\"); return 0;&#125; }","categories":[{"name":"codeforces","slug":"codeforces","permalink":"http://arintaro.com/categories/codeforces/"},{"name":"题解","slug":"codeforces/题解","permalink":"http://arintaro.com/categories/codeforces/题解/"}],"tags":[{"name":"fft","slug":"fft","permalink":"http://arintaro.com/tags/fft/"},{"name":"卷积","slug":"卷积","permalink":"http://arintaro.com/tags/卷积/"}]},{"title":"bsgs","slug":"Template/数学/数论/bsgs","date":"2019-12-01T14:02:11.781Z","updated":"2019-12-01T14:03:14.277Z","comments":true,"path":"2019/12/01/Template/数学/数论/bsgs/","link":"","permalink":"http://arintaro.com/2019/12/01/Template/数学/数论/bsgs/","excerpt":"","text":"一、代码@card{ 注意判断无解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// test site: https://loj.ac/problem/10214#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;char buf[1 &lt;&lt; 21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int a, b, p;int qpow(int a, int b, int mod) &#123; int res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;struct mHash_table&#123; static const int htmod = 5e6 - 1; int head[htmod], nxt[maxn], key[maxn], val[maxn]; int s[maxn], tot; pii find(int nkey) &#123; int p = nkey % htmod; for(int i=head[p]; i; i=nxt[i]) &#123; if(key[i] == nkey) return mp(val[i], i); &#125; return mp(-1, -1); &#125; void insert(int nkey, int nval) &#123; pii now = find(nkey); if(now.first != -1) &#123; if(now.first &lt; nval) val[now.second] = nval; // 需要保证较大的j优先 return; &#125; int p = nkey % htmod; s[++tot] = p, key[tot] = nkey, val[tot] = nval; nxt[tot] = head[p], head[p] = tot; &#125; void clear() &#123; while(tot) head[s[tot--]] = 0; &#125;&#125;ht;// a^&#123;i * t&#125; == b * a^j (mod p)// t = ceil(sqrt(p))// 只有gcd(a, p) = 1才能有这种操作，否则膜p意义下无a的逆元，无法进行除法操作int bsgs(int a, int b, int p) &#123; a %= p, b %= p; if(a == 0) return -1; if(b == 1) return 0; ht.clear(); int t = ceil(sqrt(p)), lt = 1, rt = b, k = qpow(a, t, p); for(int j=0; j&lt;t; j++) &#123; ht.insert(rt, j); rt = (lint)rt * a % p; &#125; for(int i=1; i * t &lt; p + t; i++) &#123; lt = (lint)lt * k % p; int j = ht.find(lt).first; if(j != -1) return i * t - j; &#125; return -1;&#125;int main() &#123; int T, k; readint(T), readint(k); while(T--) &#123; readint(a), readint(b), readint(p); int res = 0; if(k == 1) res = qpow(a, b, p); if(k == 2) &#123; a %= p; res = a != 0 ? (lint)b * qpow(a, p - 2, p) % p : -1; &#125; if(k == 3) res = bsgs(a, b, p); if(res == -1) puts(\"Orz, I cannot find x!\"); else printf(\"%d\\n\", res); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"不定方程","slug":"不定方程","permalink":"http://arintaro.com/tags/不定方程/"}]},{"title":"多项式开根","slug":"Template/数学/多项式/多项式开根","date":"2019-12-01T12:36:27.192Z","updated":"2019-12-01T12:37:49.177Z","comments":true,"path":"2019/12/01/Template/数学/多项式/多项式开根/","link":"","permalink":"http://arintaro.com/2019/12/01/Template/数学/多项式/多项式开根/","excerpt":"","text":"一、代码@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// test site: https://www.luogu.com.cn/record/28011827// with O2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;char buf[1 &lt;&lt; 21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = (1 &lt;&lt; 19) + 10;const int mod = 998244353;int n;int g = 3, ginv, div2;int arr[maxn];int br[maxn];int qpow(int a, int b) &#123; int res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;void ntt(int arr[], int g, int n) &#123; for(int i=0; i&lt;n; i++) if(i &lt; br[i]) swap(arr[i], arr[br[i]]); for(int len=2; len&lt;=n; len&lt;&lt;=1) &#123; int mid = len &gt;&gt; 1, w = qpow(g, (mod - 1) / len); for(int *now=arr; now!=arr+n; now+=len) &#123; int k = 1; for(int i=0; i&lt;mid; i++) &#123; int x = (lint)k * now[i + mid] % mod; now[i + mid] = (now[i] - x) % mod; now[i] = (now[i] + x) % mod; k = (lint)k * w % mod; &#125; &#125; &#125;&#125;int temp_inv[maxn];void getinv(int arr[], int n, int res[]) &#123; int t = 1, tc = 0, *temp = temp_inv; while(t &lt; 2 * n) t &lt;&lt;= 1, tc++; memset(temp, 0, sizeof(int) * t * 2), memset(res, 0, sizeof(int) * t * 2); res[0] = qpow(arr[0], mod - 2); for(int now=2, nc=1; now&lt;=t; now&lt;&lt;=1, nc++) &#123; int len = now &lt;&lt; 1, len_inv = qpow(len, mod - 2); for(int i=0; i&lt;len; i++) br[i] = (br[i&gt;&gt;1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; nc); memcpy(temp, arr, sizeof(int) * now); ntt(res, g, len), ntt(temp, g, len); for(int i=0; i&lt;len; i++) res[i] = res[i] * (2 - (lint)res[i] * temp[i] % mod) % mod; ntt(res, ginv, len); for(int i=0; i&lt;now; i++) res[i] = (lint)res[i] * len_inv % mod; for(int i=now; i&lt;len; i++) res[i] = 0; &#125;&#125;int now_inv[maxn], temp_sqrt[maxn];void getsqrt(int arr[], int n, int res[]) &#123; int t = 1, tc = 0, *temp = temp_sqrt; while(t &lt; 2 * n) t &lt;&lt;= 1, tc++; memset(temp, 0, sizeof(int) * t * 2), memset(res, 0, sizeof(int) * t * 2); res[0] = 1; for(int now=2, nc=1; now&lt;=t; now&lt;&lt;=1, nc++) &#123; int len = now &lt;&lt; 1, len_inv = qpow(len, mod - 2); getinv(res, now &gt;&gt; 1, now_inv); for(int i=0; i&lt;len; i++) br[i] = (br[i&gt;&gt;1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; nc); memcpy(temp, arr, sizeof(int) * now); ntt(temp, g, len), ntt(now_inv, g, len); for(int i=0; i&lt;len; i++) now_inv[i] = (lint)temp[i] * now_inv[i] % mod; ntt(now_inv, ginv, len); for(int i=0; i&lt;now; i++) res[i] = div2 * ((lint)now_inv[i] * len_inv % mod + res[i]) % mod; &#125;&#125;int ans[maxn];int main() &#123; readint(n); for(int i=0; i&lt;n; i++) readint(arr[i]); ginv = qpow(g, mod - 2), div2 = qpow(2, mod - 2); getsqrt(arr, n, ans); for(int i=0; i&lt;n; i++) printf(\"%d \", ans[i] &lt; 0 ? ans[i] + mod : ans[i]); puts(\"\"); return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://arintaro.com/tags/倍增/"},{"name":"多项式","slug":"多项式","permalink":"http://arintaro.com/tags/多项式/"},{"name":"ntt","slug":"ntt","permalink":"http://arintaro.com/tags/ntt/"}]},{"title":"多项式求逆","slug":"Template/数学/多项式/多项式求逆","date":"2019-12-01T11:03:11.925Z","updated":"2019-12-01T11:05:10.613Z","comments":true,"path":"2019/12/01/Template/数学/多项式/多项式求逆/","link":"","permalink":"http://arintaro.com/2019/12/01/Template/数学/多项式/多项式求逆/","excerpt":"","text":"一、代码@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// test site: https://www.luogu.com.cn/problem/P4238#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;char buf[1 &lt;&lt; 21], *p1, *p2;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getc(); x = 0; for(; !isnum(ch); ch = getc()) if(ch == '-') f = -1; for(; isnum(ch); ch = getc()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = (1 &lt;&lt; 19) + 10;const int mod = 998244353;int n;int g = 3, ginv;int arr[maxn], br[maxn];int res[maxn], temp[maxn];int qpow(int a, int b) &#123; int res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;void ntt(int arr[], int g, int n) &#123; for(int i=0; i&lt;n; i++) if(i &lt; br[i]) swap(arr[i], arr[br[i]]); for(int len=2; len&lt;=n; len&lt;&lt;=1) &#123; int mid = len &gt;&gt; 1, w = qpow(g, (mod - 1) / len); for(int *now=arr; now!=arr+n; now+=len) &#123; int k = 1; for(int i=0; i&lt;mid; i++) &#123; int x = (lint)k * now[i + mid] % mod; now[i + mid] = (now[i] - x) % mod; now[i] = (now[i] + x) % mod; k = (lint)k * w % mod; &#125; &#125; &#125;&#125;// 如果多次调用需要加上数组清空void getinv(int arr[], int n) &#123; res[0] = qpow(arr[0], mod - 2); int t = 1, tc = 0; // t表示已经求好的长度 while(t &lt; n) &#123; t &lt;&lt;= 1, tc++; int len = t &lt;&lt; 1, len_inv = qpow(len, mod - 2); for(int i=0; i&lt;len; i++) br[i] = (br[i&gt;&gt;1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; tc); memcpy(temp, arr, sizeof(int) * t); // 注意这里乘的原函数长度是t，那么需要其二倍的空间len用来乘法 ntt(res, g, len), ntt(temp, g, len); for(int i=0; i&lt;len; i++) res[i] = (lint)res[i] * (2 - (lint)res[i] * temp[i] % mod) % mod; ntt(res, ginv, len); for(int i=0; i&lt;t; i++) res[i] = (lint)res[i] * len_inv % mod; for(int i=t; i&lt;len; i++) res[i] = 0; // 别忘了清空 &#125;&#125;int main() &#123; readint(n); for(int i=0; i&lt;n; i++) readint(arr[i]); ginv = qpow(3, mod - 2); getinv(arr, n); for(int i=0; i&lt;n; i++) printf(\"%d \", res[i] &lt; 0 ? res[i] + mod : res[i]); puts(\"\"); return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://arintaro.com/tags/倍增/"},{"name":"多项式","slug":"多项式","permalink":"http://arintaro.com/tags/多项式/"},{"name":"ntt","slug":"ntt","permalink":"http://arintaro.com/tags/ntt/"}]},{"title":"Luogu P3768 简单的数学题","slug":"Answer/easy","date":"2019-11-24T13:52:52.321Z","updated":"2019-11-24T22:38:13.680Z","comments":true,"path":"2019/11/24/Answer/easy/","link":"","permalink":"http://arintaro.com/2019/11/24/Answer/easy/","excerpt":"然而并不简单","text":"然而并不简单 Description:@card{ 给定$n$与$p$，求$$\\sum_{1 \\leq i \\leq n}{\\sum_{1 \\leq j \\leq n}{i \\times j \\times \\gcd(i, j)}}\\ \\text{mod}\\ p$$ $1 \\leq n \\leq 10^{10}$，保证$p$为质数。 } Solution:@card{ 先套路的变一波形 $$\\sum_{d}{(d \\times \\sum_{i, j}{i \\times j \\times [\\gcd(i, j) = d])}}$$$$\\sum_{d}{(d^3 \\times \\sum_{1 \\leq i, j \\leq \\lfloor\\frac{n}{d}\\rfloor}{i \\times j \\times [\\gcd(i, j) = 1]})}$$显然中间变成了我们熟悉的前$n$对互质数的乘积，$[\\gcd(i, j) = 1]$可以反演。 $$\\sum_{d}{(d^3 \\times \\sum_{1 \\leq i, j \\leq \\lfloor\\frac{n}{d}\\rfloor}{(i \\times j \\times \\sum_{p | i, p | j}{\\mu(p)}}))}$$ 再次交换中间式子和求和顺序，加之$[p\\ |\\ \\gcd(i, j)] = [p\\ |\\ i] \\times [p\\ |\\ j]$ $$\\sum_{d}{(d^3 \\times \\sum_{p}{\\mu(p) \\sum_{i, j}{(i \\times j \\times [p\\ |\\ i] \\times [p\\ |\\ j])}})}$$ 利用分配律，设$h(n) = \\sum_{i=1}^{n}{i}$ $$\\sum_{1\\leq d \\leq n}{(d^3 \\times \\sum_{1 \\leq p \\leq \\lfloor \\frac{n}{d} \\rfloor }{\\mu(p) \\times p^2 \\times (h(\\lfloor \\frac{n}{pd} \\rceil })^2)}$$ 然后我第一次写推到这里就没推了，这里显然已经可以做到线性，但是数据范围线性不够，所以我写了一个玄学的数列分块套数列分块再套一个杜教筛，实测可以跑到$10^8$，然而还是跑不了$10^9$与线性同样是$60pts$。 看完题解后发现可以从第一步直接用$\\phi$进行反演，这无疑与套路不太一样，所以我接着尝试交换求和顺序，化简上个式子。 要把什么交换出来呢？按常规的把$\\mu(p)$也不可以，降不了复杂度，因为这即便交换出来，两层的上下界还是一个范围内的整数。通常降复杂度需要先行外层枚举「约束性较强的条件」，以利于内部的计算，其不一定是一个变量，也有可能是一个代数式。 在本题中，我们枚举的「较强条件」即为$t = p \\times d$，在外层枚举它后，内层可以只考虑其约数，约数下的限制条件显然是有利于进一步反演的。 枚举$t$后，交换求和顺序，内层只需枚举$p, d$中的一个，另一个可以直接算出。$$\\sum_{1 \\leq t \\leq n}{((h(\\lfloor \\frac{n}{t} \\rfloor))^2 \\times t^2 \\sum_{p|t}{(\\mu(p) \\times \\frac{t}{p})}}$$ 注意到有结论$\\phi 1 = \\text{id}$，两边同时卷一个$\\mu$，即得到$\\phi = \\text{id} \\mu$，上式化为$$\\sum_{1 \\leq t \\leq n}{((h(\\lfloor \\frac{n}{t} \\rfloor))^2 \\times t^2 \\times \\phi(t))}$$ 于是数论分块套杜教筛即可在低于线性的复杂度求解。 本题也可以一开始就用$\\phi = \\text{id} * \\mu$反演$\\gcd$，推导会更加容易。 另外补一个结论$\\sum_{i=1}^{n}i^3=(\\sum_{i=1}^{n}i)^2$ } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;climits&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e6 + 10;const int maxprimes = 5e4 + 10;const int inf = INT_MAX;int mod, pren, div2, div6;lint n;inline int qpow(int a, int b) &#123; int res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;struct mHash_table&#123; static const int htmod = 5e6 - 1; int head[maxn], nxt[maxn], val[maxn], tot; lint key[maxn]; int find(lint nkey) &#123; int p = nkey % htmod; for(rint i=head[p]; i; i=nxt[i]) &#123; if(key[i] == nkey) return val[i]; &#125; return inf; &#125; void insert(lint nkey, int nval) &#123; if(find(nkey) != inf) return; int p = nkey % htmod; key[++tot] = nkey, val[tot] = nval; nxt[tot] = head[p], head[p] = tot; &#125;&#125;ht;int phi[maxn];int minfac[maxn], primes[maxprimes], totprimes = 0;void prework(int n) &#123; phi[1] = 1; for(rint i=2; i&lt;=n; i++) &#123; if(minfac[i] == 0) minfac[i] = i, phi[i] = i - 1, primes[++totprimes] = i; for(rint j=1, maxp=min(n/i, minfac[i]); j&lt;=totprimes &amp;&amp; primes[j]&lt;=maxp; j++) &#123; minfac[i * primes[j]] = primes[j]; if(primes[j] == minfac[i]) phi[i * primes[j]] = phi[i] * primes[j]; else phi[i * primes[j]] = phi[i] * (primes[j] - 1); &#125; &#125; for(rint i=1; i&lt;=n; i++) phi[i] = (phi[i-1] + (lint)phi[i] * i % mod * i % mod) % mod;&#125;#define calc1(n) ((lint)(n) * ((n) + 1) % mod * div2 % mod)inline int calc3(lint n) &#123; n %= mod; return calc1(n) * calc1(n) % mod;&#125;inline int calc2(lint n) &#123; n %= mod; return n * (n + 1) % mod * (2 * n + 1) % mod * div6 % mod;&#125;int ask_sum(lint n) &#123; if(n &lt;= pren) return phi[n]; int res = ht.find(n); if(res != inf) return res; else res = calc3(n); for(lint i=2; i&lt;=n; i++) &#123; lint d = n / i, j = min(n, n / d); res = (res - (lint)(calc2(j) - calc2(i-1)) * ask_sum(d) % mod) % mod; i = j; &#125; res = res &lt; 0 ? res + mod : res; ht.insert(n, res); return res;&#125;int solve(lint n) &#123; int res = 0; for(lint i=1; i&lt;=n; i++) &#123; lint d = n / i, j = min(n, n / d); int t = d % mod; res = (res + (lint)(ask_sum(j) - ask_sum(i-1)) * calc1(t) % mod * calc1(t) % mod) % mod; i = j; &#125; return res &lt; 0 ? res + mod : res;&#125;int main() &#123; readint(mod), readint(n); pren = pow(n, 2.0 / 3), div2 = qpow(2, mod - 2), div6 = qpow(6, mod - 2); prework(pren); cout &lt;&lt; solve(n) &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"快速求和","slug":"快速求和","permalink":"http://arintaro.com/tags/快速求和/"}]},{"title":"杜教筛","slug":"Template/数学/数论/杜教筛","date":"2019-11-24T08:00:32.443Z","updated":"2019-11-24T08:31:06.710Z","comments":true,"path":"2019/11/24/Template/数学/数论/杜教筛/","link":"","permalink":"http://arintaro.com/2019/11/24/Template/数学/数论/杜教筛/","excerpt":"","text":"一、代码@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122// test site: https://www.luogu.org/problem/P4213// 构造递推式后，注意先线筛出前n^&#123;2/3&#125;个数，复杂度降至O(n^&#123;2/3&#125;)// 注意2^32-1溢出的问题#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;climits&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 3e6 + 10;const int inf = INT_MAX;int n, pren = pow(inf, 2.0 / 3);struct mHash_table&#123; const static int htmod = 2999903; int head[maxn], nxt[maxn], key[maxn], val[maxn], tot; int s[maxn], stop; void clear() &#123; tot = 0; while(stop) head[s[stop--]] = 0; &#125; int find(int nkey) &#123; int p = nkey % htmod; for(rint i=head[p]; i; i=nxt[i]) &#123; if(key[i] == nkey) return val[i]; &#125; return inf; &#125; void insert(int nkey, int nval) &#123; if(find(nkey) != inf) return; int p = nkey % htmod; key[++tot] = nkey, val[tot] = nval; nxt[tot] = head[p], head[p] = tot; s[++stop] = p; &#125;&#125;ht;int mob[maxn], sum_mob[maxn];int minfac[maxn], primes[maxn], totprimes = 0;void prework(int n) &#123; mob[1] = 1; for(rint i=2; i&lt;=n; i++) &#123; if(minfac[i] == 0) mob[i] = -1, minfac[i] = i, primes[++totprimes] = i; for(rint j=1, maxp=min(n, n / i); j&lt;=totprimes &amp;&amp; primes[j] &lt;= maxp; j++) &#123; minfac[i * primes[j]] = primes[j]; if(i % primes[j]) mob[i * primes[j]] = -mob[i]; &#125; &#125; for(rint i=1; i&lt;=n; i++) sum_mob[i] = mob[i] + sum_mob[i-1];&#125;int ask_sum_mob(int n) &#123; if(n &lt;= pren) return sum_mob[n]; int res = ht.find(n); if(res != inf) return res; else res = 1; for(rint i=2; i&lt;=n; i++) &#123; int d = n / i, j = min(n, n / d); res -= (j - i + 1) * ask_sum_mob(d); i = j; if(i == n) break; &#125; ht.insert(n, res); return res;&#125;lint ask_sum_phi(int n) &#123; lint res = 0; for(rint i=1; i&lt;=n; i++) &#123; int d = n / i, j = min(n, n / d); res += (lint)(ask_sum_mob(j) - ask_sum_mob(i - 1)) * ((lint)d + 1) * d / 2; i = j; if(i == n) break; &#125; return res;&#125;int main() &#123; prework(pren); int T = 0; readint(T); while(T--) &#123; readint(n); printf(\"%lld %d\\n\", ask_sum_phi(n), ask_sum_mob(n)); &#125; return 0;&#125;// sum&#123;(f * g)(i), 1 &lt;= i &lt;= n&#125; = sum&#123;g(i) * S[n / i], 1 &lt;= i &lt;= n&#125;// S[n] = 1 - sum&#123;S[n / i], 2 &lt;= i &lt;= n&#125;// f = mob, g = 1, (f * g)(x) = [x == 1]// sum&#123;sum&#123;mob[d] * i / d, d | i&#125;, 1 &lt;= i &lt;= n&#125;// sum&#123;mob[d] * sum&#123;k, 1 &lt;= k &lt;= [n / d]&#125;, 1 &lt;= d &lt;= n&#125;// phi[n] = sum&#123;sum&#123;mob[d], d | gcd(i, n)&#125;, 1 &lt;= i &lt;= n&#125;// phi[n] = sum&#123;mob[d] * n / d, d | n&#125;/*bool isprime(int x) &#123; if(x == 2 || x == 3) return 1; if(x == 1 || x == 0 || (x % 6 != 1 &amp;&amp; x % 6 != 5)) return 0; for(rint t=5, maxt=sqrt(x); t&lt;=maxt; t+=6) &#123; if(x % t == 0 || x % (t + 2) == 0) return 0; &#125; return 1;&#125;void print(int L, int R) &#123; for(rint i=L; i&lt;=R; i++) if(isprime(i)) printf(\"%d\\n\", i);&#125; */ }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"快速求和","slug":"快速求和","permalink":"http://arintaro.com/tags/快速求和/"}]},{"title":"SPOJ5971 lcm-sum","slug":"Answer/lcmsum","date":"2019-11-23T03:46:28.964Z","updated":"2019-11-23T03:56:55.801Z","comments":true,"path":"2019/11/23/Answer/lcmsum/","link":"","permalink":"http://arintaro.com/2019/11/23/Answer/lcmsum/","excerpt":"","text":"Description:@card{ 求$\\sum_{i=1}^{n}\\text{lcm}(i, n)$。 多组询问$1 \\leq T \\leq 300000$，$1 \\leq n \\leq 10^6$ } Solution:@card{ 结合数据范围可以看出单次询问至少要做到单$\\text{log}$，考虑推一下式子。 把$\\text{lcm}$化为$\\text{gcd}$后，主要应用性质$\\gcd(a, n) = \\gcd(n - a, n)$，去掉内层的带权，从而转化为对$\\gcd$的倒数求和问题。 最后问题转化为求一个函数$$f(n) = \\sum_{d|n}{d \\times \\phi(d)}$$ 显然可以通过埃筛在$O(n\\log{n})$的时间求出，不过仔细考虑其性质，可以发现其是积性函数，线筛一下即可。 具体实现下，每次乘一个最小质因子：如果其中不含这个因子，直接乘即可；含这个因子时，问题转化为快速求出$f(p^k)$，其中$p$是质数，推下式子，维护每个数去掉所有它的最小质因子后的数即可，这样就可以直接乘了。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e6 + 10;int n = 1e6;int reg[maxn], cpow[maxn];int minfac[maxn], primes[maxn], totprimes = 0;lint sum_phi[maxn];void getsum(int n) &#123; sum_phi[1] = 1; for(rint i=2; i&lt;=n; i++) &#123; if(minfac[i] == 0) &#123; minfac[i] = i, primes[++totprimes] = i; reg[i] = 1, cpow[i] = i; sum_phi[i] = 1 + (lint)i * (i - 1); &#125; for(rint j=1; j&lt;=totprimes &amp;&amp; primes[j] &lt;= n / i; j++) &#123; int k = primes[j] * i; minfac[k] = primes[j]; if(i % primes[j]) &#123; reg[k] = i, cpow[k] = primes[j]; sum_phi[k] = sum_phi[i] * sum_phi[primes[j]]; &#125; else &#123; reg[k] = reg[i], cpow[k] = cpow[i] * primes[j]; sum_phi[k] = sum_phi[reg[i]] * (sum_phi[cpow[i]] + (lint)cpow[k] * (cpow[k] - cpow[i])); break; &#125; &#125; &#125;&#125;int main() &#123; int T; getsum(n); readint(T); while(T--) &#123; readint(n); printf(\"%lld\\n\", n * (sum_phi[n] + 1) / 2); &#125; return 0;&#125; }","categories":[{"name":"SPOJ","slug":"SPOJ","permalink":"http://arintaro.com/categories/SPOJ/"},{"name":"题解","slug":"SPOJ/题解","permalink":"http://arintaro.com/categories/SPOJ/题解/"}],"tags":[{"name":"快速求和","slug":"快速求和","permalink":"http://arintaro.com/tags/快速求和/"}]},{"title":"Luogu P2054 [AHOI2005]洗牌","slug":"Answer/card","date":"2019-11-22T01:30:48.431Z","updated":"2019-11-22T01:39:20.460Z","comments":true,"path":"2019/11/22/Answer/card/","link":"","permalink":"http://arintaro.com/2019/11/22/Answer/card/","excerpt":"","text":"Description:@card{ 给定一个洗牌方式，要求求出$n$张牌洗$m$次后的第$k$张是什么。 $1 \\leq n, m, k \\leq 10^10$ } Solution:@card{ 发现只要找某张牌在下次会到哪里即可。 我先考虑了逆推，显然有$k = k &amp; 1 ? (k + 1) / 2 + n / 2 : k / 2$，模拟可得到$O(n)$做法，但是跑不过去。 接着考虑是否有循环节，打表发现存在循环节，但很多数字的循环节为$O(n)$级别，复杂度可能退化。 接着考虑分块，发现$n$很大，分块转移的话要能跑过去至少得预处理$10^3$的一起转移，但是$n$太大了。 至此逆推宣告失败，换正推，即考虑起始状态哪个元素洗$m$次可以到$k$，可以推出$k’ = 2k(\\mod\\ n + 1)$，洗$m$次即解$2^m \\times x \\equiv k$，乘个逆元即可。 同时需要注意$n+1$不一定是素数，不能用快速幂直接求，需要用exgcd，和$10^10$会爆long long，需要手写乘法。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;lint n, m, k;// 正推与逆推lint exgcd(lint a, lint b, lint&amp; x, lint&amp; y) &#123; if(b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;lint getinv(lint a, lint p) &#123; lint x, y; exgcd(a, p, x, y); x %= p; return x &lt; 0 ? x + p : x;&#125;inline lint mul(lint x, lint y, lint mod) &#123; x %= mod, y %= mod; // x, y可能大于mod时这行千万别忘了 lint t = x * y - (lint)((long double)x / mod * y + 0.5) * mod; return t &lt; 0 ? t + mod : t;&#125;lint qpow(lint a, lint b, lint mod) &#123; lint res = 1; for(; b; b&gt;&gt;=1) &#123; if(b &amp; 1) res = mul(res, a, mod); a = mul(a, a, mod); &#125; return res;&#125;int main() &#123; readint(n), readint(m), readint(k); cout &lt;&lt; mul(k, getinv(qpow(2, m, n + 1), n + 1), n + 1) &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"省选","slug":"省选","permalink":"http://arintaro.com/categories/省选/"},{"name":"题解","slug":"省选/题解","permalink":"http://arintaro.com/categories/省选/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"逆元","slug":"逆元","permalink":"http://arintaro.com/tags/逆元/"}]},{"title":"乘法逆元的线性递推","slug":"Template/数学/数论/乘法逆元","date":"2019-11-22T00:00:43.571Z","updated":"2019-11-22T00:02:01.324Z","comments":true,"path":"2019/11/22/Template/数学/数论/乘法逆元/","link":"","permalink":"http://arintaro.com/2019/11/22/Template/数学/数论/乘法逆元/","excerpt":"","text":"一、代码@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// test site: https://www.luogu.org/problem/P5431// 任意n个数先取前缀积，递推出前缀积的逆元#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e6 + 10;int n, mod, k;int arr[maxn], prod[maxn], prod_inv[maxn], inv[maxn];int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if(b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;// 模数与其互质则为逆元int getinv(int a, int p) &#123; int x, y; exgcd(a, p, x, y); x %= p; return x &lt; 0 ? x + p : x;&#125; int main() &#123; readint(n), readint(mod), readint(k); for(rint i=1; i&lt;=n; i++) readint(arr[i]); prod[0] = 1; for(rint i=1; i&lt;=n; i++) prod[i] = (lint)prod[i-1] * arr[i] % mod; prod_inv[n] = getinv(prod[n], mod); for(rint i=n-1; i&gt;=1; i--) prod_inv[i] = (lint)prod_inv[i + 1] * arr[i + 1] % mod; for(rint i=1; i&lt;=n; i++) inv[i] = (lint)prod_inv[i] * prod[i - 1] % mod; int ans = 0, t = 1; for(rint i=1; i&lt;=n; i++) &#123; t = (lint)t * k % mod; ans = (ans + (lint)t * inv[i] % mod) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"逆元","slug":"逆元","permalink":"http://arintaro.com/tags/逆元/"},{"name":"模意义","slug":"模意义","permalink":"http://arintaro.com/tags/模意义/"}]},{"title":"exgcd","slug":"Template/数学/数论/exgcd","date":"2019-11-21T13:43:22.330Z","updated":"2019-11-21T13:45:57.686Z","comments":true,"path":"2019/11/21/Template/数学/数论/exgcd/","link":"","permalink":"http://arintaro.com/2019/11/21/Template/数学/数论/exgcd/","excerpt":"毒瘤","text":"毒瘤 一、代码@card{ $ax + by = c$的通解是$a(x + k\\frac{b}{d}) + b(y + k\\frac{a}{d}) = c$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// test site: https://www.luogu.org/problem/P5656#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define int long long#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;int a, b, c;int exgcd(int a, int b, int&amp; x, int&amp; y) &#123; if(b == 0) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;signed main() &#123; int T = 0; readint(T) ; while(T--) &#123; int x, y; readint(a), readint(b), readint(c); int d = exgcd(a, b, x, y); if(c % d != 0) puts(\"-1\"); else &#123; x *= c / d, y *= c / d; int lt = b / d, rt = a / d; int l = ceil((double)(1 - x) / lt), r = floor((double)(y - 1) / rt); // 注意C++实现的整数取整是向0取整，而这里我们需要下取整 if(l &lt;= r) &#123; int minx = x + l * lt, maxx = x + r * lt; int miny = y - l * rt, maxy = y - r * rt; if(minx &gt; maxx) swap(minx, maxx); if(miny &gt; maxy) swap(miny, maxy); printf(\"%lld %lld %lld %lld %lld\\n\", r - l + 1, minx, miny, maxx, maxy); &#125; else &#123; x %= lt, y %= rt; if(x &lt; 0) x += lt; if(y &lt; 0) y += rt; if(x == 0) x = lt; if(y == 0) y = rt; printf(\"%lld %lld\\n\", x, y); &#125; &#125; &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"gcd","slug":"gcd","permalink":"http://arintaro.com/tags/gcd/"},{"name":"不定方程","slug":"不定方程","permalink":"http://arintaro.com/tags/不定方程/"}]},{"title":"同余最短路","slug":"Template/数学/数论/同余最短路","date":"2019-11-21T12:40:03.186Z","updated":"2019-11-21T12:46:02.204Z","comments":true,"path":"2019/11/21/Template/数学/数论/同余最短路/","link":"","permalink":"http://arintaro.com/2019/11/21/Template/数学/数论/同余最短路/","excerpt":"同余与最短路哪个更重要？","text":"同余与最短路哪个更重要？ 一、代码@card{ 给定若干个数，前面乘个系数求和，对这个和统计一些信息，一般要考虑同余。 同余最短路只保留在一个剩余系下的最小数字，用以统计方案数，可以看做是暴力dp的一种优化？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// test site: https://www.luogu.org/problem/P2371#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define rint register int#define lint long long#define pii pair&lt;lint, int&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e5 + 10;const int maxm = 12 * maxn;int n;int arr[20];int head[maxn], ev[maxm], nxt[maxm], ew[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;lint dist[maxn], mint, maxt;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;void dijkstra() &#123; memset(dist, 0x7f, sizeof(dist)); dist[0] = 0; q.push(mp(dist[0], 0)); while(!q.empty()) &#123; pii now = q.top(); q.pop(); int x = now.second; if(dist[x] &lt; now.first) continue; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &gt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; q.push(mp(dist[y], y)); &#125; &#125; &#125;&#125;int main() &#123; readint(n), readint(mint), readint(maxt); for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]); if(arr[i] &lt; arr[1]) swap(arr[1], arr[i]); &#125; for(rint i=0; i&lt;arr[1]; i++) &#123; for(rint j=2; j&lt;=n; j++) addedge(i, (i + arr[j]) % arr[1], arr[j]); &#125; dijkstra(); // mint &lt;= t + k * x &lt;= maxt // ceil((mint - t) / x) &lt;= k &lt;= floor((maxt - t) / x) lint ans = 0; for(rint i=0; i&lt;arr[1]; i++) &#123; if(dist[i] &lt;= maxt) &#123; ans += (maxt - dist[i]) / arr[1] - max(ceil((double)(mint - dist[i]) / arr[1]), 0.0) + 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"同余","slug":"同余","permalink":"http://arintaro.com/tags/同余/"},{"name":"最短路","slug":"最短路","permalink":"http://arintaro.com/tags/最短路/"}]},{"title":"Miller–Rabin素性判断","slug":"Template/数学/数论/miller","date":"2019-11-21T11:15:44.175Z","updated":"2019-11-21T11:38:00.995Z","comments":true,"path":"2019/11/21/Template/数学/数论/miller/","link":"","permalink":"http://arintaro.com/2019/11/21/Template/数学/数论/miller/","excerpt":"有几率错误 == OI范围内完全正确","text":"有几率错误 == OI范围内完全正确 一、代码@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// test site: https://loj.ac/problem/143#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;climits&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;// long long范围内前12个质数可保证完全正确int rprimes[] = &#123;0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37&#125;, rtot = 12;inline lint qmul(lint x, lint y, lint mod) &#123; lint t = x * y - (lint)((long double)x / mod * y + 0.5) * mod; // 注意这里先/mod 再加0.5 return t &lt; 0 ? t + mod : t;&#125;inline lint qpow(lint a, lint b, lint mod) &#123; lint res = 1; for(; b; b &gt;&gt;= 1) &#123; if(b &amp; 1) res = qmul(res, a, mod); a = qmul(a, a, mod); &#125; return res;&#125;inline bool isprime(lint n) &#123; if(n &lt;= 2) return n == 2; // &lt;=2直接返回 if(!(n &amp; 1)) return 0; // 偶数直接返回 lint a = n - 1, b = 0; while(!(a &amp; 1)) a &gt;&gt;= 1, b++; for(rint i=1; i&lt;=rtot; i++) &#123; if(rprimes[i] == n) return 1; // 注意这里的特判 lint x = qpow(rprimes[i], a, n), y = x; for(rint j=1; j&lt;=b; j++) &#123; x = qmul(x, x, n); // 防爆long long if(x == 1 &amp;&amp; !(y == 1 || y == n - 1)) return 0; y = x; &#125; if(x != 1) return 0; // 注意还要判断结束后的费马小定理 &#125; return 1;&#125;int main() &#123; lint x = 0; while(scanf(\"%lld\", &amp;x) != EOF) puts(isprime(x) ? \"Y\" : \"N\"); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// test site: https://www.luogu.org/problem/P3383#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;int n, m;// int范围内只需3个，2，7，61int rprimes[] = &#123;0, 2, 7, 61&#125;, rtot = 3;int qpow(int a, int b, int mod) &#123; int res = 1; for(; b; b &gt;&gt;= 1) &#123; if(b &amp; 1) res = (lint)res * a % mod; a = (lint)a * a % mod; &#125; return res;&#125;bool isprime(int n) &#123; if(n &lt;= 2) return n == 2; if(!(n &amp; 1)) return 0; int a = n - 1, b = 0; if(!(a &amp; 1)) a &gt;&gt;= 1, b++; for(rint i=1; i&lt;=rtot; i++) &#123; if(n == rprimes[i]) return 1; int x = qpow(rprimes[i], a, n), y = x; for(rint j=1; j&lt;=b; j++) &#123; x = (lint)x * x % n; if(x == 1 &amp;&amp; y != 1 &amp;&amp; y != n - 1) return 0; y = x; &#125; if(x != 1) return 0; &#125; return 1;&#125;int main() &#123; readint(n), readint(m); int x = 0; while(m--) &#123; readint(x); puts(isprime(x) ? \"Yes\" : \"No\"); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"},{"name":"素数","slug":"素数","permalink":"http://arintaro.com/tags/素数/"},{"name":"随机化","slug":"随机化","permalink":"http://arintaro.com/tags/随机化/"}]},{"title":"long long的模意义下乘法","slug":"Template/小工具/mul","date":"2019-11-21T11:06:14.798Z","updated":"2019-11-22T01:23:11.582Z","comments":true,"path":"2019/11/21/Template/小工具/mul/","link":"","permalink":"http://arintaro.com/2019/11/21/Template/小工具/mul/","excerpt":"还能不能再给力点呢？","text":"还能不能再给力点呢？ Code:@card{ 防爆long long12345inline lint qmul(lint x, lint y, lint mod) &#123; x %= mod, y %= mod; // x, y可能大于mod时这行千万别忘了 lint t = x * y - (lint)((long double)x / mod * y + 0.5) * mod; return t &lt; 0 ? t + mod : t;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]},{"title":"《组合数学》笔记","slug":"Algorithm/《组合数学》笔记","date":"2019-11-18T13:44:38.431Z","updated":"2019-11-21T06:10:35.299Z","comments":true,"path":"2019/11/18/Algorithm/《组合数学》笔记/","link":"","permalink":"http://arintaro.com/2019/11/18/Algorithm/《组合数学》笔记/","excerpt":"","text":"第一章@card{ 经验 常常需要在剩余系下考虑一些东西 棋盘覆盖问题经常需要染色，常见的k染色方式是在列上加一剩余系下也加一，行上加一剩余系下减一 结论 $m \\times n$棋盘有$b$格牌的完美覆盖当且仅当$b$是$m$或$n$的一个因子 习题摸了 } 第二章@card{ 经验 运用加法原理的技巧是把全集分成互斥的，少量的易处理部分。 常常想着减法原理，总数减去不合法的方案。 运用乘法原理时优先选择约束性强的选择。 计数时一定要注意”顺序”，时常需要加序/消序。 隔板法、捆绑法。 结论 $\\displaystyle \\binom{n}{m} = \\frac{n!}{(n-m)!m!}$，$\\displaystyle \\mathrm A_n^m = \\frac{n!}{(n - m)!}$ 多重集$S={n_1\\cdot a_1,n_2\\cdot a_2,\\cdots,n_k\\cdot a_k,}$排列数为$\\displaystyle \\frac{(\\sum{a_i})!}{\\prod{a_i!}}$ 设$n = \\sum{n_i}$，且$n_i &gt; 0$，那么$$\\binom{n}{n_1}\\binom{n - n_1}{n_2}\\binom{n - n_1 - n_2}{n_3}\\cdots\\binom{n-n_1-n_2-\\cdots-n_{k-1}}{n_k} = \\frac{n!}{\\prod{n_i!}}$$ 有$n$种对象的无限多重集的k组合数位$\\binom{n + k - 1}{k}$ 方程$x_1 + x_2 + x_3 + \\cdots + x_n = k$，其中$x_i \\geq 0$解的个数为$\\binom{n + k - 1}{k}$，经常通过变量代换来改变限制条件中的上下界 习题 有多少个各位数字均不相同，且不包含数字2，7且大于5400的整数？ 显然至多有八位，四位前都可以直接累加，四位需要讨论5xxx，54xx，注意深入讨论时别忘了数字不同和不包含2、7的限制条件。 10男，12女选5人，有多少种方法使得5人中至少有2女。 经典错解是用组合选上2女，再乘上剩下选谁，这会导致重复计数，正解是枚举选几个女。 15人选11人组球队，5人只能后卫，8人只能边卫，2人两项都行，问方案数。 对于有任意性的选项，通常选择枚举，大力讨论两项都行的两人怎么用即可。 2个红车和4个蓝车放$8\\times8$棋盘上，互不攻击方案数？ 先选出6行6列转化成之前做过的问题，再乘上匹配方案数$6!$，最后乘上颜色方案数$\\binom{2}{6}$即可。 有$n$根棍排成一行，选$k$根，相邻的棍之间至少隔$l$根棍，方案数。 正难则反，任何计数问题的方案数显然与其补集方案数一一对应。 考虑拿完后剩下的段，问题转化成结论5的方程中的解，再用变量代换调整下界即可。 }","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"}]},{"title":"CSP-S 2019 游记","slug":"Essay/CSP-S2019","date":"2019-11-18T02:58:24.781Z","updated":"2019-11-18T03:43:59.851Z","comments":true,"path":"2019/11/18/Essay/CSP-S2019/","link":"","permalink":"http://arintaro.com/2019/11/18/Essay/CSP-S2019/","excerpt":"退役警告","text":"退役警告 Day[-7,-1]@card{ 考前很颓，除了模拟赛以外几乎没写任何题目，看了几部动画。 Day-1的时候补了《女高中生的无聊日常》，成功破坏了我复习模版的计划。 我本来想复习的，但她实在太有趣了.jpg } Day0@card{ 坐动车到了大连，没住CCF唯一指定酒店，300一晚还离考场这么远，选择了在考场对面的小旅店。(就是开房的大学生情侣属实有点多。。) 下午试机进去敲了emacs配置和两份树链剖分拍了一下，居然没能一遍写对，现场调试了一下，觉得今年很可能也是树论大赛。 晚上看了青春野狼的剧场版，感觉这个制作质量出剧场版是不是有点坑啊，还不如出TV节奏放慢点，B站上的比BD还早也是神奇。 比较失望的是省选时看好的饭店居然两天都停业了，只能吃了两天KFC。 睡前想着考前这么颓今年肯定炸了。 } Day1@card{ 开场先看题，发现Day1居然就有两棵树。 T1先扫了一眼，发现没怎么看懂，后来发现还是分治套路题，注意了一下ull的问题，10min过了大样例就没管了。 T2看了看就觉得是毒瘤出题人又把序列上的原题搬树上了，裸的DP跑不过去，好像要对每个点计算贡献，手玩了一下发现就是当前括号深度下的左括号数，用栈维护一下就好，为了避免子树间的影响，每次回溯前修复对栈中元素的修改即可，稍微调了一下过了大样例，这个时候才9:30，觉得今天稳了。 T3看了看好像不能一眼出解，于是求稳回来拍了一下T2，跑了1e4组后到了9:50，接着想T3，觉得肯定是个贪心。 这个时候我就有点飘了，觉得今天能AK了，耳边回响起了卢姥爷的经典语录。 于是yy了几个贪心做法都被我自己hack掉了，到了11:00决定放弃正解，先保rank求个部分分，觉得大家肯定都切了T3，今天已经凉了。 想到了11:35，一个部分分都没想出来，于是匆匆打了10pts开始颓了，觉得今年WC无望了。 出来发现T3是个神题，除了少数几个神仙大家好像都是210的样子。 下午和晚上接着看动画，听zzh说他复制错了Day1，MLE 10pts，我觉得他假假，又担心自己T2挂了，影响明天心态，于是就没测luogu数据。 估分：100 + 100 + 10咕分：100 + 100 + 10CCF： } Day2@card{ 开场先看题，发现今天居然还有一棵树。 觉得T1很可做的样子，毕竟emiya的故事我还是很熟悉的，于是对着T1肝到了10:00+，发现自己还是不会做，觉得今天要爆零了，我计数太弱了，敲了个64pts就跑了，敲完已经10:20了，今天应该是凉了，D2T1都不会做，别人应该都切了吧，又回想起昨天的D1T3，觉得可能是难度乱序，于是稳住心态接着看T2。 T2随便看了看觉得应该是个斜率优化，仔细看看好像不是，有一个诡异的限制条件，那么应该是一个性质/结论保证的dp，随便猜了几个就猜中了，大概还是在套路里的，先写了个倍增调了一会，后来发现可以直接单调队列维护，就改单调队列了，敲完88pts已经11:20左右了，觉得剩的时间不多了就先看了T3，没写最后的12pts高精，更多的是对自己的常数不自信吧，应该跑不了4e7，出来估一下答案上界发现开俩long long就行，这12分还是很可惜的。 T3直接奔暴力分打了，T1耽误太长时间了，先写了个45pts，我居然调了一段时间暴力，接下来链的10pts很好拿也顺手写了。大概在11:40-50的时候我yy出了T3的正解，然而我还没想到二叉树的情况有什么简便写法，没猜到那个结论，心态崩了，觉得写不完了，于是T2又拍了1e5组，检查了一下文件名就颓到12:00了。 出来一问大家好像都没切T1,T3的样子，两天的T3部分分我都没拿全，幸好D2T2猜到结论稳了一手，大概拿了个大众分？不知道进WC有没有戏。如果D2T1放T2或者T3的位置上，D2T2、D2T3我应该能够切掉。 dalao们说T1是套路计数题，果然我计数还是太弱了。 估分：64 + 88 + 55咕分：64 + 88 + 55CCF： } 后记@card{ 题目质量很高，明年不会再来了.jpg 题是好题，可惜我都不会做，但两天的大样例和部分分都比较良心，几乎每档部分分都给了大样例，部分分给的也比较多，我这种六题只会做两题的暴力选手都能混到400。话说大样例越多，对纯暴力选手更不友好吧，今年的题似乎告诉我们啥都不会混个省一的时代已经过去了，联赛难度逐年递增，然而分数线也是正相关的 虽然D2T2和D2T3比较可惜，但说实话我没出什么叉子(写错文件名，交错文件)已经足够幸运了。Rank似乎没预想的低，毕竟考前一直在颓。 }","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"颓废","slug":"颓废","permalink":"http://arintaro.com/tags/颓废/"}]},{"title":"LOJ146 DFS序4","slug":"Answer/dfs4","date":"2019-11-13T11:23:03.007Z","updated":"2019-11-13T11:34:39.780Z","comments":true,"path":"2019/11/13/Answer/dfs4/","link":"","permalink":"http://arintaro.com/2019/11/13/Answer/dfs4/","excerpt":"","text":"Description:@card{ 给一棵有根树，根结点的编号为$root$。每个结点都有一个权值。接下来有 $m$ 组操作，操作分为三类： $1\\ a\\ x$，表示将结点$a$的权值增加$x$；$2\\ a\\ x$，表示将$a$的子树上所有结点的权值增加$x$；$3\\ a\\ b$，表示求「结点 $a$ 到结点 $b$ 的简单路径」上所有结点的权值之和。 $O(n\\log{n})$ } Solution:@card{ 树剖可以直接解决，然而会被卡，要做到一个$\\log$只能支持”单点加, 子树加, 单点查, 子树查”，是无法直接对一个链考虑的，所以我们要考虑如何用这几种操作满足题目需求。 考虑如何查询，显然对链考虑复杂度要多个$\\log$，需要考虑操作对查询的影响，操作3按套路变成查到根节点的节点权值之和，不妨去维护”每个节点到根节点的路径权值之和”。 对于操作1，显然可以直接子树加解决。 对于操作2，影响可以写成$(deep[b] - deep[a] + 1) \\times x$，与$dfs3$一样，维护一下即可。 数据结构方面需要支持区间修改和单点查询，用差分树状数组解决即可，尽量不要用线段树，容易被卡。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define lowbit(x) ((x) &amp; (-x))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e6 + 10;const int maxm = 2 * maxn;const int maxnode = 2 * maxn;int n, m, root;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;struct Bint&#123; lint c[maxn]; inline void add(int pos, lint x) &#123; while(pos &lt;= n) c[pos] += x, pos += lowbit(pos); &#125; inline void add(int L, int R, lint x) &#123; add(L, x), add(R+1, -x); &#125; inline lint ask(int pos) &#123; lint res = 0; while(pos) res += c[pos], pos -= lowbit(pos); return res; &#125;&#125;bt1, bt2, bt3;int val[maxn];lint dist[maxn];int dfn[maxn], dfr[maxn], totdfn = 0;int dfa[maxn], deep[maxn], size[maxn];int wtop[maxn], wson[maxn];void dfs1(int x, int fa, int d) &#123; dfa[x] = fa, deep[x] = d, size[x] = 1; dfn[x] = ++totdfn, dist[x] += val[x]; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dist[y] = dist[x]; dfs1(y, x, d + 1); size[x] += size[y]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125; dfr[x] = totdfn;&#125;void dfs2(int x, int top) &#123; wtop[x] = top; if(wson[x]) dfs2(wson[x], top); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == dfa[x] || y == wson[x]) continue; dfs2(y, y); &#125;&#125;inline int lca(int x, int y) &#123; while(wtop[x] != wtop[y]) &#123; if(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y); x = dfa[wtop[x]]; &#125; return deep[x] &lt; deep[y] ? x : y;&#125;inline void add_pos(int p, int x) &#123; bt1.add(dfn[p], dfr[p], x);&#125;inline void add_son(int p, int x) &#123; bt2.add(dfn[p], dfr[p], x), bt3.add(dfn[p], dfr[p], (lint)deep[p] * x);&#125;inline lint ask_path(int p) &#123; if(p == 0) return 0; return dist[p] + bt1.ask(dfn[p]) + (deep[p] + 1) * bt2.ask(dfn[p]) - bt3.ask(dfn[p]);&#125;inline lint ask_path(int a, int b) &#123; int nlca = lca(a, b); return ask_path(a) + ask_path(b) - ask_path(nlca) - ask_path(dfa[nlca]);&#125;int main() &#123; readint(n), readint(m), readint(root); for(rint i=1; i&lt;=n; i++) readint(val[i]); int nu, nv; for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs1(root, 0, 1), dfs2(root, root); int ins, a, b, x; while(m--) &#123; readint(ins); if(ins == 1) readint(a), readint(x), add_pos(a, x); else if(ins == 2) readint(a), readint(x), add_son(a, x); else readint(a), readint(b), printf(\"%lld\\n\", ask_path(a, b)); &#125; return 0;&#125; }","categories":[{"name":"LOJ","slug":"LOJ","permalink":"http://arintaro.com/categories/LOJ/"},{"name":"题解","slug":"LOJ/题解","permalink":"http://arintaro.com/categories/LOJ/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"DFS序","slug":"DFS序","permalink":"http://arintaro.com/tags/DFS序/"}]},{"title":"LOJ146 DFS序3","slug":"Answer/dfs3","date":"2019-11-13T10:53:11.483Z","updated":"2019-11-13T11:22:58.192Z","comments":true,"path":"2019/11/13/Answer/dfs3/","link":"","permalink":"http://arintaro.com/2019/11/13/Answer/dfs3/","excerpt":"","text":"Description:@card{ 给一棵有根树，$n$个结点组成。根结点的编号为 $root$。每个结点都有一个权值.。接下来有 $m$ 组操作，操作分为三类： $1\\ a\\ b\\ x$，表示将「结点 $a$ 到结点 $b$ 的简单路径」上所有结点的权值都增加 $x$；$2\\ a$，表示求结点 $a$ 的权值。$3\\ a$，表示求 $a$ 的子树上所有结点的权值之和。 $O(n\\log{n})$ } Solution:@card{ 树剖可以直接解决，然而会被卡，要做到一个$\\log$只能支持”单点加, 子树加, 单点查, 子树查”，是无法直接对一个链考虑的，所以我们要考虑如何用这几种操作满足题目需求。 考虑修改操作1对查询操作2，3的影响，显然操作1可以直接拆分成「节点$a$到根节点的路径上所有节点的权值都增加$x$」，所以考虑一次操作对其祖先节点的影响即可。 显然对操作2的影响可以直接用树上差分的思想解决问题，每次只在起始节点上单点加一下，单点查求子树和即可。 操作3有些麻烦，需要推一下式子，单独维护子树和，不妨设$a$为起点，$b$为$a$的祖先节点，加了$x$，对$b$的子树和影响为$$(deep[a] - deep[b] + 1) \\times x$$分离变量可得$$(deep[a] + 1) \\times x - deep[b] \\times x$$对于一个查询操作$deep[b]$给定，那么只要考虑所有的$a$与其修改操作的$x$之和即可，其中所有的$a$显然是$b$的子树，不妨设操作2中树上的差分数组为$det$，差分数组的和即当前点的权值为$val$。所以有$$\\sum{(deep[a] + 1) \\times det[a]} - deep[b] \\times val[b]$$分别维护一下即可。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define lowbit(x) ((x) &amp; (-x))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e6 + 10;const int maxm = 2 * maxn;int n, m, root;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;lint sum[maxn];int val[maxn];int dfn[maxn], dfr[maxn], totdfn = 0;int dfa[maxn], size[maxn], deep[maxn];int wson[maxn], wtop[maxn];void dfs1(int x, int fa, int d) &#123; dfa[x] = fa, deep[x] = d, size[x] = 1; dfn[x] = ++totdfn, sum[x] = val[x]; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, x, d + 1); size[x] += size[y], sum[x] += sum[y]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125; dfr[x] = totdfn;&#125;void dfs2(int x, int top) &#123; wtop[x] = top; if(wson[x]) dfs2(wson[x], top); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == dfa[x] || y == wson[x]) continue; dfs2(y, y); &#125;&#125;inline int lca(int x, int y) &#123; while(wtop[x] != wtop[y]) &#123; if(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y); x = dfa[wtop[x]]; &#125; return deep[x] &lt; deep[y] ? x : y;&#125;struct Bint&#123; lint arr[maxn]; void add(int pos, lint x) &#123; if(pos == 0) return; // 注意值域里有0 while(pos &lt;= n) arr[pos] += x, pos += lowbit(pos); &#125; lint ask(int pos) &#123; lint res = 0; while(pos) res += arr[pos], pos -= lowbit(pos); return res; &#125; lint ask(int L, int R) &#123; return ask(R) - ask(L - 1); &#125;&#125;bt1, bt2;inline void add_path(int p, int x) &#123; bt1.add(dfn[p], x), bt2.add(dfn[p], (lint)(deep[p] + 1) * x);&#125;inline void add_path(int a, int b, int x) &#123; int nlca = lca(a, b); add_path(a, x), add_path(b, x), add_path(nlca, -x), add_path(dfa[nlca], -x);&#125;inline lint ask_pos(int p) &#123; return bt1.ask(dfn[p], dfr[p]);&#125;inline lint ask_son(int p) &#123; return bt2.ask(dfn[p], dfr[p]) - deep[p] * ask_pos(p);&#125; int main() &#123; readint(n), readint(m), readint(root); for(rint i=1; i&lt;=n; i++) readint(val[i]); int nu, nv; for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs1(root, 0, 1), dfs2(root, root); int ins, a, b, x; while(m--) &#123; readint(ins), readint(a); if(ins == 1) readint(b), readint(x), add_path(a, b, x); else if(ins == 2) printf(\"%lld\\n\", ask_pos(a) + val[a]); else printf(\"%lld\\n\", ask_son(a) + sum[a]); &#125; return 0;&#125; }","categories":[{"name":"LOJ","slug":"LOJ","permalink":"http://arintaro.com/categories/LOJ/"},{"name":"题解","slug":"LOJ/题解","permalink":"http://arintaro.com/categories/LOJ/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"DFS序","slug":"DFS序","permalink":"http://arintaro.com/tags/DFS序/"},{"name":"树上差分","slug":"树上差分","permalink":"http://arintaro.com/tags/树上差分/"}]},{"title":"Luogu秋令营提高组 Round3 T2 表达式求值","slug":"Answer/expr","date":"2019-11-11T08:27:23.300Z","updated":"2019-11-11T08:45:41.936Z","comments":true,"path":"2019/11/11/Answer/expr/","link":"","permalink":"http://arintaro.com/2019/11/11/Answer/expr/","excerpt":"大力讨论","text":"大力讨论 Description:@card{ 给出一个长度为$n$的合法表达式，由数字、加号和括号组成。这个表达式可以通过不断循环右移得到$n$个表达式。求出这$n$个表达式中所有合法表达式的计算结果，输出他们的和。 由于答案可能很大，你只需要输出答案模 $998244353$ 的结果。 $1 \\leq n \\leq 10^5$ } Solution:@card{ 这种模拟题目很重要的一点就是手玩找性质以简化代码，如猪国杀的行为分类，最好能写出一些辅助程序，提高手玩效率。 $30%$的数据: $O(n^2)$ 枚举断点枚举断点，判断串是否合法，计算表达式即可，有30pts。 另外$30%$的数据: 无括号 计算贡献手玩后可以发现，每次中间的贡献会被直接累加，边上的数字会被”分割”成两部分，分别累加两端的贡献即可。 另外，为了方便计算，我们可以循环串，令串的末尾是一个加号。否则前几次计算时，把最前面的数字移到后面可能不会被分割。 $100%$的数据:考试的时候写出来了60pts，认为最后$40$pts是”动态括号匹配”，加上做法二，每次能匹配上时累加贡献，显然不会写。 但是手玩可以发现一个很重要的性质: “括号是假的”，当一对左右括号被分割时，一定不会有合法的情况，所以我们可以直接把表达式中括号的数计算出来转化为做法二。 同时还需要注意几种特殊情况: 没有其余符号，全都是数字 这样上述讨论”分割为两部分”不成立，移到最后面的数字会与之前的数字接在一起，需要特判。 首位或末位是括号 在做法二中，为了方便计算，我们把第一个数字串直接移到了后面，它会与后面的数字接在一起，但是如果首尾是括号的话，就会产生括号与数字连续的奇怪组合，导致串不合法，容易发现，产生这种情况时，只有初始情况是合法的。 代码是考场代码改的，比较丑，后来没有重构。 std的写法是先把+号分割的串提出来，这样后来不用扫来扫去，程序简洁很多。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define int long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int mod = 998244353;int n, m;int sum = 0;int pow10[maxn], val_pre[maxn], val_suf[maxn];int last[maxn];char s[maxn], arr[maxn], temp[maxn];signed main() &#123; pow10[0] = 1; scanf(\"%s\", s); n = strlen(s); for(rint i=1; i&lt;=n; i++) pow10[i] = pow10[i-1] * 10 % mod; if(s[0] == '(' || s[n-1] == ')') &#123; int ans = 0, x = 0; for(rint i=0; i&lt;n; i++) &#123; if(isnum(s[i])) x = (x * 10 + s[i] - '0') % mod; else ans = (ans + x) % mod, x = 0; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; bool all_num = 1; for(rint i=0; i&lt;n; i++) if(!isnum(s[i])) all_num = 0; if(all_num) &#123; val_pre[0] = s[0] - '0'; for(rint i=1; i&lt;n; i++) val_pre[i] = (val_pre[i-1] * 10 + s[i] - '0') % mod; for(rint i=n-1; i&gt;=0; i--) val_suf[i] = (val_suf[i+1] + (s[i] - '0') * pow10[n - 1 - i]) % mod; int ans = val_suf[0]; for(rint i=1; i&lt;n; i++) ans = (ans + val_suf[i] * pow10[i] + val_pre[i - 1]) % mod; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; for(rint i=0; i&lt;n; i++) &#123; if(s[i] != '(') arr[m++] = s[i]; else &#123; rint j = i+1, cnt = 1; lint x = 0; while(cnt &amp;&amp; j &lt; n) &#123; if(isnum(s[j])) &#123; x = (x * 10 + s[j] - '0') % mod; &#125; else &#123; if(s[j] == ')') cnt--; else if(s[j] == '(') cnt++; sum = (sum + x) % mod; x = 0; &#125; j++; &#125; i = j; &#125; &#125; if(arr[m] == '+') m--; arr[m + 1] = '\\0'; n = m; if(n == 0) &#123; cout &lt;&lt; sum &lt;&lt; endl; return 0; &#125; int pos = 0; while(pos &lt; n - 2 &amp;&amp; arr[pos] != '+') pos++; pos++; for(rint i=0; i&lt;n; i++) temp[i] = arr[(pos + i) % n]; for(rint i=0; i&lt;n; i++) arr[i] = temp[i]; for(rint i=0; i&lt;n; i++) &#123; if(isnum(arr[i])) &#123; int j = i, x = 0; for(; isnum(arr[j]); j++) x = (x * 10 + arr[j] - '0') % mod, val_pre[j] = x; last[i] = j - 1; sum = (sum + x) % mod; x = 0; for(rint k=j-1; k&gt;=i; k--) x = (pow10[j - 1 - k] * (arr[k] - '0') + x) % mod, val_suf[k] = x; i = j; &#125; &#125; int ans = 0; for(rint i=0; i&lt;n; i++) &#123; if(isnum(arr[i])) &#123; for(rint j=i; j&lt;=last[i]; j++) &#123; if(j != i) ans = (ans + sum - val_suf[i] + val_pre[j-1] + val_suf[j]) % mod; &#125; i = last[i]; &#125; &#125; printf(\"%lld\\n\", (ans + mod) % mod); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://arintaro.com/tags/模拟/"},{"name":"分类讨论","slug":"分类讨论","permalink":"http://arintaro.com/tags/分类讨论/"},{"name":"毒瘤","slug":"毒瘤","permalink":"http://arintaro.com/tags/毒瘤/"}]},{"title":"R001 魔能阵列","slug":"Answer/segment","date":"2019-11-10T12:49:25.659Z","updated":"2019-11-11T08:27:06.840Z","comments":true,"path":"2019/11/10/Answer/segment/","link":"","permalink":"http://arintaro.com/2019/11/10/Answer/segment/","excerpt":"","text":"Description:@card{ 魔能石是一种神奇的材料，只要向内部注入魔力，其就会产生巨大的热量。 在第$42$代王的带领下，魔法王国建成了极大规模的魔能阵列，以供应全国的能量消耗，在这几乎是无限的能源的加持下，王国飞速发展。但在$45$代王时，魔能石武器实用化，意料之中的，这种武器在$57$代王时，摧毁了整个王国。 具体来说，魔能石阵列可以看成一个长度为$n$的序列，第$i$个魔能石有两个参数，魔力值$x_i$与能量值$e_i$。如果一个魔能石的$x_i &gt; 0$，它就会产生$e_i$的能量，而阵列产生的总能量即为所有魔能石的能量值之和。 王在指挥阵列时，会发布两个指令，一种是令区间$[l, r]$中的魔能石魔力值增加一个整数，当这个整数为正数时，表示向其中注入魔力，为负数时为撤回魔力。当然，魔力值永远不可能低于零，并且在一开始，魔力值均为$0$。另一种是查询区间$[l, r]$的魔能石共计产生了多少能量。 现在，后世的史学家小R找到了$43$代王指挥阵列的记录，希望你求出阵列产生的能量。 输入格式:第一行输入两个整数$n$, $m$，分别表示魔能阵列的长度和王的指令数量。第二行输入$n$个整数，表示每个魔能石的魔力值$e_i$。接下来$m$行，每行$3$到$4$个整数，表示$m$个指令。$1\\ L\\ R\\ x$ 表示令区间$[l, r]$中的魔能石魔力值增加一个整数$x$。$2\\ L\\ R$ 表示查询区间$[l, r]$中的魔能石的产能总量。 输出格式:对于每个$2$指令，输出一行表示答案。 $1 \\leq n \\leq 2 \\times 10^5$$1 \\leq m \\leq 2 \\times 10^5$$1 \\leq x_i \\leq 10000$， $1 \\leq e_i \\leq 10000$ } Solution:@card{ } Code:@card{ 12 }","categories":[{"name":"R","slug":"R","permalink":"http://arintaro.com/categories/R/"},{"name":"题解","slug":"R/题解","permalink":"http://arintaro.com/categories/R/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://arintaro.com/tags/线段树/"}]},{"title":"Luogu秋令营提高组 Round4 T1 灯火将熄","slug":"Answer/light","date":"2019-11-09T07:30:02.131Z","updated":"2019-11-11T08:29:13.221Z","comments":true,"path":"2019/11/09/Answer/light/","link":"","permalink":"http://arintaro.com/2019/11/09/Answer/light/","excerpt":"","text":"Description:@card{ https://www.luogu.org/problem/T108117?contestId=23707 给定一棵树，有$n$个节点，每次可以放一个小队，小队每个单位时间会往上爬一个节点，并覆盖当前到达的节点，求在给定的小队数量$k$下，覆盖所有节点的最短时间。 $1\\leq n \\leq 10^5$，$1 \\leq k \\leq 10^5$ } Solution:@card{ 最优化问题，显然可以二分答案降低难度，问题转化成在给定时间下，覆盖所有节点的最少小队数量。 算法一: 贪心 + 数据结构考试我在想这题应该是”疫情控制”的idea改的，所以我们可以确定几个性质跑贪心之类的。 首先，树上问题，我们可以先确定计算顺序，这个显然可以自下而上的计算。对于叶子节点，其必然需要有一个小队从它出发，所以覆盖这棵树需要的最少小队数量显然就是叶子节点的数量。所以我们考虑先让一些小队从叶子节点出发去覆盖，然后下一步的最优覆盖位置一定是从某个子节点被覆盖，但自己当前还没被覆盖的节点出发，但是可能存在很多个这样的节点，不难想到，从这样的节点中选取树上深度最大去覆盖一定是最优的。 所以我们可以用一个堆去维护这样的节点深度，每次取深度最大的节点向上覆盖即可，同时需要注意一个节点从堆中取出时已经被覆盖就需要continue掉，这实际上是懒惰删除。还会有部分节点被重复覆盖，导致复杂度退化，所以我们还需要用并查集维护每个节点包括它自己向上第一个没被覆盖的节点，这样每跳一次必然有一个节点被覆盖，以此来保证复杂度$O(n\\log^2{n})$，如果用STL的堆，不开O2是难以在1s内跑过所有数据的。 算法二: 树上递推上个解法，我们考虑了”每个小队如何操作”，逆向思维，我们能否考虑”每个节点如何被覆盖”。在上个想法中，我们维护了并查集来避免重复覆盖，类似的想法，我们考虑到达一个节点的小队的步数，显然我们只需要保留步数最大小队的信息，其他小队无论如何是没有它覆盖的多的。 基于上述想法，我们自下而上的计算到达此节点的小队中，剩余步数最多的有多少，每次到达一个节点如果剩余步数为$0$，就增加一个小队，并设其步数为二分出来的答案。 复杂度$O(n\\log{n})$，并且常数较小。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 4e5 + 10;const int maxm = 8e5 + 10;int n, m, k;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;int cnt_in[maxn], cnt_out[maxn];vector&lt;int&gt; ma[maxn];int dfa[maxn], val[maxn];// 存的是反边, 从根下来inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; cnt_in[nu]++, cnt_out[nv]++;&#125;// 每次找深度最大的节点向上跳struct Uset&#123; int fa[maxn]; // 向上第一个没被覆盖的点 inline void init() &#123; for(rint i=0; i&lt;=n; i++) fa[i] = i; &#125; int find(int x) &#123; return fa[x] == x ? fa[x] : fa[x] = find(fa[x]); &#125; // 把x接到y上 inline void unio(int x, int y) &#123; x = find(x), y = find(y); if(x == y) return; fa[x] = y; &#125;&#125;uset;// 到一个点必然花费1单位时间int deep[maxn];void dfs(int x, int d) &#123; deep[x] = d; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) dfs(y, d + 1);&#125;// [2, 3]// 第一维深度，第二维节点编号int arr[maxn], tot;// tot是零入度点priority_queue&lt;pii&gt; q;bool vis[maxn];bool check(int mid) &#123; memset(vis, 0, sizeof(vis)); uset.init(); while(q.size()) q.pop(); int rest_aim = n, rest_point = k; for(rint i=1; i&lt;=tot; i++) q.push(mp(deep[arr[i]], arr[i])); while(!q.empty() &amp;&amp; rest_aim &amp;&amp; rest_point) &#123; pii now = q.top(); q.pop(); int x = now.second, rest_time = mid, y = 0; if(vis[x]) continue; rest_point--; while(true) &#123; y = uset.find(x); rest_time -= deep[x] - deep[y] + 1; if(y == 0 || rest_time &lt; 0) break; vis[y] = 1, rest_aim--; x = dfa[y], uset.unio(y, dfa[y]); &#125; if(y != 0) q.push(mp(deep[y], y)); &#125; return rest_aim &lt;= 0;&#125;int main() &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for(rint i=1; i&lt;=n; i++) scanf(\"%d\", &amp;val[i]); while(m--) &#123; int x, y; scanf(\"%d %d\", &amp;x, &amp;y); ma[x].push_back(y), ma[y].push_back(x); &#125; for(rint x=1; x&lt;=n; x++) &#123; int minpos = 0; // 注意有的节点父亲会是0 for(rint i=0; i&lt;ma[x].size(); i++) &#123; int y = ma[x][i]; if(val[y] &gt; val[x]) continue; if(minpos == 0 || val[y] &lt; val[minpos]) minpos = y; &#125; dfa[x] = minpos; if(minpos != 0) addedge(minpos, x); &#125; for(rint x=1; x&lt;=n; x++) if(cnt_in[x] == 0) arr[++tot] = x; if(tot &gt; k) printf(\"No\\n%d\\n\", tot); else &#123; for(rint x=1; x&lt;=n; x++) if(cnt_out[x] == 0) dfs(x, 1); int l = 1, r = 0; for(rint x=1; x&lt;=n; x++) r = max(r, deep[x]); while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; printf(\"Yes\\n%d\\n\", l); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, m, k;vector&lt;int&gt; ma[maxn];int val[maxn], dfa[maxn];int cnt_in[maxn], now_in[maxn];int dp[maxn];int q[maxn];bool check(int mid) &#123; memset(dp, 0, sizeof(dp)); // 到达i的小队算i最多能走多少个节点 memcpy(now_in, cnt_in, sizeof(cnt_in)); int l = 1, r = 0, res = 0; for(rint x=1; x&lt;=n; x++) if(now_in[x] == 0) q[++r] = x; while(l &lt;= r) &#123; int x = q[l++], y = dfa[x]; if(dp[x] == 0) res++, dp[x] = mid; dp[y] = max(dp[y], dp[x] - 1); if(--now_in[y] == 0) q[++r] = y; &#125; return res &lt;= k;&#125;int main() &#123; readint(n), readint(m), readint(k); for(rint i=1; i&lt;=n; i++) readint(val[i]); int x, y; while(m--) &#123; readint(x), readint(y); ma[x].push_back(y), ma[y].push_back(x); &#125; for(rint x=1; x&lt;=n; x++) &#123; int pos = 0; for(rint i=0; i&lt;ma[x].size(); i++) &#123; int y = ma[x][i]; if(val[y] &gt; val[x]) continue; if(pos == 0 || (pos &amp;&amp; val[y] &lt; val[pos])) pos = y; &#125; if(pos != 0) cnt_in[pos]++, dfa[x] = pos; &#125; int cnt_zero_in = 0; for(rint x=1; x&lt;=n; x++) if(cnt_in[x] == 0) cnt_zero_in++; if(cnt_zero_in &gt; k) printf(\"No\\n%d\\n\", cnt_zero_in); else &#123; int l = 1, r = n; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; printf(\"Yes\\n%d\\n\", l); &#125; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"},{"name":"整体法","slug":"整体法","permalink":"http://arintaro.com/tags/整体法/"}]},{"title":"POJ2762 Going from u to v or from v to u","slug":"Answer/uvuv","date":"2019-11-08T10:24:02.946Z","updated":"2019-11-08T11:05:24.528Z","comments":true,"path":"2019/11/08/Answer/uvuv/","link":"","permalink":"http://arintaro.com/2019/11/08/Answer/uvuv/","excerpt":"","text":"Description:@card{ 给定一个$n$个点$m$条边的有向图，现在要求图中任意两点$u$和$v$，均可满足$u$能通往$v$或$v$能通往$u$，请你判断要求是否能够成立。 $O(n)$ } Solution:@card{ 看一下数据范围，发现$O(nm)$能过，那我们可以打个暴力，并AC本题(雾)。 再看一下数据，多组数据，可能会有毒瘤出题人$n$组数据卡我，那我们缩点以后上个bitset优化一下暴力，并AC本题。缩点后建正反图，做两遍”可达性统计”，最后或起来，考虑每个点是否能到达所有点即可。跑的比部分$O(n)$算法还快。 说正经的，这个问题显然可以缩点变成一个有向无环图上的等价问题，考虑其拓扑序，显然对一个点，它需要能到达所有拓扑序在它后面的节点。 于是我们就有一个结论，一个有向无环图满足题意，当且仅当它有唯一的拓扑序。 如何理解？拓扑序描述了节点之间的”先后关系”，如果一个节点$b$需要在节点$a$之后进行计算，即$b$的拓扑序在$a$之后，那么从$a$出发一定至少有一条路径到$b$。但是我们平时随手写的拓扑排序会出现存在几个节点之间，没有”先后关系”，先计算哪个都无所谓，那么这些节点之间的顺序调换就会产生不同的拓扑序，即这些节点不能互相到达，不满足题意。 具体代码实现可以在bfs时判断是否一次扫描后有多个节点同时入队，虽然我们在tarjan的过程中其实已经求出了一个逆拓扑序。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// bitset优化暴力#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e3 + 10;const int maxm = 100000 + 10;struct Graph&#123; bool vis[maxn]; bitset&lt;maxn&gt; dp[maxn]; int head[maxn], ev[maxm], nxt[maxm], totedge; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; &#125; void clear(int n) &#123; memset(head, 0, sizeof(head)), totedge = 1; for(rint i=1; i&lt;=n; i++) dp[i].reset(); memset(vis, 0, sizeof(vis)); &#125; void dfs(int x) &#123; if(vis[x]) return; vis[x] = 1, dp[x][x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; dfs(y), dp[x] |= dp[y]; &#125; &#125; &#125;g2, g3;namespace G1&#123; int n, m; int head[maxn], ev[maxm], nxt[maxm], totedge = 1; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; &#125; int dcc_id[maxn], totdcc = 0; int low[maxn], dfn[maxn], totdfn = 0; int s[maxn], stop = 0; int cnt_in[maxn], cnt_out[maxn]; void clear() &#123; memset(cnt_in, 0, sizeof(cnt_in)), memset(cnt_out, 0, sizeof(cnt_out)); memset(dfn, 0, sizeof(dfn)), memset(dcc_id, 0, sizeof(dcc_id)); memset(head, 0, sizeof(head)); g2.clear(totdcc), g3.clear(totdcc); totdcc = totdfn = stop = totedge = 0; &#125; void dfs(int x) &#123; low[x] = dfn[x] = ++totdfn, s[++stop] = x; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dfn[y] == 0) dfs(y), low[x] = min(low[x], low[y]); else if(dcc_id[y] == 0) low[x] = min(low[x], dfn[y]); &#125; if(low[x] == dfn[x]) &#123; ++totdcc; do &#123; int z = s[stop]; dcc_id[z] = totdcc; for(rint i=head[z], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dcc_id[y] &amp;&amp; dcc_id[y] != totdcc) &#123; g2.addedge(totdcc, dcc_id[y]), g3.addedge(dcc_id[y], totdcc); cnt_in[dcc_id[y]]++, cnt_out[totdcc]++; &#125; &#125; &#125; while(s[stop--] != x); &#125; &#125; void work() &#123; int T = 0; readint(T); while(T--) &#123; readint(n), readint(m); int nu, nv; while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv); &#125; for(rint x=1; x&lt;=n; x++) if(dfn[x] == 0) dfs(x); int cnt_zero_in = 0, cnt_zero_out = 0; for(rint t=1; t&lt;=totdcc; t++) cnt_zero_in += (cnt_in[t] == 0), cnt_zero_out += (cnt_out[t] == 0); if(cnt_zero_in == 1 &amp;&amp; cnt_zero_out == 1) &#123; g2.dfs(totdcc), g3.dfs(1); bitset&lt;maxn&gt; full; for(rint i=1; i&lt;=totdcc; i++) full[i] = 1; bool failed = 0; for(rint t=1; t&lt;=totdcc; t++) if((g2.dp[t] | g3.dp[t]) != full) &#123; failed = 1; break; &#125; puts(failed ? \"No\" : \"Yes\"); &#125; else puts(\"No\"); clear(); &#125; &#125;&#125;;int main() &#123; G1::work(); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 正解#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int maxm = 6000 + 10;namespace G2&#123; int head[maxn], ev[maxm], nxt[maxm], totedge = 1; int cnt_in[maxn]; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; cnt_in[nv]++; &#125; int q[maxn]; void clear(int n) &#123; memset(head, 0, sizeof(int) * (n + 1)), totedge = 1; memset(cnt_in, 0, sizeof(int) * (n + 1)); &#125; bool check(int n) &#123; int l = 1, r = 0, cnt = 0; for(rint x=1; x&lt;=n; x++) if(cnt_in[x] == 0) cnt++; // 如果图中有多个流图，dcc序不连续 if(cnt &gt; 1) return 0; q[++r] = n; while(l &lt;= r) &#123; int x = q[l++], cnt = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(--cnt_in[y] == 0) q[++r] = y, cnt++; &#125; if(cnt &gt; 1) return 0; &#125; return 1; &#125; &#125;;namespace G1&#123; int n, m; int head[maxn], ev[maxm], nxt[maxm], totedge = 1; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; &#125; int dcc_id[maxn], totdcc = 0; int dfn[maxn], low[maxn], totdfn = 0; int s[maxn], stop = 0; void clear() &#123; memset(head, 0, sizeof(int) * (n + 1)); memset(dcc_id, 0, sizeof(int) * (n + 1)); memset(dfn, 0, sizeof(int) * (n + 1)); G2::clear(totdcc); totdcc = totdfn = totedge = stop = 0; &#125; void dfs(int x) &#123; dfn[x] = low[x] = ++totdfn, s[++stop] = x; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dfn[y] == 0) dfs(y), low[x] = min(low[x], low[y]); else if(dcc_id[y] == 0) low[x] = min(low[x], dfn[y]); &#125; if(low[x] == dfn[x]) &#123; ++totdcc; do &#123; int z = s[stop]; dcc_id[z] = totdcc; for(rint i=head[z], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dcc_id[y] &amp;&amp; dcc_id[y] != totdcc) G2::addedge(totdcc, dcc_id[y]); &#125; &#125; while(s[stop--] != x); &#125; &#125; void work() &#123; int T = 0; readint(T); while(T--) &#123; readint(n), readint(m); int nu, nv; while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv); &#125; for(rint x=1; x&lt;=n; x++) if(dfn[x] == 0) dfs(x); puts(G2::check(totdcc) ? \"Yes\" : \"No\"); clear(); &#125; &#125; &#125;;int main() &#123; G1::work(); return 0;&#125; }","categories":[{"name":"POJ","slug":"POJ","permalink":"http://arintaro.com/categories/POJ/"},{"name":"题解","slug":"POJ/题解","permalink":"http://arintaro.com/categories/POJ/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"结论","slug":"结论","permalink":"http://arintaro.com/tags/结论/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://arintaro.com/tags/拓扑排序/"},{"name":"强联通分量","slug":"强联通分量","permalink":"http://arintaro.com/tags/强联通分量/"}]},{"title":"BZOJ3033 太鼓达人","slug":"Answer/drum","date":"2019-11-08T05:38:55.275Z","updated":"2019-11-10T03:25:40.656Z","comments":true,"path":"2019/11/08/Answer/drum/","link":"","permalink":"http://arintaro.com/2019/11/08/Answer/drum/","excerpt":"神奇的题目","text":"神奇的题目 Description:@card{ 太鼓达人的鼓坏了，现在vani来修鼓。 鼓的主要元件是$m$个围成一圈的传感器。 每个传感器都有开和关两种工作状态，分别用$1$和$0$表示。 显然，从不同的位置出发沿顺时针方向连续检查$k$个传感器可以得到$m$个长度为$k$的$01$串。 Vani 知道这$m$个$01$串应该是互不相同的。 而且鼓的设计很精密, $m$会取到可能的最大值。 现在 Vani 已经了解到了$k$的值，他希望你求出$m$的值，并给出字典序最小的传感器排布方案。 $1 \\leq k \\leq 11$ } Solution:@card{ 这个题直接做显然是没法做的，后效性太强，不容易进行动态规划，又没什么好的贪心思路，或许有神牛可以直接构造？ 先观察样例，发现就是$2^3=8$，仔细想想$m$的上界就是$2^k$，能否构造出一种方案的长度为$2^k$呢？题目还要求字典序最小，显然把全是0的那个子串放在最前面最小，然后考虑什么串可以接在它后面？ 想了想发现十分不可做，不过接在它后面这个关系可以用图论建模描述，我们把$2^k$个串作为图中的节点，能接在其后面的连有向边，仔细思考可以发现，一个点只会连两条出边和两条入边(全是0和全是1会形成自环)，我们要求出的最优解其实就是图中的最大环，这其实就是要求哈密顿环，在一般图上是NP-hard的。 不重不漏的经过所有的点难以做到，所以我们可以把信息放在边上，即点是”长度为$m-1$的$01$串”，而边是”长度为$m$的$01$串”，按照上述方式建图后，每个点也只会连两条出边和两条入边，存在欧拉回路，所以我们可以直接求出方案。 另外吐槽一下网上的题解的代码实现大多是求”最大环”的那种，即dfs到一个点打一个vis标记，之后不重复访问，虽然从本题出发得到的结果是对的，但是推导的过程却是错误的。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline bool readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f; return x != 0;&#125;using namespace std;const int maxn = 12;const int maxm = 1 &lt;&lt; maxn;const int maxedge = 4 * maxm;int n, m, t;int head[maxm], ev[maxedge], nxt[maxedge], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int s[maxm], stop = 0;void dfs(int x) &#123; while(head[x]) &#123; int y = ev[head[x]]; head[x] = nxt[head[x]]; dfs(y); &#125; s[++stop] = x;&#125;int main() &#123; readint(n); int t = (1 &lt;&lt; (n - 1)) - 1; for(rint i=0; i&lt;(1 &lt;&lt; (n - 1)); i++) &#123; addedge(i, ((i &lt;&lt; 1) &amp; t) | 1); addedge(i, (i &lt;&lt; 1) &amp; t); &#125; dfs(0); printf(\"%d \", 1 &lt;&lt; n); while(stop &gt; 1) putchar((s[stop--] &gt;&gt; (n - 2)) + '0'); puts(\"\"); return 0;&#125; }","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://arintaro.com/categories/BZOJ/"},{"name":"题解","slug":"BZOJ/题解","permalink":"http://arintaro.com/categories/BZOJ/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"构造","slug":"构造","permalink":"http://arintaro.com/tags/构造/"},{"name":"结论","slug":"结论","permalink":"http://arintaro.com/tags/结论/"}]},{"title":"POJ1275 Cashier Employment","slug":"Answer/cashier","date":"2019-11-07T06:17:51.737Z","updated":"2019-11-07T06:58:30.316Z","comments":true,"path":"2019/11/07/Answer/cashier/","link":"","permalink":"http://arintaro.com/2019/11/07/Answer/cashier/","excerpt":"难以建模","text":"难以建模 Description:@card{ 一家超市要每天$24$小时营业，为了满足营业需求，需要雇佣一大批收银员。 已知不同时间段需要的收银员数量不同，为了能够雇佣尽可能少的人员，从而减少成本，这家超市的经理请你来帮忙出谋划策。 经理为你提供了一个各个时间段收银员最小需求数量的清单$R(0),R(1),R(2),…,R(23)$。 $R(0)$表示午夜到凌晨一点的最小需求数量，$R(1)$表示凌晨一点到凌晨两点的最小需求数量，以此类推。 一共有$n$个合格的申请人申请岗位，第$i$个申请人可以从$t_i$开始连续工作$8$小时。 收银员之间不存在替换，一定会完整的工作$8$小时，收银台的数量一定足够。 现在给定你收银员的需求清单，请你计算最少需要雇佣多少名收银员。 } Solution:@card{ 先考虑贪心，显然对一个选完的前缀接下来选能选的向后扩展最长的收银员最好，但是这个问题是一个”环形”问题，由于可能不存在常规环形问题的”断点”，是没法直接转换成序列上的问题的。 常规的思路是在一个中间局面考虑某个收银员是否选择，但差分约束的思路是求出一组解，再考虑现在的收银员能否满足这组解，有点像”生成-验证”的暴力？ 有了这个思路就好办了，我们可以先对需要最优化的值求前缀和，再应用差分约束，具体到这个问题上就是某个前缀雇佣了多少收银员，然后对每个时间去计算”当前在工作的收银员的上班时间”，同时注意环形性质即可，具体计算可以设元解不等式。 方便起见，下面的方程下标均加了一。 具体写出方程后，发现有一个方程是$dist[24] - dist[i + 16] + dist[i] \\geq arr[i]$，有三个变量，无法应用差分约束，但是对于一个确定的$i$，其中只有两项是”动态的”，所以我们考虑枚举$dist[24]$，验证是否存在解即可，注意$dist[24]$其实就是答案，而它显然具有单调性，换成二分答案时间上会更优。 具体实现上，与常规的差分约束不同，我们有了一个已知的”定值”，如何应用这个条件呢？ 不额外加边，直接初始化$dist[24] = mid$，并用其作源点跑最长路。这是一个错误的想法，因为差分约束维护的不是具体的值，而是元素之间的差，这使得所有元素加上一个任意值，图中的不等式也都是成立的。跑完最长路后，图中的$dist$值的确满足我们设下的限制关系，并且$dist[24]$也一定不会改变，否则图中存在正环，无解，但是求出的解可能会没有实际意义，因为$dist[0]$可能不等于0。 不额外加边，直接初始化$dist[0] = 0$，$dist[24] = mid$，并直接入队两个点跑最长路。这也是一个错误的想法，因为初始化两个源点的值，而不将他们的值设成$-inf$，即使在没有正环的情况下，两个源点中的一个也可能会被另外一个更新，导致与初始化的条件不符。 额外加边$dist[24] \\geq mid$，$dist[24] \\leq mid$，并初始化$dist[0] = 0$作为源点跑最长路。这是正确的，这样显然可以保证$dist[24] = mid$，并且$dist[0]$的值不会被意外更新。如果被更新，图中一定存在正环，无解。在其他差分约束问题中，还要注意源点是否能遍历全图，如果图中不存在负环/正环，被扫描过的边代表的限制条件是一定成立的，但是图也可能是不联通的，此时需要设计超级源点，尽量不要一次入队全部节点，这样初值的设计非常麻烦。 额外加边，随便初始化一个点，随便初始化一个大于$-inf$的值。这也是正确的，只要保证初始化的这个点能够遍历全图，这是差分约束系统”差分性质”的更好体现，我们额外加的边约束了$0$与$24$的关系，求出一组解后，只要把这组解的值全部减去$dist[0]$，一定能对应一组有实际意义的解。 在一般问题中，我们一般采用做法3，对于已知的常量，不初始化维护，而通过与”基点”的两个不等式去维护。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 24 + 10;const int maxm = 1000 + 10;int n = 24, m;int arr[maxn], cnt[maxn], sum_cnt = 0;int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;void clear() &#123; memset(arr, 0 ,sizeof(arr)), memset(cnt, 0, sizeof(cnt)); sum_cnt = 0;&#125;int dist[maxn], cnt_path[maxn];bool inq[maxn];queue&lt;int&gt; q;bool check(int x) &#123; memset(inq, 0, sizeof(inq)); memset(cnt_path, 0, sizeof(cnt_path)); memset(head, 0, sizeof(head)), totedge = 1; memset(dist, 0xcf, sizeof(dist)); dist[0] = 0; for(rint k=1; k&lt;=7; k++) addedge(k + 16, k, arr[k] - x); for(rint k=8; k&lt;=24; k++) addedge(k - 8, k, arr[k]); for(rint k=1; k&lt;=24; k++) addedge(k, k-1, -cnt[k]), addedge(k-1, k, 0); addedge(0, 24, x), addedge(24, 0, -x); while(q.size()) q.pop(); q.push(0), inq[0] = 1; while(!q.empty()) &#123; int x = q.front(); q.pop(), inq[x] = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &lt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; cnt_path[y] = cnt_path[x] + 1; if(cnt_path[y] &gt; n + 1) return 0; if(inq[y] == 0) inq[y] = 1, q.push(y); &#125; &#125; &#125; return 1;&#125;int main() &#123; int T; readint(T); while(T--) &#123; clear(); for(rint i=1; i&lt;=n; i++) readint(arr[i]); readint(m); int x = 0; for(rint i=1; i&lt;=m; i++) readint(x), cnt[x + 1]++; int l = 0, r = m + 1; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; &#125; if(l == m + 1) puts(\"No Solution\"); else printf(\"%d\\n\", l); &#125; return 0;&#125; }","categories":[{"name":"POJ","slug":"POJ","permalink":"http://arintaro.com/categories/POJ/"},{"name":"题解","slug":"POJ/题解","permalink":"http://arintaro.com/categories/POJ/题解/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"},{"name":"差分约束","slug":"差分约束","permalink":"http://arintaro.com/tags/差分约束/"}]},{"title":"双联通分量","slug":"Template/图论/双联通分量","date":"2019-11-06T05:08:25.345Z","updated":"2019-11-08T12:46:18.263Z","comments":true,"path":"2019/11/06/Template/图论/双联通分量/","link":"","permalink":"http://arintaro.com/2019/11/06/Template/图论/双联通分量/","excerpt":"换种写法。","text":"换种写法。 一、点双联通分量@card { 需要特判两个地方，第一个是根节点，第二个是孤立点。 由于特判的地方比较多，点双联通分量就不要写边tarjan边缩点了，非常容易写错 123456789101112131415161718void dfs(int x, int fa) &#123; dfn[x] = low[x] = ++totdfn, s[++stop] = x; if(head[x] == 0) ++totdcc, dcc[totdcc].push_back(x); // 特判孤立点 for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dfn[y] == 0) dfs(y, x), low[x] = min(low[x], low[y]); else low[x] = min(low[x], dfn[y]); &#125; if(fa &amp;&amp; low[x] &gt;= dfn[fa]) &#123; // 根节点不需要 ++totdcc, cut[fa]++; do dcc[totdcc].push_back(s[stop]); while(s[stop--] != x); dcc[totdcc].push_back(fa); &#125; if(fa == 0) cut[x] = cut[x] &gt;= 2 ? cut[x] : 0; // 特判根节点&#125;for(rint i=1; i&lt;=n; i++) if(dfn[i] == 0) dfs(i, 0);// 只要遇到一个dfn[i]==0，一定产生了一个新的联通块 } 二、边双联通分量注意，点双联通分量是比边双联通分量更强的条件， 这样的结构会被判断成同一个边双联通分量，而不是一个点双联通分量。 avatar 12345678910111213141516171819202122232425// POJ3694 Networkvoid dfs(int x, int in_edge) &#123; dfn[x] = low[x] = ++totdfn, s[++stop] = x; // 入栈，给编号 for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == (in_edge ^ 1)) continue; // 这里为了判定重边 if(dfn[y] == 0) dfs(y, i), low[x] = min(low[x], low[y]); else low[x] = min(low[x], dfn[y]); &#125; // 常规的割边判定法则是对于一个节点，它某个子节点回不到它和更早遍历的到的节点，此时这条边就是割边 // 我们这里回溯时判定，可以直接类似强联通分量的low[x] == dfn[x]，因为无向图搜索树上显然没有横插边，不可能更新到一个节点它的dfs序比这个节点小，且比它的父节点大。 // 边双联通分量递归时判断必须在结束后清空栈，点双联通分量结束后会仅剩根节点，无需清空 if(low[x] == dfn[x]) &#123; // 注意这里与点双不同 ++totdcc; do &#123; int z = s[stop]; dcc_id[z] = totdcc; for(rint i=head[z], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; // 先取出的一定是缩点后构成的树上深度较大的dcc，因此可以直接边遍历边加边 // 当dcc_id[y] == 0时，它可能是其缩点后的树的父dcc中的节点，也可能是在同一个dcc还没出栈的节点 // 当dcc_id存在，并且不等于当前的dcc编号，它一定是当前dcc树上的子节点。 if(dcc_id[y] &amp;&amp; dcc_id[y] != totdcc) G2::addedge(totdcc, dcc_id[y]); // 加边时如果需要去重可以对个dcc开个桶，结束后还原防止复杂度退化 &#125; &#125; while(s[stop--] != x); &#125; &#125;","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"连通性问题","slug":"连通性问题","permalink":"http://arintaro.com/tags/连通性问题/"}]},{"title":"基于原始对偶方法的Dijkstra-Dinic","slug":"Template/图论/费用流","date":"2019-11-06T04:33:48.657Z","updated":"2019-11-06T05:08:12.462Z","comments":true,"path":"2019/11/06/Template/图论/费用流/","link":"","permalink":"http://arintaro.com/2019/11/06/Template/图论/费用流/","excerpt":"然而复杂度都是不对的。","text":"然而复杂度都是不对的。 一、概述@card{ OI中费用流一般用消圈orSSP，复杂度在边权较大时都是不对的，但是出题人一般不卡，在这种环境下写对的某个算法反而会被卡，所以我选择用Dijkstra跑Dinic，平均表现还是比较优秀的，但是在原图上就有负权回路的图上没法正确求出答案。 由于dinic更新边时一定会产生负权边，导致无法直接应用dijkstra，只能不停地跑SPFA，如果设计一个势函数，使得边权变正，那么就能用Dijkstra跑了。 一个错误的想法就是把每条边都加上inf，这显然会导致加完后的最短路和原来的最短路不同，考虑物理中”势能”的想法，我们定义新的边权$$w_{u,v}’ = w_{u,v} + h(u) - h(v)$$这样相加后中间的项显然都会消去，对于一个最短路$dist_{u, v}’ = dist_{u, v}’ + h(u) - h(v)$，对于给定的源点和起点后面两项都是常数，所以最短路肯定是不变的。 问题现在在于如何设计一个$h(x)$，满足对于所有的边都满足$w_{u,v} + h(u) - h(v) \\geq 0$，类似差分约束的想法，这个可以与三角不等式联系到一起，显然我们有$dist_u + w_{u,v} \\geq dist_v$，整理可得类似上面的形式，所以我们直接令$h(x) = dist_x$。 然而还有一个问题，我们每次会动态更新边权，而我们显然不能每次都再跑一遍SPFA求出$dist$数组就为了重标号跑Dijkstra再求一遍$dist$数组，所以我们需要一个可以快速更新$h(x)$的方法。 在这次跑完最短路上的图上每条边均满足$dist_u + w_{u,v} + h(u) - h(v) \\geq dist_v$，变形得$w_{u, v} + (h(u) + dist_u) - (h(v) + dist_v) \\geq 0$。 如果这条边没被更新，显然上式仍成立。 如果这条边被更新了，一定有$w_{u, v} + (h(u) + dist_u) - (dist_v + h(v)) = 0$成立，这条边更新出的绝对值最大的负边权为$-w_{u, v}$，左右两边乘个负号，即得到$-w_{u, v} + (dist_v + h(v)) - (dist_u + h(u)) = 0$，因为$-w_{u, v}$绝对值是最大的，所以$w_{v, u}’ + (dist_v + h(v)) - (dist_u + h(u)) \\geq 0$。 由上述的推导可以看出，我们可以每次跑完后规定$h’(x) = h(x) + dist_x$，这样新图上的边权也一定非负。 } 二、代码@card{123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5000 + 10;const int maxm = 2e5 + 10;const int inf = 0x3f3f3f3f;int n, m, st, ed;int cur[maxn];int head[maxn], ev[maxm], ew[maxm], ec[maxm], nxt[maxm], totedge = 1;inline void addedge_one(int nu, int nv, int nw, int nc) &#123; // 注意这里分清nw, nc ev[++totedge] = nv, ew[totedge] = nw, ec[totedge] = nc; nxt[totedge] = head[nu], head[nu] = totedge;&#125;inline void addedge_two(int nu, int nv, int nw, int nc) &#123; // 别忘了加反边 addedge_one(nu, nv, nw, nc), addedge_one(nv, nu, 0, -nc);&#125;// 第一维距离，第二维编号priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;lint h[maxn], dist[maxn];bool dijkstra() &#123; memset(dist, 0x3f, sizeof(dist)); dist[st] = 0, q.push(mp(0, st)); while(!q.empty()) &#123; pii now = q.top(); q.pop(); int x = now.second; if(now.first &gt; dist[x]) continue; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(ew[i] &amp;&amp; dist[y] &gt; dist[x] + ec[i] + h[x] - h[y]) &#123; // 这里记得判此边是否还有容量 dist[y] = dist[x] + ec[i] + h[x] - h[y]; q.push(mp(dist[y], y)); &#125; &#125; &#125; return dist[ed] &lt; inf;&#125;int maxflow = 0, mincost = 0;bool vis[maxn];int dinic(int x, int rest) &#123; if(x == ed || rest == 0) return rest; vis[x] = 1; // 一般的正权图跑最短路生成DAG时不用这样，但此题中可能有\"零环\" int flow = 0; for(rint &amp;i = cur[x], y=ev[i]; i &amp;&amp; rest; i=nxt[i], y=ev[i]) &#123; // 当前弧优化, &amp;&amp;rest 及时退出 if(ew[i] == 0 || vis[y] || dist[y] != dist[x] + ec[i] + h[x] - h[y]) continue; // 记得判边是否还有容量，以及为了避免无限递归零环而打的入栈标记。 // 最短路生成DAG int now = dinic(y, min(ew[i], rest)); flow += now, rest -= now; ew[i] -= now, ew[i ^ 1] += now; // 实时更新剩余容量 &#125; vis[x] = 0; // 回溯时还原标记，一个点可能会被多次访问 return flow;&#125;int main() &#123; readint(n), readint(m), readint(st), readint(ed); int nu, nv, nw, nc; while(m--) &#123; readint(nu), readint(nv), readint(nw), readint(nc); addedge_two(nu, nv, nw, nc); &#125; while(dijkstra()) &#123; memcpy(cur, head, sizeof(cur)); // 当前弧优化 int flow = 0; // 一次多路增光，降低常数 while((flow = dinic(st, INT_MAX))) maxflow += flow, mincost += flow * (dist[ed] - h[st] + h[ed]); for(rint i=1; i&lt;=n; i++) h[i] += dist[i]; // 更新势能函数 &#125; printf(\"%d %d\\n\", maxflow, mincost); return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://arintaro.com/tags/网络流/"}]},{"title":"POJ3694 Network","slug":"Answer/bridge","date":"2019-11-05T13:33:10.949Z","updated":"2019-11-05T13:57:50.930Z","comments":true,"path":"2019/11/05/Answer/bridge/","link":"","permalink":"http://arintaro.com/2019/11/05/Answer/bridge/","excerpt":"难写","text":"难写 Description:@card{ 给定一张$n$个点$m$条边的无向连通图，然后执行$q$次操作，每次向图中添加一条边，并且询问当前无向图中“桥”的数量。$1 \\leq n \\leq 100000$，$N-1 \\leq m \\leq 200000$，$1 \\leq Q \\leq 1000$， } Solution:@card{ lyd书上讲过的题。 显然需要缩点后变成一棵树，加边其实就是在树上覆盖一条路径，使其边权均变为0，用树链剖分+线段树可以直接解决，但是代码和时间均不优。 由于本题中只有”一边倒”的操作，就是只有把边权1变成0的操作，我们可以用并查集维护01序列，每次只要直接跳到它前面最近的1暴力修改即可。其实就是把这个东西放在了树上，对应实际含义可以是每次跳到向上第一个还没删的边。 另外，双联通分量可以直接在回溯时求出，使得代码更加简洁。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int maxm = 4 * maxn;namespace G2&#123; int n, ans = 0; int head[maxn], ev[maxm], nxt[maxm], totedge = 1; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; &#125; int fa[maxn]; int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125; int dfa[maxn], size[maxn], deep[maxn]; int wson[maxn], wtop[maxn]; void dfs1(int x, int fa, int d) &#123; dfa[x] = fa, size[x] = 1, deep[x] = d; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, x, d + 1), size[x] += size[y]; if(size[y] &gt; size[wson[x]]) wson[x] = y; &#125; &#125; void dfs2(int x, int top) &#123; wtop[x] = top; if(wson[x]) dfs2(wson[x], top); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == dfa[x] || y == wson[x]) continue; dfs2(y, y); &#125; &#125; int lca(int x, int y) &#123; while(wtop[x] != wtop[y]) &#123; if(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y); x = dfa[wtop[x]]; &#125; return deep[x] &lt; deep[y] ? x : y; &#125; void clear() &#123; int msize = sizeof(int) * (n + 1); memset(size, 0, msize), memset(wson, 0, msize); memset(head, 0, msize), totedge = 1; &#125; void init(int size) &#123; n = size, ans = n - 1; dfs1(n, 0, 1), dfs2(n, n); for(rint i=1; i&lt;=n; i++) fa[i] = i; &#125; // 向上跳到第一个上边权不为0的点, 并查集维护01序列 void jump(int x, int aim) &#123; while(true) &#123; x = find(x); if(deep[dfa[x]] &gt;= deep[aim]) &#123; fa[x] = fa[dfa[x]]; x = dfa[x], ans--; &#125; else break; &#125; &#125; int ask(int x, int y) &#123; int nlca = lca(x, y); jump(x, nlca), jump(y, nlca); return ans; &#125; &#125;;namespace G1&#123; int n, m; int head[maxn], ev[maxm], nxt[maxm], totedge = 1; inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; &#125; int dfn[maxn], low[maxn], totdfn = 0; int dcc_id[maxn], totdcc = 0; int s[maxn], stop = 0; void clear() &#123; stop = totdcc = totdfn = 0, totedge = 1; int msize = sizeof(int) * (n + 1); memset(dcc_id, 0, msize), memset(dfn, 0, msize); memset(low, 0, msize), memset(head, 0, msize); G2::clear(); &#125; void dfs(int x, int in_edge) &#123; dfn[x] = low[x] = ++totdfn, s[++stop] = x; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == (in_edge ^ 1)) continue; if(dfn[y] == 0) dfs(y, i), low[x] = min(low[x], low[y]); else low[x] = min(low[x], dfn[y]); &#125; // 割边 if(low[x] == dfn[x]) &#123; ++totdcc; do &#123; int z = s[stop]; dcc_id[z] = totdcc; for(rint i=head[z], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dcc_id[y] &amp;&amp; dcc_id[y] != totdcc) G2::addedge(totdcc, dcc_id[y]); &#125; &#125; while(s[stop--] != x); &#125; &#125; void work() &#123; int T = 0; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m)) &#123; printf(\"Case %d:\\n\", ++T); int nu, nv; while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(1, 0); G2::init(totdcc); readint(m); while(m--) &#123; readint(nu), readint(nv); printf(\"%d\\n\", G2::ask(dcc_id[nu], dcc_id[nv])); &#125; puts(\"\"); clear(); &#125; &#125;&#125;;int main() &#123; G1::work(); return 0;&#125; }","categories":[{"name":"POJ","slug":"POJ","permalink":"http://arintaro.com/categories/POJ/"},{"name":"题解","slug":"POJ/题解","permalink":"http://arintaro.com/categories/POJ/题解/"}],"tags":[{"name":"双联通分量","slug":"双联通分量","permalink":"http://arintaro.com/tags/双联通分量/"},{"name":"并查集","slug":"并查集","permalink":"http://arintaro.com/tags/并查集/"}]},{"title":"POI2008 BLO-Blockade","slug":"Answer/blo","date":"2019-11-05T11:02:31.302Z","updated":"2019-11-05T11:11:46.014Z","comments":true,"path":"2019/11/05/Answer/blo/","link":"","permalink":"http://arintaro.com/2019/11/05/Answer/blo/","excerpt":"换个思路，统计贡献","text":"换个思路，统计贡献 Description:@card{ 给定一张无向图，求每个点被封锁之后有多少个有序点对$(x,y)$满足$x$无法到达$y$。 $1 \\leq n \\leq 100000$，$1 \\leq m \\leq 500000$ } Solution:@card{ 无向图连通性问题，在一棵生成树上考虑。 如果$x$对于它某棵子树是割点的话，显然这棵子树在断开连向$x$的所有边后会与外界隔绝，每个点会与除在这棵子树中的所有点构成一个点对。 断开$x$的所有边后，除了这些子树，图中还剩联通的一部分和$x$自己，这其中每一块都会产生类似的贡献，我们不妨对每个块考虑，强制令这个块中的点为第一维，显然当一块中的点数为$size$时，其会产生$size \\times (n - size)$的贡献。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int maxm = 1e6 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;lint ans[maxn];int dfn[maxn], low[maxn], totdfn = 0;int size[maxn];// 记得处理重边, 特判搜索树根节点void dfs(int x, int in_edge) &#123; int cnt = 1; dfn[x] = low[x] = ++totdfn, size[x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == (in_edge ^ 1)) continue; if(dfn[y] == 0) &#123; dfs(y, i), size[x] += size[y], low[x] = min(low[x], low[y]); if(low[y] &gt;= dfn[x]) ans[x] += (lint)size[y] * (n - size[y]), cnt += size[y]; &#125; else low[x] = min(low[x], dfn[y]); &#125; ans[x] += n - 1 + (lint)cnt * (n - cnt);&#125;int main() &#123; readint(n), readint(m); int nu, nv; while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(1, 0); for(rint i=1; i&lt;=n; i++) printf(\"%lld\\n\", ans[i]); return 0;&#125; }","categories":[{"name":"POI","slug":"POI","permalink":"http://arintaro.com/categories/POI/"},{"name":"题解","slug":"POI/题解","permalink":"http://arintaro.com/categories/POI/题解/"}],"tags":[{"name":"双连通分量","slug":"双连通分量","permalink":"http://arintaro.com/tags/双连通分量/"},{"name":"计数问题","slug":"计数问题","permalink":"http://arintaro.com/tags/计数问题/"}]},{"title":"Luogu P3994 高速公路","slug":"Answer/highway","date":"2019-11-04T08:33:32.739Z","updated":"2019-11-04T08:45:12.464Z","comments":true,"path":"2019/11/04/Answer/highway/","link":"","permalink":"http://arintaro.com/2019/11/04/Answer/highway/","excerpt":"复杂度很容易写假，但是数据没卡","text":"复杂度很容易写假，但是数据没卡 Description:@card{ 核心idea要求对树上的每一个节点维护到根路径上的单调队列，就是遍历到这点时，单调队列必须只考虑了它到根节点路径上的所有点，外层套了一个斜率优化的壳。 $1 \\leq n \\leq 10^6$ } Solution:@card{ 显然的做法是按序遍历，回溯时撤销影响。 说起撤销，第一时间想的肯定是可持久化数据结构，但是复杂度要多个$\\log$，仔细想想撤销影响并不是瓶颈，我们每次没必要遍历队列中的所有元素，只需要还原这次更改的元素即可，所以还原的最差复杂度肯定是与这次更改同级的，进一步思考，我们只改了两个指针，覆盖操作只针对入队的一个元素，所以只还原这三样，还原复杂度是$O(1)的$。 想到这里，我写了第一个程序，交上去并AC了。 然而看了题解发现复杂度不对，对于一个祖先节点，它会在下面孩子的不同子树多次被出队，如果构造一个链套菊花就会被卡掉，然而这种数据是很难造的，因为外层斜率优化的壳，出题人是没法很简单的造出这种数据给我卡掉的，必须针对边权设计，或者直接random跑很久跑出一组数据。 正确的做法是每次二分或倍增的出队入队，常规的单调队列虽然一次可能出队入队很多元素，但由于元素数量限制，会被均摊掉，就算应用了二分/倍增带来的只是常数上的提升，但是这次一个元素会多次入队，均摊不掉，很可能会变成$O(n^2)$所以我们需要快速的进行入队/入队操作，发现其实就是在一个有序序列中找满足条件的位置，可以直接用二分或倍增解决。我比较喜欢写倍增，常数小，代码短。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;inline int mlog2(lint x) &#123; if(x == 1) return 0; double t = x; return (int)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1;&#125;using namespace std;const int maxn = 1e6 + 10;const int maxm = 2 * maxn;int n, root = 1;int a[maxn], b[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;// dp[i] = min&#123;dp[j] + a[i] * (dist[i] - dist[j]) + b[i]&#125;// dp[i] = dp[j] + a[i] * dist[i] - a[i] * dist[j] + b[i]// dp[j] = a[i] * dist[j] + dp[i] - a[i] * dist[i] - b[i]// (dist[j], dp[j])// 每次在最右边出现，求截距最小值// 维护斜率单调递增，每次找第一个斜率大于它线段的左端点// 保证要找的斜率单调递增，小于等于它的直接出队int q[maxn];int l = 1, r = 0;lint dist[maxn], dp[maxn];double calc(int i, int j) &#123; return (double)(dp[i] - dp[j]) / (dist[i] - dist[j]);&#125;void dfs(int x) &#123; int ml = l, mr = r, mem = 0; for(rint t=mlog2(r - l + 1); t&gt;=0; t--) &#123; int len = 1 &lt;&lt; t; if(l + len - 1 &lt; r &amp;&amp; calc(q[l + len - 1], q[l + len]) &lt;= a[x]) l += len; &#125; dp[x] = dp[q[l]] + a[x] * (dist[x] - dist[q[l]]) + b[x]; for(rint t=mlog2(r - l + 1); t&gt;=0; t--) &#123; int len = 1 &lt;&lt; t; if(r - len + 1 &gt; l &amp;&amp; calc(q[r - len + 1], q[r - len]) &gt;= calc(q[r - len + 1], x)) r -= len; &#125; mem = q[r+1], q[++r] = x; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; dist[y] = dist[x] + ew[i]; dfs(y); &#125; q[r] = mem, l = ml, r = mr;&#125;int main() &#123; readint(n); for(rint x=2, y, w; x&lt;=n; x++) &#123; readint(y), readint(w), readint(a[x]), readint(b[x]); addedge(y, x, w); &#125; dfs(root); for(rint i=2; i&lt;=n; i++) printf(\"%lld\\n\", dp[i]); return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"斜率优化","slug":"斜率优化","permalink":"http://arintaro.com/tags/斜率优化/"},{"name":"倍增","slug":"倍增","permalink":"http://arintaro.com/tags/倍增/"}]},{"title":"POI2008 KUP-Plot purchase","slug":"Answer/kup","date":"2019-11-03T22:43:54.440Z","updated":"2019-11-03T22:56:01.282Z","comments":true,"path":"2019/11/04/Answer/kup/","link":"","permalink":"http://arintaro.com/2019/11/04/Answer/kup/","excerpt":"强行与牛有关","text":"强行与牛有关 Description:@card{ 给定$k$, $n$,和$n \\times n$的矩阵，求一个子矩形满足权值和在$[k, 2k]$之间 $1 \\leq n \\leq 2000$, $1 \\leq k \\leq 10^9$ } Solution:@card{ 直接做显然没法做，但大部分情况下，可以感觉出”答案空间很大”，考虑能否讨论+构造。 首先考虑如何骗分，假设存在某个格子的权值正好符合$[k, 2k]$，那么直接输出即可。如果某个格子的权值$x \\geq 2k$，那么它显然不能选，是个”障碍点”。 那么剩下的格子的权值$x \\leq k$，考虑一个个格子选，无论怎么选都无法”跳过”$[k, 2k]$这个区间，所以一旦某个矩形，满足格子权值都小于等于$k$，的总权值大于等于$k$，那么我们一定能通过拆分这个矩形构造出一组解。这样的子矩形我们显然可以把大于等于$2k$的点设为障碍点，然后跑最大子矩形。 与Cow Rectangles那题很像，都是先”极大化”，再考虑如何缩小拆分组成答案。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define gb(x, i) (((x) &gt;&gt; (i)) &amp; 1)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 21;const int maxm = 1000 + 10;int n, m, aim;int dp[1 &lt;&lt; maxn];// 0-indexvector&lt;int&gt; arr[maxn];int len[maxn];int ans = maxn;int main() &#123; readint(n), readint(aim); for(rint i=0; i&lt;n; i++) &#123; int x = 0; readint(len[i]), readint(m); for(rint j=0; j&lt;m; j++) &#123; readint(x), arr[i].push_back(x); &#125; &#125; for(rint s=0; s&lt;(1&lt;&lt;n); s++) &#123; int cnt = 0; for(rint i=0; i&lt;n; i++) &#123; if((s &gt;&gt; i) &amp; 1) &#123; cnt++; continue; &#125; // 找最后一个小于等于dp[s]的数 int p = upper_bound(arr[i].begin(), arr[i].end(), dp[s]) - arr[i].begin(); if(p == 0) continue; dp[s | (1 &lt;&lt; i)] = max(dp[s | (1 &lt;&lt; i)], arr[i][p-1] + len[i]); &#125; if(dp[s] &gt;= aim) ans = min(ans, cnt); &#125; printf(\"%d\\n\", ans == maxn ? -1 : ans); return 0;&#125; }","categories":[{"name":"POI","slug":"POI","permalink":"http://arintaro.com/categories/POI/"},{"name":"题解","slug":"POI/题解","permalink":"http://arintaro.com/categories/POI/题解/"}],"tags":[{"name":"悬线法","slug":"悬线法","permalink":"http://arintaro.com/tags/悬线法/"},{"name":"多维问题","slug":"多维问题","permalink":"http://arintaro.com/tags/多维问题/"},{"name":"构造","slug":"构造","permalink":"http://arintaro.com/tags/构造/"}]},{"title":"USACO15JAN 电影移动 Moovie Mooving","slug":"Answer/cow5","date":"2019-11-03T13:35:49.436Z","updated":"2019-11-03T13:43:04.190Z","comments":true,"path":"2019/11/03/Answer/cow5/","link":"","permalink":"http://arintaro.com/2019/11/03/Answer/cow5/","excerpt":"强行与牛有关","text":"强行与牛有关 Description:@card{ 给$n$种颜色区间，每种区间至多有$m$个，要求一种颜色至多选出一个区间，覆盖到$aim$，判断是否可行，可行的话要输出选的最少颜色个数。 $1 \\leq n \\leq 20$，$1 \\leq m \\leq 1000$，$1 \\leq aim \\leq 100000000$ } Solution:@card{ 值域很大，$n$非常小，最优化问题，二分答案显然不行，排序贪心由于有颜色限制不容易做，考虑状压dp。 显然对后面计算有后效性的值有两个，第一个是当前已经选了哪些颜色，第二个是当前选到了了哪，由于$n$较小，第一个可以直接状压，第二个有”最优性”可以直接放价值上。 每次转移直接枚举这次要选哪种颜色，选一个当前能选的最晚开始的即可。 这份代码由于使用了upper_bound与vector，常数较大，不开O2在luogu上过不了。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define gb(x, i) (((x) &gt;&gt; (i)) &amp; 1)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 21;const int maxm = 1000 + 10;int n, m, aim;int dp[1 &lt;&lt; maxn];// 0-indexvector&lt;int&gt; arr[maxn];int len[maxn];int ans = maxn;int main() &#123; readint(n), readint(aim); for(rint i=0; i&lt;n; i++) &#123; int x = 0; readint(len[i]), readint(m); for(rint j=0; j&lt;m; j++) &#123; readint(x), arr[i].push_back(x); &#125; &#125; for(rint s=0; s&lt;(1&lt;&lt;n); s++) &#123; int cnt = 0; for(rint i=0; i&lt;n; i++) &#123; if((s &gt;&gt; i) &amp; 1) &#123; cnt++; continue; &#125; // 找最后一个小于等于dp[s]的数 int p = upper_bound(arr[i].begin(), arr[i].end(), dp[s]) - arr[i].begin(); if(p == 0) continue; dp[s | (1 &lt;&lt; i)] = max(dp[s | (1 &lt;&lt; i)], arr[i][p-1] + len[i]); &#125; if(dp[s] &gt;= aim) ans = min(ans, cnt); &#125; printf(\"%d\\n\", ans == maxn ? -1 : ans); return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://arintaro.com/tags/状态压缩/"}]},{"title":"USACO2015Jan Cow Rectangles","slug":"Answer/cow4","date":"2019-11-03T11:44:26.450Z","updated":"2019-11-03T13:35:33.939Z","comments":true,"path":"2019/11/03/Answer/cow4/","link":"","permalink":"http://arintaro.com/2019/11/03/Answer/cow4/","excerpt":"强行与牛有关","text":"强行与牛有关 Description:@card{ 坐标系上给$n$个点，分H点G点，求一个矩形，不包含任何G点，并包含尽量多的H点，在此基础上最小化面积。 $1 \\leq n \\leq 1000$，$1 \\leq x \\leq 1000$，$1 \\leq y \\leq 1000$ } Solution:@card{ 算法一: 离散化后直接暴力发现$n$只有500，那么我们离散化后显然可以跑$O(n^3)$的做法。 转化一下题意，显然这个矩形的任意一边是必须在某个G点或H点上的，所以我们可以令H点的权值为1，G点的权值为$-inf$然后跑”最大子矩形和”，这个显然可以$O(n^3)$跑出来，直接解决。 在最优化问题中，我们可以直接把不合法的状态设置成$inf$，从而避免了不合法的转移，降低编程复杂度。 因为我还不会写王知昆论文中的算法一，我在这题发现离散化后都可以用算法二跑，复杂度相同，适应范围更广。 算法二: 求极大子矩形 + 二分缩小可以发现，在这个”最大子矩形和”问题中，是没有”负权点”的，只有禁止点和点权为1/0的点，考虑没有禁止点怎么做，发现令点权最大肯定是全选，问题在于怎么让面积最小，发现”面积过大”的锅肯定是边缘上多选了一些点权为0的点，只要在四周二分缩小，每次检查点权小没小即可。 然而本题中有禁止点，类似之前的想法，答案显然是极大子矩形，我们对每个极大子矩形二分缩小即可，极大子矩形个数显然是$O(n^2)$级的，二分缩小再挂个$log$，总复杂度$O(n^2logn)$ } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//O(n^3)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;// 0 &lt;= x &lt;= 1000int n;int px[maxn], py[maxn], val[maxn];int totx, toty;int htx[maxn], hty[maxn];void eco(int arr[maxn], int ht[maxn], int&amp; tot) &#123; memcpy(ht, arr, sizeof(int) * (n + 1)); sort(ht+1, ht+n+1), tot = unique(ht+1, ht+n+1) - (ht+1); for(rint i=1; i&lt;=n; i++) arr[i] = lower_bound(ht+1, ht+tot+1, arr[i]) - ht;&#125;int ma[maxn][maxn], sum[maxn][maxn];int arr[maxn], arr_sum[maxn];// 注意上限是totyint ans_val = 0, ans_area = 0;void calc(int h) &#123; int pos = 0; // 直接把不合法的情况赋成-inf for(rint i=1; i&lt;=toty; i++) &#123; arr_sum[i] = arr_sum[i-1] + arr[i]; int now_val = arr_sum[i] - arr_sum[pos], now_area = h * (hty[i] - hty[pos+1]); if(now_val &gt; ans_val || (now_val == ans_val &amp;&amp; now_area &lt; ans_area)) &#123; ans_val = now_val, ans_area = now_area; &#125; if(arr_sum[pos] &gt;= arr_sum[i]) pos = i; &#125; // sum[i] - sum[j] 0&lt;=j&lt;i &#125;int main() &#123; char s[4]; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(px[i]), readint(py[i]); scanf(\"%s\", s + 1); val[i] = (s[1] == 'H' ? 1 : -maxn); &#125; eco(px, htx, totx), eco(py, hty, toty); for(rint i=1; i&lt;=n; i++) ma[px[i]][py[i]] += val[i]; for(rint i=1; i&lt;=totx; i++) &#123; for(rint j=1; j&lt;=toty; j++) sum[i][j] = sum[i-1][j] + ma[i][j]; &#125; for(rint i=1; i&lt;=totx; i++) &#123; for(rint j=i; j&lt;=totx; j++) &#123; for(rint k=1; k&lt;=toty; k++) arr[k] = sum[j][k] - sum[i-1][k]; calc(htx[j] - htx[i]); &#125; &#125; printf(\"%d \\n%d \\n\", ans_val, ans_area); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// O(n^2logn)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;int n;int px[maxn], py[maxn], val[maxn];int htx[maxn], hty[maxn];int ma[maxn][maxn], sum[maxn][maxn];int lmax[maxn][maxn], rmax[maxn][maxn], umax[maxn][maxn];int totx, toty;inline void eco(int arr[maxn], int ht[maxn], int&amp; tot) &#123; memcpy(ht, arr, sizeof(int) * (n + 1)); sort(ht+1, ht+n+1), tot = unique(ht+1, ht+n+1) - (ht + 1); for(rint i=1; i&lt;=n; i++) arr[i] = lower_bound(ht+1, ht+tot+1, arr[i]) - ht;&#125;inline int calc_val(int x1, int y1, int x2, int y2) &#123; return sum[x2][y2] - sum[x2][y1-1] - sum[x1-1][y2] + sum[x1-1][y1-1];&#125;inline int calc_area(int x1, int y1, int x2, int y2) &#123; return (htx[x2] - htx[x1]) * (hty[y2] - hty[y1]);&#125;struct rec&#123; int x1, y1, x2, y2; int val, area; rec() &#123;&#125; rec(int xx1, int yy1, int xx2, int yy2): x1(xx1), y1(yy1), x2(xx2), y2(yy2)&#123; val = calc_val(x1, y1, x2, y2), area = calc_area(x1, y1, x2, y2); &#125; bool operator &lt; (const rec&amp; b) const &#123; if(val == b.val) return area &gt; b.area; return val &lt; b.val; &#125; void shrink() &#123; int l = 0, r = x2 - x1; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc_val(x1 + mid, y1, x2, y2) == val) l = mid; else r = mid - 1; &#125; x1 += l; l = 0, r = x2 - x1; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc_val(x1, y1, x2 - mid, y2) == val) l = mid; else r = mid - 1; &#125; x2 -= l; l = 0, r = y2 - y1; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc_val(x1, y1 + mid, x2, y2) == val) l = mid; else r = mid - 1; &#125; y1 += l; l = 0, r = y2 - y1; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(calc_val(x1, y1, x2, y2 - mid) == val) l = mid; else r = mid - 1; &#125; y2 -= l; area = calc_area(x1, y1, x2, y2); &#125;&#125;arr[maxn * maxn];int totrec = 0;int main() &#123; char s[3]; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(px[i]), readint(py[i]); scanf(\"%s\", s + 1); val[i] = (s[1] == 'H' ? 1 : -maxn); &#125; eco(px, htx, totx), eco(py, hty, toty); for(rint i=1; i&lt;=n; i++) &#123; ma[px[i]][py[i]] += val[i]; &#125; // lmax, rmax表示这根悬线的最大延伸, 算自己 int n = totx, m = toty; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; sum[i][j] = ma[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]; &#125; &#125; rec ans; ans.val = 0, ans.area = 0; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) lmax[i][j] = ma[i][j] &lt; 0 ? 0 : lmax[i][j-1] + 1; for(rint j=m; j&gt;=1; j--) rmax[i][j] = ma[i][j] &lt; 0 ? 0 : rmax[i][j+1] + 1; for(rint j=1; j&lt;=m; j++) &#123; if(i == 1 || ma[i-1][j] &lt; 0) umax[i][j] = 1; else &#123; umax[i][j] = umax[i-1][j] + 1; lmax[i][j] = min(lmax[i-1][j], lmax[i][j]); rmax[i][j] = min(rmax[i-1][j], rmax[i][j]); &#125; if(ma[i][j] &gt;= 0) &#123; arr[++totrec] = rec(i - umax[i][j] + 1, j - lmax[i][j] + 1, i, j + rmax[i][j] - 1); ans = max(ans, arr[totrec]); &#125; &#125; &#125; for(rint i=1; i&lt;=totrec; i++) &#123; if(arr[i].val == ans.val) &#123; arr[i].shrink(); ans = max(ans, arr[i]); &#125; &#125; printf(\"%d \\n%d \\n\", ans.val, ans.area); return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"悬线法","slug":"悬线法","permalink":"http://arintaro.com/tags/悬线法/"},{"name":"多维问题","slug":"多维问题","permalink":"http://arintaro.com/tags/多维问题/"}]},{"title":"《天气之子》观后感","slug":"Essay/《天气之子》观后感","date":"2019-11-02T16:40:16.669Z","updated":"2019-11-18T02:59:03.027Z","comments":true,"path":"2019/11/03/Essay/《天气之子》观后感/","link":"","permalink":"http://arintaro.com/2019/11/03/Essay/《天气之子》观后感/","excerpt":"退役警告","text":"退役警告 一、前言 &amp; 观影体验@card{ 先讲讲我对新海诚的认识，毕竟这部动画很大一部分讨论都集中在他身上，这是一个蛮有趣的现象，其他日本动画电影在宣发时主要强调的是IP，毕竟深夜动画圈相对整个观影人群还是占绝对少数的，而君名和这部宣发很大程度上强调的是由”新海诚”这个人上，这是与”宫崎骏”在同等地位上的。 诚哥在《君名》之前，认知度还是集中在”平时就比较喜欢看日本动画”的人里，我在这个时间点大概只看过《秒速五厘米》。《君名》爆红之后，我才陆陆续续补了其他作品，当然，我作为一名萌二，肯定是现在还没看完的，记得《云端》只看了木鱼水心的解说视频，现在最喜欢的大概是《星之声》，当然这部从制作水准上肯定是没现在的作品强，但是我喜欢的是其中的”idea”。（比民俗我大概更喜欢科幻。 这次的《天气之子》是比《君名》在上映前更受到关注的，资本因素大概会更多一些？不过有趣的是，国内的引进速度都是差不多的（奇异的游戏人生zero，话说TV动画什么时候继续出啊？！），因此我在上映前就被各大位于日本的动漫高手剧透了大体剧情走向（当然出钱这么多的片子肯定也可以推测出不会让诚哥乱搞一个BE出来的）。 接着讲观影体验，具体观影我是在11/2的晚上刷了两遍，一开始本来只想看一场的，但是由于：第一场： 我一个人坐在了两对情侣之间- 儿童厅的小屏幕- 提前买了冰奶茶很好喝+ 首次观影+ 第二场: 有dbn陪我吹水+ imax的大屏幕+ 有可爱的妹子+ 人少可以随便换座+ 明天放假+ 第一次在影院里看到《君名》女主翻译成”宫本茂”时，我的反映： 这不是做马里奥的那个大叔嘛？ 我是不是记错女主名字了，她不是叫宫水三叶么？ 啊啊，应该是嫁给男主改姓了 可是男主不是叫”立花泷”么？ ？？我记错哪个名字了？！ } 二、杂项@card{ 这部分放在前面，因为我确实啥也不懂，只能跟《君名》做做比较。 作画这部分似乎没什么人提，因为经费比较充足，确实作画质量吊打各大其余”类似画风”的动画。动作场面非常精彩，诚哥标志性的城市风景和天空也得到了充分的体现，对于我这样的非作豚肯定是只能吹爆了。（当然单从作监履历上来看，田村篤确实之前没有什么著名作品，肯定是没有《君名》的安藤雅司耀眼），anitama上贴了很多幕后制作故事、访谈，连接。 人设上我认为女主的人设还是比较新颖的，男主的似乎见得比较多？ 音乐，我这样五音不全的人就不评价了，单听都是非常好听，但从”契合度”上来讲，似乎是没有《君名》好，中间还有女主唱《逃耻》的曲子，我在电影院里居然反应过来。。 配音我认为都非常优秀，包括在日上映之前在zhihu上饱受怀疑的启用明星配音的小栗旬。 } 三、剧情 (剧透警告)@card{ 由于我现在没读过小说，BD也没出，以下均按我在影院看了两遍的个人感受为准。 剧情主体还是传统的boy meets girl，再混合了一些超能力设定和小偷家族的感觉？出来看了访谈， 据说新海当初在观看是枝裕和导演执导的《小偷家族》时，就想着要酝酿一部，未必如揭示日本低层民众疾苦的《小偷家族》那般立意沉重深远，但在感觉上较为相近的作品。登场人物中既有姐姐，年幼的孩子，也有上了年纪的老婆婆，以及少年。如此，便有望将影片打造成老少皆宜的作品。作者：izumi链接：http://www.anitama.cn/article/e49836264d7384cc来源：Anitama 前期剧情前期讲了男主离家出走，受到女主和大叔帮助，并用捡来的枪击退了劝拐女主从事风俗业的坏人，后来想到利用能力牟利并度过了一段欢乐日常。 一开始，男主离家出走时身上是带伤的，暂不清楚是因为他太皮被”合理的管教”了，还是单纯的家暴。这里如果解释成”男主被家暴”了，大概男主的形象会在”社会意义上”正面一些。 之后女主给了落魄的男主一个汉堡，并成为后来男主阻止女主从事风俗业的flag，后来女主被开除我个人倾向是女主说的”其他原因”，而不是因为给了男主一个汉堡，毕竟女主想给的话，应该是自己掏钱买，从女主其余地方表现的善良性格，大概是不会偷汉堡店的东西的。 中间前辈的两个女友玩了声优梗。(前辈太强了，orz) 这段大叔的戒指给了非常多的特写，疯狂暗示大叔的亡妻，看zhihu上说场刊废设有大叔是专门研究民俗的学者，而不是现在的八卦小报编辑。剧情中给了相当多的暗示大叔是有故事的人，我个人倾向于他妻子也是那种”牺牲小我成就大我的巫女”(是不是天气巫女不确定)，并且大叔没有像这次的男主一样选择老婆而不是世界，之后现在的大叔一直在后悔。但我认为他对这次阳菜能力的设定还是不太清楚的，如果清楚，恐怕他会在得知阳菜在滥用能力之后立刻阻止的吧。我认为如果大叔设定成”学者”，并将救阳菜的后果与方法研究出来，这个片子的剧情走向恐怕就会完全改变，这个之后再说。 捡到枪是非常重要的flag，它直接引起了后来的剧情冲突，但是这也恰恰是被很多人喷的点，还是之后再说。 在男主想到能力牟利后，剧情前期大概就再也没描写过生活不易，并且这段他们的活动已经引起了相当的关注。这里可以发现他们所在的世界(同时也是《君名》的世界)，虽然充斥着超自然现象，但在普通群众的认可度不高，政府也没有相关机构研究，换句话说，就是没有社会人认为能力是真的，也没有政府认为能力是真的，否则单凭这几个孩子肯定是要被抓走的。当然，这是与剧中大型活动单靠女主矛盾的，不过也可以解释成”当个吉祥物”，否则就是剧情出锅了。不少能力系的作品的核心矛盾就定在”政府/机构抓人研究上”，但是这部作品没有。我在这里就联想到了《哆啦A梦》，大雄每次适当用道具时就不会出事，一旦开始乱搞就肯定会出事，这其实是插上了BE的flag。 中期中期大概是三人组的整个逃亡过程。 然后就到了主要争论点，这片没有不可调和的核心矛盾，所谓的矛盾大部分是男主决策失误自己作的。(这并不是定论，请接着往下看) 剧中中期阻碍两人在一起的是警察，后期阻碍的是警察+神隐。中期警察为什么抓他俩？ 是因为男主捡到枪并使用了它，女主带着弟弟独立生活，由于剧中并没有描写警察势力有多么黑暗，从常理来讲”男主持枪”在暴力袭警之前，是完全可以解释清楚的。而”女主带着弟弟独立生活”也不是不可调和的，即使接受收容，女主反而可以接受教育，弟弟也能过上物质条件好一些的生活，并且接受稳定的教育，这与女主照顾弟弟的目标是契合的。剧中解释是想”两人在一起生活”，可接受收容后两人也并不是见不到了呀。现在剩下的问题其实是，一旦男主选择与警察和解，其必然要被遣返读完高中，事实上从结局给出的结果来看，这并不是不可接受的结果。然后最终他们选择了跑路，其成功性也非常渺茫，没有身份证件，黑活也很难找到，也没有其他有效收入与住所，事发之后控制天气的私活也很难干下去，还要面临警察全天候的追捕，并且弟弟再也接受不了义务教育了。 从上述视角看，这个故事是”不合逻辑的”，但是剧中作出决策的并不是拥有上帝视角的观众，而是会作出”毫无准备的离家出走”这种决策的男主，这样的男主会作出不理性的决策，导致观众认为的”主线任务”偏离。 我一开始认为的主线是”男女主与世界的对抗”，看完想想，不如说是”男女主走到一起的曲折过程”，它可能本来会非常顺利，但是因为意外或者是剧中人物的决策失误导致了偏离，从”对抗世界”转而”对抗警察”。 我认为从”事实上的事件”来看，这个过程是没有问题的；但是从剧作的角度来看，我们平时看到的剧本一定是符合逻辑的，即使存在意外也在合理的范围并存在铺垫的：比如白箱最后一集，放一个不知道哪里出现的纵火犯把武藏野烧了，这恐怕会被喷到死，但是这种事件在现实里的京都却发生了，这就是所谓的”现实比剧本更加离奇”。 当然，这种事件在现实里肯定会有铺垫，但是由于我们信息量太少，无法掌握，而这在剧本里是会给你的，比如”某人买了不知用途的汽油，并拿着攻击用品朝着京都动画走来”，这就是可能推测出”这个人以后会纵火”的关键信息，而在现实里没有上帝视角or编剧特意强调的信息，这种信息是根本无法掌握的。 所以，我认为从男主之前设定的性格来看，作出这些冲动决策其实是合理的。但这样的情节安排肯定会导致”故事性不强”，这也是评价两极分化的直接原因，我认为是没有必要得出一个定论”故事性不强”好不好的，喜欢的人自然喜欢，不喜欢的人自然不喜欢。 后期后期讲了阳菜消失到拯救阳菜，及留白的遣返三年。 又到了一个争论点，不过大概没有上一个大，即男主的选择，在女主和东京之间果断选择了女主。 但是从影片中来看，男主做梦大概只做到了女主从神社升天(如果设定集改了这个前提，以下说明均不成立)，并没有给出他拯救女主的方法与后果。这也就是上文说的，”如果大叔设定成学者并研究成功”，这段男主的行为就从”观众的逻辑”完全解释的通了，而不是自我的”任性”。 仔细考虑一下，他被逮捕后，是不知道拯救女主的方法与后果的，这代表着即使他让大叔与姐姐成为共犯，即使他成功暴力袭警并选择为之承担后果，也不知道能否成功拯救女主，其成功概率是他无法预估的，而后果更是他无法预估的，是仅仅下雨几天，还是下雨几个月，或者是下雨三年淹了东京，还是最严重的淹了全世界。 他是根本不知道的，他是抱着仅有的一丝可能性，不顾之后的任何后果，选择了暴力袭警拯救女主，从这个角度考虑，这确实是能突出两人的羁绊的。从事后诸葛亮的角度来讲，恐怕任何观众换进去从逃亡开始走男主的流程，没有一个能打出GE的，反而是”任性”的男主打出了”个人较优解”。 不过，我相当奇怪的是女主的转变，在女主消失的那个晚上，她是愿意为世界而牺牲自己的，但是当后来男主不顾一切来找她的时候，她没有丝毫犹豫，直接跟男主走了。当然，由于没有女主视角，不知道女主这时对能力的前提与后果掌握的怎么样了，因此只能作为”奇怪的地方”。 不过也可以换个角度解释，也可以解释成那个晚上女主问男主愿不愿意停雨，那时男主说了”嗯”，所以女主依照男主的想法决定牺牲自己，但这时男主其实是不知道停雨的代价是女主消失，等到男主了解代价，并来救女主，其实就是告诉女主”我其实是不愿意你消失的”，所以女主又按照男主的想法立即回去了。大概这个角度能更突出两人的羁绊。 然后就是几人被抓后的现实社会情节，这部分一点没讲，但这其实是之前为何逃亡的重要原因，但影片自始自终没表现最后被抓回去有多惨，反而是男主只判了一个保护观察正常接收教育，男主未成年就忍了，但作为成年人共犯的大叔，就算能洗掉诱拐，可是暴力袭警怎么洗呀，基于开头的讨论，法官也肯定不会相信是因为一些超自然力，但是大叔三年后反而还混的更好了，这部分等设定集洗吧，不知道能如何解释。 当然，如果不考虑得这么复杂，我们抽象一点，东京和女主选哪个，或者更大一点，世界和女主选哪个，从我的立场来说，我选女主。 最后男女主的相见还是经典的坡道梗，虽然上面这么说了，但真正在电影院里看的时候，还是非常有感染力的。 } 四、总结@card{ 制作顶尖的作品。 如果你在意剧情，那么主要看您对”故事性不强”的故事的接受程度。我认为不在意剧情的人，这片都会看得非常开心。 知乎上有非常多的补充细节和剧情分析，如果您看完了这部，并对这些东西感兴趣十分推荐阅读，这里我就懒得放链接了。 最后，散发的女主真好看.jpg，等出了BD我要截下来。 }","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://arintaro.com/tags/动画/"},{"name":"颓废","slug":"颓废","permalink":"http://arintaro.com/tags/颓废/"}]},{"title":"Luogu P3400 仓鼠窝","slug":"Answer/hamster","date":"2019-11-01T08:46:01.002Z","updated":"2019-11-01T09:35:37.443Z","comments":true,"path":"2019/11/01/Answer/hamster/","link":"","permalink":"http://arintaro.com/2019/11/01/Answer/hamster/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给一个$n \\times n$的$01$矩阵，求出其中均为$1$的子矩阵个数。 $1 \\leq n \\leq 3000$ } Solution:@card{ 先考虑几个朴素做法，枚举子矩阵的三个角，暴力判断其中是否都是$1$，$O(n^6)$。 发现判断很耗时，不如用hash，降到$O(n^4)$。 考虑只枚举两个角，即枚举两个行，然后判断两行间有多少子矩阵。只要把多行压成一行，然后转化成一维问题解决即可。降到$O(n^3)$。 再写出暴力对拍后，考虑能否只枚举一个角解决问题。 算法一: 单调栈 + 分行计算贡献考虑之前经常做的最大子矩阵问题，我们可以枚举一行，然后每列之上连续的$1$的数量作为一列的高度。 同时注意不要重复计算，我们每次计算的是”底端在这行上”的数量，类似最大子矩阵问题，我们在出栈时计算贡献。 与之前相同，因为我们维护了矩形的单调性，我们出栈时倒序计算可以保证右边的矩形都比当前矩形高，从而快速累加贡献。但是这里我们需要计算什么呢？为了防止重复计算，我们规定出栈时只计算”跨多个矩形构成的子矩阵”，出栈一个矩形时，分成它自己的左端，和这次之前出栈的右端，不妨设左端宽度$w$，右端宽度$now$，左端高度$h$，则这次的贡献显然是$w \\times now \\times h$。 之后注意入栈时不能只入$now + 1$一个矩形，而是要入一个$now$和一个$1$的，因为新加进来的矩形与之前的矩形的贡献还未计算。 算法二： 单调栈 + 对每个右下角计算贡献考虑对一个右下角有多少个左上角能与其匹配，手玩后发现其在列上满足一定的单调性。所以分列转移，用递推预处理出每个点向左最多能扩展$1$的长度，再用单调栈维护一下即可，具体做法与上个方法类似。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 算法1#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 3000 + 10;int n, m;bool ma[maxn][maxn];int arr[maxn];lint ans = 0;int h[maxn], w[maxn], stop = 0;// 注意n, m别写反了lint calc() &#123; stop = 0; lint res = 0; for(rint i=1; i&lt;=m+1; i++) &#123; res += arr[i]; if(h[stop] &lt; arr[i]) h[++stop] = arr[i], w[stop] = 1; else &#123; int now = 0; while(stop &amp;&amp; h[stop] &gt;= arr[i]) &#123; res += (lint)w[stop] * now * h[stop], now += w[stop]; stop--; &#125; if(arr[i] != 0) &#123; h[++stop] = arr[i], w[stop] = now; h[++stop] = arr[i], w[stop] = 1; &#125; &#125; &#125; return res;&#125;int main() &#123; readint(n), readint(m); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(ma[i][j]); &#125; &#125; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) arr[j] = ma[i][j] ? arr[j] + 1 : 0; ans += calc(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 算法二#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 3000 + 10;int n, m;int lt[maxn][maxn];bool ma[maxn][maxn];int h[maxn], w[maxn];lint ans = 0;int main() &#123; readint(n), readint(m); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(ma[i][j]); lt[i][j] = ma[i][j] ? lt[i][j-1] + 1 : 0; &#125; &#125; for(rint j=1; j&lt;=m; j++) &#123; int cnt = 0, stop = 0; for(rint i=1; i&lt;=n; i++) &#123; cnt += lt[i][j]; if(!stop || (stop &amp;&amp; w[stop] &lt;= lt[i][j])) &#123; w[++stop] = lt[i][j], h[stop] = 1; &#125; else &#123; int now = 1; while(stop &amp;&amp; w[stop] &gt;= lt[i][j]) &#123; cnt -= (w[stop] - lt[i][j]) * h[stop]; now += h[stop], stop--; &#125; w[++stop] = lt[i][j], h[stop] = now; &#125; ans += cnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://arintaro.com/tags/单调栈/"},{"name":"悬线法","slug":"悬线法","permalink":"http://arintaro.com/tags/悬线法/"},{"name":"多维问题","slug":"多维问题","permalink":"http://arintaro.com/tags/多维问题/"}]},{"title":"USACO11OPEN 奇数度 Odd degrees","slug":"Answer/cow3","date":"2019-11-01T02:41:11.874Z","updated":"2019-11-01T08:45:40.063Z","comments":true,"path":"2019/11/01/Answer/cow3/","link":"","permalink":"http://arintaro.com/2019/11/01/Answer/cow3/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给一张图，要求选出一些边，使每个点的度数为奇数。 $1 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^5$ } Solution:@card{ 由于图上问题有”任意性”, 难以进行DP，所以先考虑性质与扫描。 发现这个问题与图的形态无关，其实就是给一个全$0$序列和$m$对关系，选一对关系是把两个都加一，最后求怎么选能让序列中的数都都是奇数，最后发现十分不可做，我们难以确定计算顺序，选了一对关系很可能会对后面带来无法估计与记录的影响。 考虑在树上怎么做，树上显然确定计算顺序自下而上即可，叶子节点连向父亲的边是必须选的，考虑完所有的叶子节点，再考虑向上一层，它们此时的度数的奇偶性是确定，也就是说成为新的”可以直接确定连向父亲边选不选的”叶子节点。 接着扩展到图上，发现图上随便一个生成树的所有方案其实覆盖了图上的所有方案。首先，对一条链来讲，把其中边选不选的状态取反，中间的节点度数奇偶性均不变，只有两头的节点奇偶性取反。那么如果存在一种方案有一条不在生成树上的边成立，那么去掉这条边，把它在生成树路径上的边取反，显然也是一种成立的方案。 所以随便求个生成树当树上问题做即可。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e4 + 10;const int maxm = 2e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], id[maxm], totedge = 1;inline void addedge(int nu, int nv, int x) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge; id[totedge] = x;&#125;// 图上问题在树上怎么做？int cnt = 0;bool vis[maxn], choose[maxm];bool dfs(int x) &#123; bool res = 0; vis[x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(vis[y]) continue; if(!dfs(y)) cnt++, choose[id[i]] = 1, res ^= 1; &#125; return res;&#125;int main() &#123; readint(n), readint(m); int nu, nv; for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv); addedge(nu, nv, i), addedge(nv, nu, i); &#125; bool failed = 0; for(rint x=1; x&lt;=n; x++) &#123; if(vis[x]) continue; if(!dfs(x)) &#123; failed = 1; break; &#125; &#125; if(failed) puts(\"-1\"); else &#123; printf(\"%d\\n\", cnt); for(rint i=1; i&lt;=m; i++) if(choose[i]) printf(\"%d\\n\", i); &#125; return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"等效法","slug":"等效法","permalink":"http://arintaro.com/tags/等效法/"},{"name":"生成树","slug":"生成树","permalink":"http://arintaro.com/tags/生成树/"}]},{"title":"USACO13JAN 牛的阵容 Cow Lineup","slug":"Answer/cow2","date":"2019-10-31T11:41:09.091Z","updated":"2019-10-31T11:46:54.171Z","comments":true,"path":"2019/10/31/Answer/cow2/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cow2/","excerpt":"转化后不难的问题。","text":"转化后不难的问题。 Description:@card{ 给定一个颜色序列，可以至多去掉$k$种颜色，使去除后一个连续相同颜色的子段最长。 $1 \\leq k \\leq 10^5$, $1 \\leq k \\leq n$ } Solution:@card{ 考虑一个颜色数不大于$k+1$的区间，它显然可以去掉$k$种留下区间颜色数最多的得到这个区间的答案。 然后双指针扫一扫，对每个$i$找颜色数尽量多的区间即可。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, k, ans = 0;int arr[maxn];int ht[maxn], tot = 0;inline int eco(int x) &#123; return lower_bound(ht+1, ht+tot+1, x) - ht;&#125;int cnt_color[maxn], cnt = 0;inline void update(int c, int x) &#123; int pre = (cnt_color[c] != 0); cnt_color[c] += x; cnt += (cnt_color[c] != 0) - pre;&#125;int main() &#123; cnt_color[0] = 1; readint(n), readint(k); for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]); ht[++tot] = arr[i]; &#125; sort(ht+1, ht+n+1), tot = unique(ht+1, ht+n+1) - (ht + 1); for(rint i=1; i&lt;=n; i++) arr[i] = eco(arr[i]); for(rint i=1, j=0; i&lt;=n; i++) &#123; while(j &lt;= n &amp;&amp; cnt &lt;= k + 1) update(arr[++j], 1); ans = max(ans, cnt_color[arr[i]]); update(arr[i], -1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"等效法","slug":"等效法","permalink":"http://arintaro.com/tags/等效法/"}]},{"title":"POJ3017 Cut The Sequence","slug":"Answer/cut","date":"2019-10-31T06:20:01.041Z","updated":"2019-10-31T11:38:57.144Z","comments":true,"path":"2019/10/31/Answer/cut/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cut/","excerpt":"","text":"Description:@card{ 给定一个长度为$n$的序列A，要求把该序列分成若干段，在满足“每段中所有数的和”不超过$m$的前提下，让“每段中所有数的最大值”之和最小。 $1 \\leq n \\leq 10^5$, $1 \\leq m \\leq 10^{11}$ } Solution:@card{ 这题是个相当好的题目。 最优化问题，乍一看挺像一个二分答案的，答案显然具有单调性，然而仔细考虑一下，二分答案中，我们二分出来的“答案”需要对计算有帮助，然而这个答案““每段中所有数的最大值”之和”，对计算毫无卵用，根本无法check。 既然最优化问题的第一个想法二分答案不行，我们接着考虑最优化问题的第二个想法，DP。 不妨设$max[l,r] = max{arr[k],k \\in [l,r]}$, 显然有状态转移方程：$$dp[i] = \\min(dp[j] + max[j+1, i])$$ 是一种经典的枚举断点从而转移的序列分段DP，然而复杂度过高，稍微想想没什么显然的等效转移or状态。 接着考虑优化此方程，然而也很困难，$max[k+1,i]$是一个与当前状态变量有关的函数，这样$i$每增加1，我们都必须得考虑每个合法决策来确定决策对当前状态的评分。这也不是简单多项式函数，可以利用斜率优化解决的。 四边形不等式？需要有$max[k,i+1] + max[k+1,i] &gt;= max[k,i] + max[k+1,i+1]$，这个式子乍一看像成立的，然而并不成立（虽然对不少小规模数据是可以成立的，这也提醒我们四边形不等式的打表一定要打的长一些，不能太懒），考虑$k$与$i+1$位置上出现有俩$inf$，此时等式左边只有一个$inf$，而等式右边俩$inf$，显然不成立。 考虑定值，斜率优化，四边形不等式全挂了，只剩一个单调性了。 从实际意义出发：考虑前后两个决策$k$, $k+1$显然有$$dp[k] \\leq dp[k+1]$$$$max[k+1,i] \\geq max[k+2,i]$$即非严格单调性，那如果$k+1$想成为最优决策，必须有$max[k+2,i] &lt; max[k+1,i]$,进而可以推出$arr[k+1] = max[k+1,i]$（注意两个条件并不等价） 可以发现，我们似乎把不确定的$max[k+1,i]$化为了一个数组中的定值，然而决策$k+1$中的函数是$max[k+2,i]$，那怎么办呢？既然$k+1$可能成为最优决策可以确定$max[k+1,i]$的值，那不妨我们就去找$k+2$或更后面的决策可能成为最优决策的时候$max[k+2,i]$的值也便确定了。 基于此思路，由于前面的限制条件$sum[i] - sum[k] \\leq m$,是一个”越前面越难满足的条件”，说白了就是从队头出队，所以我们可以维护一个单调队列，其中$arr[k]$单调递减，显然队列中第$k$项的$max$函数就是下一项的的值。这样对于一个决策，只要队列中的下一项不变，它的评分就与$i$无关，是一个定值，这样就化为了模板题，用堆or平衡树维护决策集合即可。由于本题中出队时，需要有删除操作，而堆要删除每次还要记录指针，相当麻烦，不如直接用平衡树，复杂度也是$O(nlogn)$，常数大一些。 讨论至此，您写出来可能发现样例都过不了，因为忽视了讨论的“前提条件”，我们考虑了$k+1$，用$k$肯定or否定了它的最优性，那么有没有这样一个决策，前面没有决策呢？显然就是最小的满足$sum[i] - sum[k] \\leq m$的$k$。 程序实现上，由于队列中最后一项的$max$函数的值一定是$arr[i]$，我们可以在转移前把$arr[i]$入队计算即可。另外要注意特判平衡树or队列为空的情况，避免RE或WA。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const lint inf = 1e16;int n;int arr[maxn], q[maxn];lint m, sum[maxn], dp[maxn];multiset&lt;lint&gt; s;inline lint calc(int pos) &#123; return dp[q[pos]] + arr[q[pos + 1]];&#125;int main() &#123; readint(n), readint(m); // 无解与正常计算分开判断 for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]), sum[i] = sum[i-1] + arr[i]; if(arr[i] &gt; m) &#123; puts(\"-1\"); return 0; &#125; &#125; int l = 1, r = 0; for(rint i=1, p=0; i&lt;=n; i++) &#123; while(p &lt; i &amp;&amp; sum[i] - sum[p] &gt; m) p++; while(l &lt;= r &amp;&amp; sum[i] - sum[q[l]] &gt; m) s.erase(s.find(calc(l++))); while(l &lt;= r &amp;&amp; arr[q[r]] &lt;= arr[i]) &#123; if(l &lt; r) s.erase(s.find(calc(r - 1))); r--; &#125; q[++r] = i; if(l &lt; r) s.insert(calc(r - 1)); dp[i] = dp[p] + arr[q[l]]; if(l &lt; r) dp[i] = min(dp[i], *s.begin()); &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"POJ","slug":"POJ","permalink":"http://arintaro.com/categories/POJ/"},{"name":"题解","slug":"POJ/题解","permalink":"http://arintaro.com/categories/POJ/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"单调队列","slug":"单调队列","permalink":"http://arintaro.com/tags/单调队列/"}]},{"title":"高斯消元","slug":"Template/数学/线性代数/高斯消元","date":"2019-10-31T02:54:23.836Z","updated":"2019-10-31T06:19:44.151Z","comments":true,"path":"2019/10/31/Template/数学/线性代数/高斯消元/","link":"","permalink":"http://arintaro.com/2019/10/31/Template/数学/线性代数/高斯消元/","excerpt":"注意无解和多解的判断","text":"注意无解和多解的判断 一、概念@card{ 先确定这次要消哪元，然后从还没被确定的方程中选一个系数不为$0$的消其他所有该元系数不为$0$的方程，无解即存在$0 = 4$这种方程，多解即存在$0 = 0$的方程。 } 二、测试地址@card{ Luogu高斯消元模版：https://www.luogu.org/record/26019277 } 三、代码@card{123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define zero(x) (fabs((x)) &lt; eps)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50 + 10;const double eps = 1e-6;int n;double c[maxn][maxn];int calc() &#123; for(rint t=1, p=1; t&lt;=n; t++) &#123; for(rint i=p; i&lt;=n; i++) &#123; if(zero(c[i][t])) continue; for(rint k=1; k&lt;=n+1; k++) swap(c[i][k], c[p][k]); break; &#125; if(zero(c[p][t])) continue; for(rint i=1; i&lt;=n; i++) &#123; if(i == p || zero(c[i][t])) continue; double rate = c[i][t] / c[p][t]; for(rint k=1; k&lt;=n+1; k++) c[i][k] -= c[p][k] * rate; &#125; p++; &#125; for(rint i=1, p=1; i&lt;=n; i++) &#123; while(p &lt;= n &amp;&amp; zero(c[i][p])) p++; if(p == n + 1 &amp;&amp; !zero(c[i][p])) return -1; &#125; for(rint i=1, p=1; i&lt;=n; i++) &#123; while(p &lt;= n &amp;&amp; zero(c[i][p])) p++; if(p == n + 1) return 0; &#125; return 1;&#125;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=n+1; j++) readint(c[i][j]); &#125; int res = calc(); if(res == 1) &#123; for(rint i=1; i&lt;=n; i++) printf(\"x%d=%.2lf\\n\", i, c[i][n+1] / c[i][i]); &#125; else printf(\"%d\\n\", res); return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数学","slug":"模板/数学","permalink":"http://arintaro.com/categories/模板/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"线性代数","slug":"线性代数","permalink":"http://arintaro.com/tags/线性代数/"}]},{"title":"HAOI2015 树上染色","slug":"Answer/color","date":"2019-10-31T02:03:25.740Z","updated":"2019-10-31T11:41:02.748Z","comments":true,"path":"2019/10/31/Answer/color/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/color/","excerpt":"换个思路，统计贡献","text":"换个思路，统计贡献 Description:@card{ 有一棵点数为$n$的树，树边有边权，你要在这棵树中选择$k$个点，将其染成黑色，并将其他的$n-k$个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益，问收益最大值。 $1&lt;=n&lt;=2000$，$0&lt;=k&lt;=n$ } Solution:@card{ 先迅速地打出暴力，枚举选哪些，然后每个节点作根暴力计算答案，手玩了一下没发现有什么贪心性质。 由于是树上的路径之和，考虑类似树上差分的想法，即有很多个点对，每次都会把它们之间的路径覆盖一次，求每个边的边权乘以覆盖次数的和，对每条边计算覆盖次数即可。 此题中的覆盖一条边的覆盖次数显然是子树中的某色点数量乘子树外的某色点数量，由于色点数量给定，一旦我们知道了一端的数量，就能通过整体减去局部的方法计算出另外一端。 所以可以先确定自下而上的计算顺序，状态定义为某个子树中选$k$个黑点所有边产生的最大贡献，类似费用提前计算，之后直接跑树上背包即可，注意应用上下界剪枝优化到$O(n^2)$ } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 2 * maxn;int n, m, root = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw; nxt[totedge] = head[nu], head[nu] = totedge;&#125;// 统计路径贡献 -&gt; 树上差分，考虑一条边的贡献 (费用提前计算)// 整体减局部为另外，正难则反// 以x为根的子树，k个黑点，所有边的最大贡献// lint dp[maxn][maxn];int size[maxn];void dfs(int x, int fa) &#123; size[x] = 1; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs(y, x); for(rint j=min(m, size[x] + size[y]); j&gt;=0; j--) &#123; for(rint k=max(0, j-size[x]); k&lt;=j &amp;&amp; k&lt;=size[y]; k++) &#123; dp[x][j] = max(dp[x][j], dp[x][j-k] + dp[y][k] + (lint)k * (m - k) * ew[i] + ((lint)size[y] - k) * (n - size[y] - (m - k)) * (lint)ew[i]); &#125; &#125; size[x] += size[y]; &#125;&#125;int main() &#123; readint(n), readint(m); int nu, nv, nw; for(rint i=2; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs(root, 0); printf(\"%lld\\n\", dp[root][m]); return 0;&#125; }","categories":[{"name":"省选","slug":"省选","permalink":"http://arintaro.com/categories/省选/"},{"name":"题解","slug":"省选/题解","permalink":"http://arintaro.com/categories/省选/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"换根法","slug":"换根法","permalink":"http://arintaro.com/tags/换根法/"}]},{"title":"USACO12FEB 附近的牛 Nearby Cows","slug":"Answer/cow1","date":"2019-10-31T00:26:43.109Z","updated":"2019-11-18T02:58:02.429Z","comments":true,"path":"2019/10/31/Answer/cow1/","link":"","permalink":"http://arintaro.com/2019/10/31/Answer/cow1/","excerpt":"强行与牛有关","text":"强行与牛有关 Description:@card{ 树上每个点有一个点权，求每个点距离不超过$k$的点权。其中$1&lt;=k&lt;=20$, $1&lt;=n&lt;=10^5$ } Solution:@card{ 注意要求全部点的答案，并且$k$较小，所以很可能是个换根DP。 又注意到对于任意一种转移顺序，某个点$x$的$dp[x][k]$，不可能转移到$y$的$dp[y][k+1]$，所以可以直接在状态内记录当前点范围为$k$的答案。规定计算顺序自下而上，先确定一个根，计算子树内的信息，之后再自上而下的根据父节点的答案算这个节点的答案即可。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const int maxk = 20 + 2;const int maxm = 2 * maxn;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans = 0;int n, m, root = 1;int sum[maxn][maxk], res[maxn][maxk];// 从x出发不超过kvoid dfs1(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs1(y, x); for(rint k=1; k&lt;=m; k++) sum[x][k] += sum[y][k-1]; &#125;&#125;// void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; res[y][0] = sum[y][0]; res[y][1] = sum[y][1] + sum[x][0]; for(rint k=2; k&lt;=m; k++) &#123; res[y][k] = res[x][k-1] - sum[y][k-2] + sum[y][k]; &#125; dfs2(y, x); &#125;&#125;int main() &#123; readint(n), readint(m); int x, y; for(rint i=1; i&lt;n; i++) &#123; readint(x), readint(y); addedge(x, y), addedge(y, x); &#125; for(rint i=1; i&lt;=n; i++) &#123; readint(sum[i][0]); for(rint k=1; k&lt;=m; k++) sum[i][k] = sum[i][0]; &#125; dfs1(root, 0); for(rint k=0; k&lt;=m; k++) res[root][k] = sum[root][k]; dfs2(root, 0); for(rint i=1; i&lt;=n; i++) printf(\"%d\\n\", res[i][m]); return 0;&#125; }","categories":[{"name":"USACO","slug":"USACO","permalink":"http://arintaro.com/categories/USACO/"},{"name":"题解","slug":"USACO/题解","permalink":"http://arintaro.com/categories/USACO/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"换根法","slug":"换根法","permalink":"http://arintaro.com/tags/换根法/"}]},{"title":"HNOI2003 消防局的设立","slug":"Answer/fire","date":"2019-10-30T08:24:46.725Z","updated":"2019-10-30T09:44:29.080Z","comments":true,"path":"2019/10/30/Answer/fire/","link":"","permalink":"http://arintaro.com/2019/10/30/Answer/fire/","excerpt":"少数几道贪心扩展性超过DP的题目","text":"少数几道贪心扩展性超过DP的题目 Description:@card{ 从树上选出最少的点，每个点可以覆盖与它距离不超过2的点，求最少需要选出多少点。 } Solution:@card{ 贪心做法扩展性强，且容易理解，但是这里不讲。本问题有很多前置形态，比如”每条边连接的两点必须任选一个”, 只需要记录每个点选不选就行了，但是此题影响的距离是2，这启发我们需要在DP状态上记录更多的信息便于转移。 树上问题一般要先确定计算顺序是自上而下还是自下而上，这里选择自上而下显然不容易设计出状态，所以选择每次从子树向上转移的自下而上。 确定计算顺序后，容易想到状态是”某范围中的点都被管辖所需要的最少点数”，按常规考虑是一个点子树中的点都被管辖，但是手玩几组数据发现，这样设计状态，一个点是可以从它的孙子甚至曾孙转移来的，这样设计状态难以转移，如果暴力追溯转移，时间上显然会爆炸。不容易优化转移，考虑重新设计状态，又想到附加儿子或孙子选不选的小范围状压维度，进一步考虑，我们事实上不关心子树中选了什么点，而是想通过知道这些点选没选而得知它向上覆盖的范围，所以我们规定状态为”某个点向上/向下覆盖了多少层选的最少点数”, 考虑一个节点$x$，它向下两层的节点必须在它这里被覆盖，否则按照我们的计算顺序，它以后都没机会被覆盖了，所以状态中记录的向上向下的最大层数为2。 接着考虑如何转移，$dp[x][0]$为它的孙子被完全覆盖, 1为儿子都被覆盖, 2为自己被覆盖, 3为父亲被覆盖, 4为祖父为覆盖。 下设$y$为$x$的儿子，显然有$$dp[x][0] = \\sum{dp[y][1]}$$与$$dp[x][1] = \\sum{dp[y][2]}$$ 先暂缓一下，这样转移可能会遗漏某些情况，这样转移状态的严谨定义就变成”刚好覆盖到某层的最少点数”，但是会不会有时往上多覆盖了反而用了更少的点？考虑一个边界情况，按照此定义，对于一个叶子节点$x$，$dp[x][2]$显然无法成立，需要设成inf，这显然会影响后续的转移，所以不妨直接将状态定义为”至少覆盖到这层”的最小点数，也可以理解为对状态求后缀min。按此定义，我们可以先按照上述的递推式计算，当$x$的所有状态计算完毕后，再扫一遍取后缀min。 当覆盖到$x$下面时，子树是分叉的，所有点都需要被覆盖，因此需要求和。但当覆盖到$x$时或以上，变成了只有一支，所以我们只需要覆盖一次，其余子树选最小能覆盖的即可。所以有：$$dp[x][2] = \\min(dp[y][3] + \\sum_{s \\not = y}{dp[s][2]})$$为了程序实现方便，上述方程可以改写为$$dp[x][2] = dp[x][1] + \\min(dp[y][3] - dp[y][2])$$当能覆盖$x$上一层时，需要某个子节点向上覆盖两层，需要注意这个覆盖对于其他子树也会成立，因此有$$dp[x][3] = \\min(dp[y][4] + \\sum_{s \\not = y}{dp[s][1]})$$当$x$向上覆盖两层，显然$x$一定是被选上的，所以有$$dp[x][4] = \\sum{dp[y][0]} + 1$$} Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int maxm = 2 * maxn;int n, root = 1;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;// 影响后续计算的放状态里// 树形问题计算顺序自下而上，自上而下// 自下而上// dp[x][0]表示x一层以下都被覆盖最少代价// dp[x][1] x以下都被覆盖// dp[x][2] x被覆盖// int dp[maxn][6];// dp[x][2] = dp[x][1] + min&#123;- dp[y][2] + dp[y][3]&#125;void dfs(int x, int fa) &#123; dp[x][2] = dp[x][3] = maxn; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs(y, x); dp[x][4] += dp[y][0]; // x一层以下都被覆盖 dp[x][0] += dp[y][1]; // x以下被覆盖 dp[x][1] += dp[y][2]; // x被覆盖 dp[x][2] = min(dp[x][2], dp[y][3] - dp[y][2]); // x上一层被覆盖 dp[x][3] = min(dp[x][3], dp[y][4] - dp[y][1]); &#125; dp[x][4]++, dp[x][2] += dp[x][1], dp[x][3] += dp[x][0]; for(rint k=3; k&gt;=0; k--) dp[x][k] = min(dp[x][k], dp[x][k+1]);&#125;int main() &#123; readint(n); for(rint x=2, y; x&lt;=n; x++) &#123; readint(y); addedge(x, y), addedge(y, x); &#125; dfs(root, 0); cout &lt;&lt; dp[root][2] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"后效性的处理","slug":"后效性的处理","permalink":"http://arintaro.com/tags/后效性的处理/"}]},{"title":"AC自动机","slug":"Template/字符串/ac","date":"2019-10-28T14:07:45.546Z","updated":"2019-11-06T04:37:00.801Z","comments":true,"path":"2019/10/28/Template/字符串/ac/","link":"","permalink":"http://arintaro.com/2019/10/28/Template/字符串/ac/","excerpt":"大概可以用来AC, 本文主要是记录性质, 大概会看不懂。","text":"大概可以用来AC, 本文主要是记录性质, 大概会看不懂。 一、概述@card{ AC自动机是基于Trie建立的, Trie上的一个节点到根节点的路径会确定唯一的一个字符串,表示的是插入Trie的某个字符串的前缀。 解决多模式串匹配问题时, 先把所有的模式串插入Trie中, 再进行建树。 AC自动机对于Trie上的每个节点构造fail指针, 其指向Trie上与这个节点的后缀匹配的最长真前缀的节点, 朴素的计算方法类似KMP或者是递推, 如果父节点的fail不能继续匹配自身, 就跳fail到次长, 如果找不到就连在根节点上, 时间复杂度显然不优, 优化后建出Trie图, 同时修改Trie上边的定义, 为当前节点加上这个字符后的后缀Trie上能匹配的最长前缀, 由于没有”真”, 这对原Trie上的边也是适用的。然后我们就可以递推地以深度作为状态去计算这两种指针, 当遍历到一个节点时, 遍历字符集, 当原Trie上有这条边时, 我们需要计算它的fail, 显然是$pv[fail[x]][c]$, 即与当前节点后缀匹配的最长真前缀再加上转移的字符的后缀在Trie上能匹配的最长前缀(大概用形式化的语言说出来就没有这么绕了), 感性的理解一下就是尝试给fail再加个字符去匹配, 需要对自身跳fail去找是因为fail需要是真前缀。 多模式串匹配时, 按序遍历主串, 每次当前节点跳Trie图上的边即可, 即对每个主串的前缀, 用它的后缀去找Trie上能匹配的最长前缀, 找到这个最长前缀后, 从它一直跳fail跳到根节点, 就能找到Trie上所有能与这个后缀匹配的前缀了。 注意每个节点有且仅有一条fail边, 那么其实所有fail边与点构成一棵树, 一个节点往上跳fail的过程其实就遍历它到根节点的路径, 基于这个性质, 我们可以在fail树上跑一些树形数据结构来维护一些东西。如维护出现次数树上差分等。 } 二、代码 + 讲解","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"字符串","slug":"模板/字符串","permalink":"http://arintaro.com/categories/模板/字符串/"}],"tags":[{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"字符串","slug":"字符串","permalink":"http://arintaro.com/tags/字符串/"}]},{"title":"小型人类智慧题/脑筋急转弯汇总","slug":"Answer/brain","date":"2019-10-27T13:24:46.584Z","updated":"2019-10-27T13:37:28.570Z","comments":true,"path":"2019/10/27/Answer/brain/","link":"","permalink":"http://arintaro.com/2019/10/27/Answer/brain/","excerpt":"自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。","text":"自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。 T1: 盛最多水的容器@card{ site: https://leetcode-cn.com/problems/container-with-most-water/ 给定一个数组, 要求$O(n)$求出最大的$|i - j| \\times \\min(arr[i], arr[j])$。 考虑枚举一个端点, 用$O(1)$的时间求出另一端的最优决策, 发现很难维护, 没有决策单调性, 按照$arr[j]$的大小分组用斜率优化+数据结构维护复杂度势必要多个$log$。 考虑重排序, 发现无论按下标排序or按值排序$abs$与$min$都很难维护。 正解是左右两端指针往中间扫, 即不确定”主指针”, 而是每次考虑移动任意一个指针去掉不可能的答案。这里每次只要把值较小的指针往中间移动即可, 正确性显然, 考虑任意一个端点在当前指针区间$[l, r]$外的的决策已经被更新进答案, 不妨设$arr[l]$较小, 则移动$l$其实就是去掉了所有左端点为$l$, 右端点在$(l, r]$的决策, 这其中的决策显然没有$[l, r]$好, 所以就推到了指针区间$[l+1, r]$所有区间外的决策已经被正确更新, 由数学归纳法知这么做不会遗漏答案。 } Solution:","categories":[{"name":"题解","slug":"题解","permalink":"http://arintaro.com/categories/题解/"}],"tags":[{"name":"人类智慧","slug":"人类智慧","permalink":"http://arintaro.com/tags/人类智慧/"}]},{"title":"小工具合集","slug":"Template/小工具/small-tool","date":"2019-10-27T10:21:08.341Z","updated":"2019-10-27T10:35:40.796Z","comments":true,"path":"2019/10/27/Template/小工具/small-tool/","link":"","permalink":"http://arintaro.com/2019/10/27/Template/小工具/small-tool/","excerpt":"比较有用, 但比较简短懒得单独开一页的技巧。","text":"比较有用, 但比较简短懒得单独开一页的技巧。 1.二进制子集枚举@card{1234int S = 22; // 全集for(int i=S; i; i=(i-1)&amp;S) &#123; // 此时i即为S的子集&#125; 枚举$n$位二进制数, 再依次枚举它的子集, 复杂度为$O(3^n)$}","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]},{"title":"Luogu 买菜","slug":"Answer/vegetable","date":"2019-10-27T02:00:24.681Z","updated":"2019-10-27T02:26:48.142Z","comments":true,"path":"2019/10/27/Answer/vegetable/","link":"","permalink":"http://arintaro.com/2019/10/27/Answer/vegetable/","excerpt":"模拟赛里的题, 没有题面(","text":"模拟赛里的题, 没有题面( Description:@card{ 给定一个字符串 𝑆 和一个字符串集合 𝑇，询问 𝑆 中最短的包含 𝑇 的子串。 } Solution:@card{ 如果我们能够在不会T掉的时间内处理出所有字符串的出现位置, 这个问题就可以直接变成选区间问题, 从而应用双指针或其他算法解决。但我考场一想, 这个玩意不是$O(n^2)$级的么, 根本不可能。然而事实上远远不到这个级别, 考虑按长度分组, 去重后每个长度显然至多会有$O(n)$级的匹配数, 由于总长度给定, 不同长度的数量至多有$O(\\sqrt{n})$种, 所以是$O(n\\sqrt{n})$的。 算法1: 字符串hash + 双指针基于上述复杂度证明, 我们可以采用子串hash与hash表直接得到一个$O(n\\sqrt{m} + m)$的多模式串匹配算法, 其中$m$为模式串总长度。具体做法是去重后按长度分组, 扫描前把这个长度的字符串的hash值插入hash表, 然后匹配即可。所以问题转化为: 在长为m的直线上有n种区间, 求直线覆盖所有n种区间的最短线段 做法有很多, 我的做法是开两个vector记录区间起点与终点：如果左指针扫到了一个起点, 那么对应种类的计数直接减一(其中可能会有当前右指针尚未扫到这个区间的终点, 导致计数器变成负数的情况, 不过不要紧); 如果右指针扫到了一个终点, 计数器直接加一, 如果计数器当前为负数, 就相当于”还上了之前欠的债”。每个区间被选上的条件是它自己的出现计数器大于等于$1$。对每个左指针让右指针一直往右扫, 直到当前选上了全部的区间。 算法2: AC自动机/后缀平衡树 + 二叉堆我还不会, 待更。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define rint register int#define ull unsigned long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define lint long long#define eco(c) ((int)(c) - 3)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;const ull base = 131;const int htmod = 5000087;struct mhash_set&#123; static const int maxnode = htmod + 2; int head[maxnode], nxt[2 * maxn], id[2 * maxn], totnode; int s[2 * maxn], stop; ull val[2 * maxn]; void clear() &#123; totnode = 0; while(stop) head[s[stop--]] = 0; &#125; void insert(ull x, int nid) &#123; int pos = x % htmod; s[++stop] = pos; val[++totnode] = x, id[totnode] = nid; nxt[totnode] = head[pos], head[pos] = totnode; &#125; int find(ull x) &#123; int pos = x % htmod; for(rint i=head[pos]; i; i=nxt[i]) &#123; if(val[i] == x) return id[i]; &#125; return 0; &#125;&#125;ht;ull calc_hash(const char s[], int len) &#123; ull res = 0; for(rint i=1; i&lt;=len; i++) res = res * base + eco(s[i]); return res;&#125;int n, m;ull prehash[maxn], basepow[maxn];char s1[maxn], temp[maxn];// 第一维编号， 第二维1表示开始，-1表示结束struct str&#123; ull x; int len; str() &#123;&#125; str(ull xx, int ll): x(xx), len(ll) &#123;&#125; bool operator &lt; (const str&amp; b) const &#123; return len &lt; b.len; &#125;&#125;s2[maxn];inline ull calc_hash(int L, int R) &#123; return prehash[R] - prehash[L - 1] * basepow[R - L + 1];&#125;void match(int len) &#123; for(rint i=1; i+len-1&lt;=m; i++) &#123; ull res = calc_hash(i, i + len - 1); int nid = ht.find(res); if(nid != 0) &#123; st[i].push_back(nid), ed[i + len - 1].push_back(nid); &#125; &#125;&#125;vector&lt;int&gt; st[maxn], ed[maxn];int cnt_color[maxn], cnt = 0;int ans_len, ans_l, ans_r;inline void update(int c, int x) &#123; int pre = (cnt_color[c] &gt;= 1); cnt_color[c] += x; cnt += (cnt_color[c] &gt;= 1) - pre;&#125;void solve() &#123; ans_len = m; for(rint i=1, j=0; i&lt;=m; i++) &#123; while(j &lt;= m &amp;&amp; cnt &lt; n) &#123; j++; for(rint k=0; k&lt;ed[j].size(); k++) update(ed[j][k], 1); &#125; if(j &gt; m) return; if(j - i + 1 &lt; ans_len) &#123; ans_len = j - i + 1, ans_l = i, ans_r = j; &#125; for(rint k=0; k&lt;st[i].size(); k++) update(st[i][k], -1); &#125;&#125;int main() &#123; basepow[0] = 1; scanf(\"%s\", s1+1), m = strlen(s1 + 1); for(rint i=1; i&lt;=m; i++) &#123; basepow[i] = basepow[i-1] * base; prehash[i] = prehash[i-1] * base + eco(s1[i]); &#125; readint(n); int tot = 0; for(rint i=1; i&lt;=n; i++) &#123; scanf(\"%s\", temp+1); int len = strlen(temp + 1); ull res = calc_hash(temp, len); if(!ht.find(res)) &#123; s2[++tot] = str(res, len), ht.insert(res, i); &#125; &#125; n = tot; sort(s2+1, s2+n+1); for(rint i=1; i&lt;=n; i++) &#123; int l = i, r = i; while(r &lt;= n &amp;&amp; s2[r].len == s2[l].len) r++; i = --r; ht.clear(); for(rint j=l; j&lt;=r; j++) ht.insert(s2[j].x, j); match(s2[l].len); &#125; solve(); for(rint i=ans_l; i&lt;=ans_r; i++) putchar(s1[i]); puts(\"\"); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://arintaro.com/tags/字符串/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://arintaro.com/tags/字符串匹配/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"}]},{"title":"Luogu P1121 环状最大两段子段和","slug":"Answer/sum","date":"2019-10-24T13:24:25.109Z","updated":"2019-10-24T14:09:04.321Z","comments":true,"path":"2019/10/24/Answer/sum/","link":"","permalink":"http://arintaro.com/2019/10/24/Answer/sum/","excerpt":"大概特判才是主要难点(","text":"大概特判才是主要难点( Description:@card{ 给定一个环状序列, 可以选其中两段连续不相交的子段, 求它们的最大和 } Solution:@card{ 对于这种”两段”问题的处理, 一般有两种方法：第一种是枚举切点, 用前后两段的”一段”的最优去组合答案；第二种是在DP状态内记录当前选了几段, 从而进行转移。 算法1: 枚举切点, 正难则反考虑序列上怎么做, 显然可以枚举切点用前后两段的最大子段和组合答案。顺着想到可以破环成链跑类似的算法, 然而可能前后两段的长度加起来超过$n$, 从而使答案变大, 这里可以用数据结构维护不同长度的答案(eg. 可持久化平衡树), 然而无论怎么样, 复杂度都会多个$log$。 考虑在序列上跑完遗落了什么情况, 显然是前后两段接到一起和中间的一段组成答案, 发现这其实在序列上体现为三段, 这三段又分出来了两段, 最优解中这两段之和显然是最小的, 那么用总和减去”序列上最小两段子段和”, 一定能覆盖这种情况。 然而到这里还远没有结束, 考虑边界情况, 第一种情况只要我们枚举的”两个数之间的断点”在序列中间, 前后两段加起来至少会有两个数字, 因此是没有问题的。但是第二种情况, 我们求出的”序列上最小两段子段和”的长度$len &gt; n-2$的话, 求出来的解就是没有意义的, 由于特判范围较小, 考虑进行讨论。当$len = n$时, 显然序列中必然全是负数, 否则我们在一个正数两边切点就能得到更小的解; 当$len = n-1$时, 我们用来更新答案的值必然是序列中最大的正数, 如果存在另外一个正数, 那么第一种情况一定会比第二种情况求出的答案优秀, 不影响答案, 如果不存在另外一个正数, 那么序列中有且仅有一个正数, 我们显然可以直接得到答案。 综上, 当序列中正数只有$0$个或$1$个时, 答案为序列中的最大值加次小值, 否则可以应用我们上述的算法, 正确求出答案。 算法2: 动态规划, 一次断开, 一次强制连接考虑序列上怎么做, 显然我们可以在状态内记录当前选了几个, 以及上个选没选(其实记录上个选没选可以理解为一种小范围的状态压缩去解决一定的后效性)来转移。如果破环成链势必又面临维护麻烦的长度限制的问题, 所以考虑强制连接。 强制连接后前后两个视为一段, 在中间找第三段即可, 即求出不强制连接时的两段答案, 和强制连接后的三段答案就可覆盖所有情况。 这种方法常数不太好, 但是不用考虑麻烦的边界情况, 是考场比较优秀的算法。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2e5 + 10;const int inf = 2e9 + 10;int n;int arr[maxn], cnt = 0;int ans = -inf, sum, max1 = -inf, max2 = -inf;int presum[maxn], sufsum[maxn];void calc() &#123; for(rint i=1; i&lt;=n; i++) presum[i] = max(presum[i-1], 0) + arr[i]; for(rint i=n; i&gt;=1; i--) sufsum[i] = max(sufsum[i+1], 0) + arr[i]; for(rint i=2; i&lt;=n; i++) presum[i] = max(presum[i-1], presum[i]); for(rint i=n-1; i&gt;=1; i--) sufsum[i] = max(sufsum[i+1], sufsum[i]); &#125;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(arr[i]), sum += arr[i]; if(arr[i] &gt;= 0) cnt++; &#125; for(rint i=1; i&lt;=n; i++) &#123; if(arr[i] &gt;= max1) max2 = max1, max1 = arr[i]; else if(arr[i] &gt; max2) max2 = arr[i]; &#125; ans = max1 + max2; if(cnt &lt; 2) &#123; cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; calc(); for(rint i=1; i&lt;=n-1; i++) ans = max(ans, presum[i] + sufsum[i+1]); for(rint i=1; i&lt;=n; i++) arr[i] = -arr[i]; calc(); for(rint i=1; i&lt;=n-1; i++) ans = max(ans, sum + presum[i] + sufsum[i+1]); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"经典模型","slug":"经典模型","permalink":"http://arintaro.com/tags/经典模型/"},{"name":"正难则反","slug":"正难则反","permalink":"http://arintaro.com/tags/正难则反/"},{"name":"两段处理","slug":"两段处理","permalink":"http://arintaro.com/tags/两段处理/"},{"name":"环形处理","slug":"环形处理","permalink":"http://arintaro.com/tags/环形处理/"}]},{"title":"Luogu P1654 OSU!","slug":"Answer/osu","date":"2019-10-24T05:40:42.504Z","updated":"2019-10-30T08:28:01.841Z","comments":true,"path":"2019/10/24/Answer/osu/","link":"","permalink":"http://arintaro.com/2019/10/24/Answer/osu/","excerpt":"感觉期望还是比较冷门的考察方向","text":"感觉期望还是比较冷门的考察方向 Description:@card{ 给定一个$n$个位置, 每个位置有$p_i$的概率为$1$, 否则为0, 每一段极大连续的$1$会产生长度的三次方的分数, 求分数的期望值 } Solution:@card{ 考虑逐个把1加入计算贡献, 不妨假设前$i-1$个位置的得分期望已经正确求出,。当该位为0时, 显然答案直接累加$i-1$的即可；当该位为1时, 会增大所有”后缀连续1”的贡献, 而对其他贡献没有影响: 对于一个长度在这之前已经为$x$的后缀1段, 增大的贡献显然为$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$, 对于所有这样的串考虑显然只需要代入期望值即可, 所以需要分别维护后缀长度平方的期望和后缀长度的期望。 注意后缀长度平方的期望不能直接由后缀长度的期望直接平方得到, 因为它自身显然是不独立的, 不能直接用期望的乘法性质, 乘法要求两个随机变量相互独立。则有: $$E(A^3_n) = p_i (E(A^3_n-1) + 3E(B^2_n-1) + 3E(B_n-1) + 1) + (1 - p_i) E(A^3_n-1)$$$$E(B^2_n) = p_i (E(B^2_n-1) + 2E(B_n-1) + 1) + (1 - p_i) \\times 0$$$$E(B_n) = p_i(E(B_n-1) + 1) + (1 - p_i) \\times 0$$ Luogu上的题解也有很多从另外的角度思考了, 复习的时候可以看一下：https://www.luogu.org/problemnew/solution/P1654} Code:@card{ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define ldob long double#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n;ldob EA3[maxn], EB1[maxn], EB2[maxn], p[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; scanf(\"%Lf\", &amp;p[i]); EB1[i] = p[i] * (EB1[i-1] + 1) + (1 - p[i]) * 0; EB2[i] = p[i] * (EB2[i-1] + 2 * EB1[i-1] + 1) + (1 - p[i]) * 0; EA3[i] = p[i] * (EA3[i-1] + 3 * EB2[i-1] + 3 * EB1[i-1] + 1) + (1 - p[i]) * EA3[i-1]; &#125; printf(\"%.1Lf\\n\", EA3[n]); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"题解","slug":"Luogu/题解","permalink":"http://arintaro.com/categories/Luogu/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"递推","slug":"递推","permalink":"http://arintaro.com/tags/递推/"},{"name":"期望","slug":"期望","permalink":"http://arintaro.com/tags/期望/"}]},{"title":"NOIP2013 花匠","slug":"Answer/flower","date":"2019-10-23T11:53:29.869Z","updated":"2019-11-01T00:02:57.951Z","comments":true,"path":"2019/10/23/Answer/flower/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/flower/","excerpt":"与黄题斗智斗勇","text":"与黄题斗智斗勇 Description:@card{ 求一个整数序列的最长波峰序列, 详见https://www.luogu.org/problem/P1970 } Solution:@card{ 这个题思路没什么难的, 主要是实现细节与边界处理。 做法显然是划分出每个单调递增单调递减的子段, 选上峰点和开头结尾即可。 问题在于其中会有相等的数字, 对于一个区间内的很好处理, 相等是不影响当前区间的单调性的。然而我们在设初值时, 会设为$a[1], a[2]$的关系, 我一开始没有考虑$a[1]$, $a[i]$相等了该怎么办。另外, 当$n=1$和$n = 2 and a[1] == a[2]$时, “选上开头结尾”是无法做到的, 需要特判。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, ans = 2;int arr[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) readint(arr[i]); if(n == 1) cout &lt;&lt; 1 &lt;&lt; endl; else if(n == 2) cout &lt;&lt; 1 + (arr[2] != arr[1]) &lt;&lt; endl; else &#123; int x = -1; for(rint i=2; i&lt;=n; i++) &#123; if(arr[i] == arr[i-1]) continue; if(x == -1) x = (arr[i] &gt; arr[i-1]); else if((arr[i] &gt; arr[i-1]) != x) ans++, x ^= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"边界处理","slug":"边界处理","permalink":"http://arintaro.com/tags/边界处理/"}]},{"title":"NOIP2010 观光公交","slug":"Answer/bus","date":"2019-10-23T09:33:02.040Z","updated":"2019-11-01T00:02:51.743Z","comments":true,"path":"2019/10/23/Answer/bus/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/bus/","excerpt":"你以为我是DP,其实我是贪心啦dio","text":"你以为我是DP,其实我是贪心啦dio Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1315要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。 } Solution:@card{ 对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。 接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(事实上远远跑不到); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。 我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(这两个名词都是我瞎编的) 算法1：贪心直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。 同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。 算法2：优化后的贪心发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(然而并没有), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。 算法3: 数据结构优化贪心考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int inf = 1e9;int n, m, k;int cnt[maxn], leave[maxn], arrive[maxn], w[maxn];lint sum[maxn];int main() &#123; readint(n), readint(m), readint(k); for(rint i=2; i&lt;=n; i++) readint(w[i]); for(rint i=1; i&lt;=m; i++) &#123; int t, st, ed; readint(t), readint(st), readint(ed); cnt[ed]++, sum[ed] += t; leave[st] = max(leave[st], t); &#125; for(rint i=2; i&lt;=n; i++) arrive[i] = max(arrive[i-1], leave[i-1]) + w[i]; while(k != 0) &#123; int res_st = 0, res_ed = 0, res_w = 0, res_cnt = 0; for(rint i=2; i&lt;=n; ) &#123; if(w[i] == 0) &#123; i++; continue; &#125; int now_w = min(w[i], k), now_cnt = 0; rint j = i; for(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123; now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]); &#125; now_cnt += cnt[j]; if(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt; i = j + 1; &#125; if(res_w == 0) break; w[res_st] -= res_w, k -= res_w; for(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w; &#125; lint ans = 0; for(rint i=1; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"迭代","slug":"迭代","permalink":"http://arintaro.com/tags/迭代/"}]},{"title":"NOIP2009 道路游戏","slug":"Answer/road","date":"2019-10-23T02:52:08.757Z","updated":"2019-11-01T00:02:46.515Z","comments":true,"path":"2019/10/23/Answer/road/","link":"","permalink":"http://arintaro.com/2019/10/23/Answer/road/","excerpt":"千万不要以为普及组都是水题","text":"千万不要以为普及组都是水题 Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1070要点: 在任意时间必须有且仅有一个机器人,可以赔钱 } Solution:@card{ 分析一下思路,发现有明显的时间顺序,又是一个最优化问题,可以确定是动态规划。费用比较奇怪,题面描述是个边权,不过我们显然可以下放到到点上,比如$1 -&gt; 2 -&gt; 3$,从1走两次到3,累加了两段路上金币,可以发现从$i$走$p$次就是累加$[i, i + x - 1]$的金币。手玩一下可以发现只要对费用矩阵斜着求前缀和即可。由于是环形问题,为了方便最好把行上的编号重编至$[0, n-1]$。如果沿用$[1, n]$, 需要在每次”可能越界前”,先把编号-1取模再+1映射回来。 算法1：暴力DP题里没什么影响决策的限制条件,记录时间即可,转移显然需要枚举出发点和走多远,稍微算下复杂度$O(nmp)$。期望得分90pts, 实际得分100pts 算法2：转移优化DP由于给了较多的部分分,我们可以相信这与正解已经相差不远,所以先考虑转移优化,而不是状态优化。 这种求前缀和的分段转移模型,一般写出”我从哪里来”形式的方程,显然我们有: $$dp[i] = min{dp[j] + sum[x][i] - sum[(x - (i - j)) mod n][j] - val[(x - (i - j) + 1) mod n] } ( i - p &lt;= j &lt;= i - 1) $$ 注意一个细节, 序列上的”前缀和”求$[l, r]$的和时需要用$sum[r] - sum[l - 1]$,在方程中体现的是”出发点事实上是$x + 1$”。另外具体实现时,由于涉及到模意义下的减法,尽量加模数后再取模防止负数。 决策变量两维, 发现$n^2$可以接受, 考虑先枚举一维, 涉及$x$的量较多, 考虑先确定$x$, 略去$mod n$后 $$dp[i] = min{dp[j] - sum[x - (i - j)][j] - val[x - (i - j) + 1] } + sum[x][i] ( i - p &lt;= j &lt;= i - 1)$$ 可以发现与常规的优化DP不同, 一个决策$j$的价值可能与$x, i$有关,使得我们无法高效的维护决策集合,如果我们能使得$j$的价值与$x, i$无关,就可以用单调队列或平衡树等数据结构直接维护价值,每次直接转移,而不需要在得到$x, i$后对决策集合中的每个决策重新计算价值。 把确定的变量$x, i$整理到一起后, 发现内层价值数组中的下标只与$x - i$有关, 而在$mod n$意义下$x - i$的值显然至多只有$n$种,从多重背包在剩余系下的优化转移得到启发,我们可以按其在剩余系的模数分类,开$n$个不同的决策集合,这样对于决策$j$来讲关于$x - i$的部分即可化为定值。限制条件中上界下界单调递增, 显然可以用单调队列把转移的时间摊到$O(1)$ 从实际含义上讲,这对应了在费用矩阵上不同的”斜列”转移(即我们斜着求前缀和的$n$个不同序列), 每次内层$x$增加时, 对应在不同斜列上的移动。 此题启发我们可以对决策集合进行”分类”, 从而消除状态变量对一个决策价值的影响。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define eco(x) ((x) % n == 0 ? n : (x) % n)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;int n, m, p;int id[maxn][maxn], w[maxn][maxn], c[maxn];int dp[maxn], ql[maxn], qr[maxn];pii mq[maxn][maxn];int main() &#123; memset(dp, 0xc0, sizeof(dp)); readint(n), readint(m), readint(p); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(w[i][j]); &#125; &#125; for(rint i=1; i&lt;=n; i++) readint(c[i]); for(rint j=1; j&lt;=m; j++) &#123; for(rint i=1; i&lt;=n; i++) &#123; w[i][j] += w[eco(i-1)][j-1]; &#125; &#125; for(rint i=1; i&lt;=n; i++) &#123; int x = i, y = 1; ql[i] = 1, qr[i] = 1; mq[i][1] = mp(-c[i], 0); while(y &lt;= m) &#123; id[x][y] = i; x = eco(x + 1), y++; &#125; &#125; dp[0] = 0; for(rint t=1; t&lt;=m; t++) &#123; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; t - q[l].second &gt; p) l++; dp[t] = max(dp[t], w[x][t] + q[l].first); &#125; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; q[r].first &lt; dp[t] - w[x][t] - c[eco(x+1)]) r--; q[++r] = mp(dp[t] - w[x][t] - c[eco(x+1)], t); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"环形处理","slug":"环形处理","permalink":"http://arintaro.com/tags/环形处理/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"单调队列","slug":"单调队列","permalink":"http://arintaro.com/tags/单调队列/"}]},{"title":"基础数学总结","slug":"Algorithm/基础数学总结","date":"2019-09-25T07:56:33.502Z","updated":"2019-10-01T06:52:50.957Z","comments":true,"path":"2019/09/25/Algorithm/基础数学总结/","link":"","permalink":"http://arintaro.com/2019/09/25/Algorithm/基础数学总结/","excerpt":"","text":"一、数论@card{ (一) 质数与因子相关1.对于一个足够大的整数N，不超过N的质数大约有$\\frac{N}{ln(n)}$个2.一个数至少有一个小于$\\sqrt{n}$的因子，至多存在一个超过$\\sqrt{n}$的因子，因此不少算法可以只跑到$\\sqrt{n}​$3.埃筛(1) 每个数从$x^2​$开始筛即可 (2) 用$\\sqrt{r}$内的数就可以对$[l, r]$进行区间筛 4.线筛(1) 通过“积累最小质因子”的方法，去除合数 5.质因数分解(1) 不少题可以通过算术基本定理找出想法 (2) 试除法最后需要特判剩下来个大于$\\sqrt{n}$的质数的情况 (3) 有时候也可以反过来统计，不考虑它有什么因子，而是考虑“每个因子有多少个”，阶乘快速分解和倍数法基于此思想 } @card{ (二) 同余、取模相关1.不少模非质数的题目，需要对模数分解成质因子，最后用CRT/EXCTR合并答案}","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"数学","slug":"算法/数学","permalink":"http://arintaro.com/categories/算法/数学/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"}]},{"title":"基础数论","slug":"Template/基础算法/base","date":"2019-09-23T13:41:18.234Z","updated":"2019-10-28T14:06:53.665Z","comments":true,"path":"2019/09/23/Template/基础算法/base/","link":"","permalink":"http://arintaro.com/2019/09/23/Template/基础算法/base/","excerpt":"","text":"1.归并排序求逆序对@card{ $Test Site:$ https://www.acwing.com/problem/content/109/ $Code:$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e5 + 10;// 9 1 0 5 4int n;lint ans = 0;int arr[maxn], temp[maxn];void msort(int l, int r) &#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; msort(l, mid), msort(mid+1, r); // 在后面还小 for(rint i=l, j=mid+1, p=l; p&lt;=r; p++) &#123; // 一定要讨论选完的情况 if(j &gt; r || i &lt;= mid &amp;&amp; arr[i] &lt;= arr[j]) temp[p] = arr[i++]; else temp[p] = arr[j++], ans += mid - i + 1; &#125; for(rint i=l; i&lt;=r; i++) arr[i] = temp[i];&#125;int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; ans = 0; for(rint i=1; i&lt;=n; i++) readint(arr[i]); msort(1, n); printf(\"%lld\\n\", ans); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"}]},{"title":"小型冷门知识点汇总","slug":"Algorithm/小型冷门知识点汇总","date":"2019-04-28T06:06:16.512Z","updated":"2019-11-08T01:49:32.252Z","comments":true,"path":"2019/04/28/Algorithm/小型冷门知识点汇总/","link":"","permalink":"http://arintaro.com/2019/04/28/Algorithm/小型冷门知识点汇总/","excerpt":"","text":"一、图论@card{ 1. Johnson 算法 /原始对偶算法 $site:$ https://zhuanlan.zhihu.com/p/48523094、https://www.cnblogs.com/tkandi/p/10532774.html 用途：用下界$O(NM)$的时间跑一遍$SPFA$消除图内所有负权边，用以之后跑$DJ$的全源最短路径或者跑费用流。适用于需要多次求最短路的问题，有时候甚至可以带来级 } 二、杂项@card{ 1. 01串的字典序排名与它的值相同}","categories":[],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"}]},{"title":"EX数据结构","slug":"Template/数据结构/ex","date":"2019-04-28T02:46:22.952Z","updated":"2019-10-28T14:07:02.441Z","comments":true,"path":"2019/04/28/Template/数据结构/ex/","link":"","permalink":"http://arintaro.com/2019/04/28/Template/数据结构/ex/","excerpt":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。","text":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。 EX堆-配对堆@card{ 请不要对我抱有会写斐波那契堆的期望。 $test\\ site: $&lt; https://lydsy.com/JudgeOnline/problem.php?id=3040&gt; $task:$ 实现配对堆完成最短路，每次$push$输入节点编号，$top$返回最短点的节点编号，注意空间要求$O(n)$，也就是说您要实现一个内存池。 $note: $维护这种多重编号映射，一定要列表需要维护的东西 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pii pair&lt;int, int&gt;template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000000 + 10;const int maxm = 10000000 + 10;const int inf = 0x7f7f7f7f;lint dist[maxn];struct Heap&#123;&#125;q;int n, m, s;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;void calc_sp() &#123; memset(dist, 0x7f, sizeof(lint) * (n+1)); dist[s] = 0, q.push(s); while(!q.empty()) &#123; int x = q.top(); q.pop(); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &gt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; q.update(y); &#125; &#125; &#125;&#125;int main() &#123; int T, nu, nv, nw; lint x = 0, y = 0, a, b; lint rxa, rxc, rya, ryc, rp; readint(n), readint(m), s = 1; readint(T), readint(rxa), readint(rxc), readint(rya), readint(ryc), readint(rp); while(T--) &#123; x=(x*rxa+rxc)%rp; y=(y*rya+ryc)%rp; a=min(x%n+1,y%n+1); b=max(y%n+1,y%n+1); addedge(a, b, 1e8 - 100 * a); &#125; while(m--) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); &#125; calc_sp(); printf(\"%lld\\n\", dist[n]); return 0;&#125; } 2.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/categories/数据结构/"}],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"新科技","slug":"新科技","permalink":"http://arintaro.com/tags/新科技/"}]},{"title":"基础图论模板","slug":"Template/图论/基础图论","date":"2019-04-27T13:23:23.969Z","updated":"2019-05-08T08:04:19.163Z","comments":true,"path":"2019/04/27/Template/图论/基础图论/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/图论/基础图论/","excerpt":"需要$3min$内实现任意一个","text":"需要$3min$内实现任意一个 负环的判定@card{ $test\\ site: $https://www.luogu.org/problemnew/show/P3385 $task: $ 600ms以内判定负环，请注意，有多组数据，要求实现clear函数（包括邻接表 $tips: $ 对于$O(NM)$能跑过去复杂度正确的，建议写$BFS_SPFA + SLF_SWAP$，复杂度不对的写$DFS$ $extra:?$?”同时记录节点入队次数”、”卡时” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int arr[maxn]; int l, r, size; inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125; inline void push(int x) &#123; if(r == size) r = 0; arr[++r] = x; &#125; inline int pop() &#123; if(l == size) &#123;l = 1; return arr[size]; &#125; return arr[l++]; &#125; inline bool empty() &#123; return l == r + 1; &#125;&#125;q;void clear() &#123; &#125;bool check() &#123; &#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? &quot;YE5&quot; : &quot;N0&quot;); &#125; return 0;&#125; } 邻接表的删除操作card{ 可以维护一个删除标记，但是这么做在有些算法里会导致复杂度(空间or时间)退化，具体测试可以去写即时删除的配对堆。 显然我们可以再维护一个$pre$域，像普通链表一样删除，但是过于麻烦，我们可以直接把这条边的数据与表头交换，然后让表头指向下一个，但是这么做会导致边序号乱序，需要注意成对变换等对边序号有要求的信息。 } SPFA求最长路card{ 我们经常写$DJ$，也经常写最短路，但是最长路+$SPFA$我第一次写的时候却挂了。。 $test\\ stie: $ https://www.acwing.com/activity/content/code/content/34854/ $task:$ 实现循环队列，初始化$dist[1] = 0$，求最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair(x, y)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * (maxn + maxn);int n, max_val;int dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int q[maxn]; int l, r, size;&#125;q;void calc_sp() &#123; &#125;int main() &#123; int nu, nv, nw; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); nu += 1, nv += 2; // 节点编号[1, 50002] addedge(nu, nv, nw); max_val = max(max_val, max(nu, nv)); &#125; for(rint i=1; i&lt;=max_val-1; i++) addedge(i, i+1, 0), addedge(i+1, i, -1); calc_sp(); printf(\"%d\\n\", dist[max_val] - dist[1]); return 0;&#125; } 无向图的割边card{ $test\\ site: $https://www.acwing.com/problem/content/365/ $task: $实现判断割边，处理出搜索树的$deep$，$fa$数组，并在割边的子节点上标记$val[y] = 1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * 2 * maxn;int n, m, root = 1;int ans = 0;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int dfn[maxn], low[maxn], tot = 0;int deep[maxn], val[maxn], fa[maxn];void dfs(int x, int ind) &#123; low[x] = dfn[x] = ++tot; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == ind) continue; if(!dfn[y]) &#123; deep[y] = deep[x] + 1, fa[y] = x, dfs(y, i ^ 1); low[x] = min(low[x], low[y]); if(low[y] &gt; dfn[x]) val[y] = 1, ans++; &#125;else low[x] = min(low[x], dfn[y]); &#125;&#125;void clear() &#123; ans = tot = 0, totedge = 1; memset(head, 0, sizeof(int) * (n+1)); memset(dfn, 0, sizeof(int) * (n+1)); memset(val, 0, sizeof(int) * (n+1));&#125;int mem[maxn];void ask(int x, int y) &#123; int res = 0, s = 0; if(deep[x] &lt; deep[y]) swap(x, y); while(deep[x] &gt; deep[y]) &#123; mem[++s] = x, x = fa[x]; &#125; while(x != y) &#123; mem[++s] = x, mem[++s] = y; x = fa[x], y = fa[y]; &#125; for(rint i=1; i&lt;=s; i++) &#123; res += val[mem[i]], val[mem[i]] = 0; fa[mem[i]] = x; &#125; ans -= res;&#125;int main() &#123; int T = 0; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; clear(); printf(\"Case %d:\\n\", ++T); while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(root, 0); readint(m); while(m--) &#123; readint(nu), readint(nv); ask(nu, nv); printf(\"%d\\n\", ans); &#125; puts(\"\"); &#125; return 0;&#125; $Solution:$ 注意父节点来的边不能更新，具体用成对变换实现，割点不用记录，都能更新，但是要注意，按照常规割点定义，根节点必须有俩儿子“大于等于”，才能判断是，割边则是“大于”。 } 无向图的$v-dcc$缩点 + 二分图判定@card{ $test\\ site:​$ https://www.acwing.com/problem/content/367/ $task:$ 划分出图中的每个$vdcc$，并判定其是否是二分图（是否存在奇环），是的话将其每个节点的$suc$值设为$1$，并实现多组数据的清空函数 $note:$ 现用现标记，解决割点重叠问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e6 + 4 * maxn;int n, m;int edge[maxn][maxn];int head[maxn], nxt[maxm], ev[maxm], totedge = 1;inline void addedge(int x, int y) &#123; ev[++totedge] = y, nxt[totedge] = head[x], head[x] = totedge;&#125;int main() &#123; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; while(m--) readint(nu), readint(nv), edge[nu][nv] = edge[nv][nu] = 1; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=i+1; j&lt;=n; j++) &#123; // 虽然在完全图上用邻接表十分弱智,但可以降低常数 if(!edge[i][j]) addedge(i, j), addedge(j, i); &#125; &#125; int ans = 0; for(rint i=1; i&lt;=n; i++) ans += (suc[i] == 0); printf(\"%d\\n\", ans); clear(); &#125; return 0;&#125; } 欧拉回路的具体方案 $test\\ site:$ https://www.acwing.com/problem/content/368/ $task:$ 寻找一个从$1$出发，遍历所有边两次的具体方案，保证有解。 $tips:$ 注意入栈方法的实际含义。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e4 + 10;const int maxm = 1e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans[maxm], tot = 0;int s[maxm], top = 0;void solve() &#123; &#125;int main() &#123; int nu, nv; readint(n), readint(m); while(m--) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu); solve(); for(rint i=1; i&lt;=tot; i++) printf(\"%d\\n\",ans[i]); return 0;&#125; 7.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"基础数据结构","slug":"Template/数据结构/base","date":"2019-04-27T12:44:23.105Z","updated":"2019-10-28T14:06:59.668Z","comments":true,"path":"2019/04/27/Template/数据结构/base/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/数据结构/base/","excerpt":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。","text":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。 循环队列@card{ $test \\ site:$https://www.luogu.org/problemnew/show/P3385 $task:$实现一个循环队列，要求有$empty \\ \\ push\\ init(O(1))\\ \\ pop\\ \\ front $ $note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// test site: https://www.luogu.org/problemnew/show/P3385// task: 实现一个循环队列，要求有empty push init(O(1)) pop front // note: 一般用于需要多次清空队列且已知\"队列里同时存在的最多元素数量\"，// 比起STL的queue，手写的可以O(1)清空。 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; &#125;q;int cnt_path[maxn], dist[maxn];bool inq[maxn];void clear() &#123; totedge = 0; q.init(); memset(head, 0, sizeof(int) * (n+1)); memset(inq, 0, sizeof(bool) * (n+1)); memset(cnt_path, 0, sizeof(int) * (n+1)); memset(dist, 0x3f, sizeof(int) * (n+1));&#125;bool check() &#123; q.push(start), dist[start] = 0; while(!q.empty()) &#123; int x = q.pop(); inq[x] = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[x] + ew[i] &lt; dist[y]) &#123; dist[y] = dist[x] + ew[i]; cnt_path[y] = cnt_path[x] + 1; if(cnt_path[y] &gt; n) return 1; if(!inq[y]) q.push(y), inq[y] = 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? \"YE5\" : \"N0\"); &#125; return 0;&#125; $Solution:$ 懒得写了，自己看代码吧 } 2.#### 整数hash表@card{ $Test Site:https://www.luogu.org/problem/CF670C $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pll pair&lt;lint, lint&gt;#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 200000 * 3 + 10;const int mod = 599899;int arr[maxn];int n, m, totid;struct mhash&#123; int head[maxn], nxt[maxn], eco[maxn], tot; int pre[maxn], suf[maxn]; int find(int x) &#123; int nu = x % mod + 1; //别忘了+1 for(rint i=head[nu]; i; i=nxt[i]) &#123; if(pre[i] == x) return suf[i]; &#125; return 0; &#125; void insert(int x, int y) &#123; int nu = x % mod + 1; nxt[++tot] = head[nu], head[nu] = tot, pre[tot] = x, suf[tot] = y; &#125;&#125;ht;int ry[maxn], dz[maxn], dy[maxn];int cnt[maxn];int ansid = 1, ansy = -1, ansz = -1;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(ry[i]); int t = ht.find(ry[i]); if(t == 0) t = ++totid, ht.insert(ry[i], t); cnt[t]++; &#125; readint(m); for(rint i=1; i&lt;=m; i++) readint(dy[i]), dy[i] = ht.find(dy[i]); for(rint i=1; i&lt;=m; i++) readint(dz[i]), dz[i] = ht.find(dz[i]); for(rint i=1; i&lt;=m; i++) &#123; if(cnt[dy[i]] &gt; ansy || (cnt[dy[i]] == ansy &amp;&amp; cnt[dz[i]] &gt; ansz)) ansid = i, ansy = cnt[dy[i]], ansz = cnt[dz[i]]; &#125; printf(\"%d\\n\", ansid); return 0;&#125; }3.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数据结构","slug":"模板/数据结构","permalink":"http://arintaro.com/categories/模板/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://arintaro.com/tags/队列/"}]},{"title":"LNOI2019 & 多省联考 游记","slug":"Essay/LNOI2019 & 多省联考 游记","date":"2019-04-27T09:01:25.797Z","updated":"2019-04-27T13:03:09.425Z","comments":true,"path":"2019/04/27/Essay/LNOI2019 & 多省联考 游记/","link":"","permalink":"http://arintaro.com/2019/04/27/Essay/LNOI2019 & 多省联考 游记/","excerpt":"","text":"Day1:待更，鸽了","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"无病呻吟","slug":"无病呻吟","permalink":"http://arintaro.com/tags/无病呻吟/"}]},{"title":"综合技巧与实践","slug":"Detail/综合技巧与实践","date":"2019-04-27T09:01:25.547Z","updated":"2019-10-29T02:43:20.285Z","comments":true,"path":"2019/04/27/Detail/综合技巧与实践/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/综合技巧与实践/","excerpt":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。","text":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。 一、STL相关@card{ 1.algorithm1234567891011121314151.lower_bound &amp; upper_bound //我就算饿死，死外面，也不会自己写一个二分查找的 int pos = lower_bound(arr+1,arr+n+1,val) - arr; //在有序数组[1,n]中查第一个 &gt;=val的数 // 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater2.unique //常用于离散化 n = unique(arr+1,arr+n+1) - (arr+1); //去重，新元素存在[1,n] 3.inplace_merge merge // 常用于CDQ分治中，不要cdq里套sort了！！ // 数组 arr分为有序的两部分 [1,mid] [mid+1,n] inplace_merge(arr+1,arr+mid+1,arr+n+1); merge(first1,last1,first2,last2,result,compare);4.nth_element //数组中O(n)找第k大，前k个数一定都在[1，k], 内部不一定有序 nth_element(arr+1,arr+k,arr+n+1);5.sort stable_sort // 后一个可以稳定排序 6.reverse // 跟sort传参一样，序列反转 7.next_permutation, prev_permutation //排列8.partial_sort // nth_element加强版, O(nlogk)排序前k个数, [1, k]内一定有序 2.vector121.vector的clear不会释放空间，需要释放空间的话，需要: vector&lt;int&gt;().swap(a); // 但是几乎比clear慢一倍 3.输入输出相关11.cin.getline(s+1, len+1, '\\0'); // 字符数组、长度、结束字符 4.cmath11.round(double x); // 返回四舍五入的整数 %.0lf也可以 5.其他1231.fill(begin, end, val); // 填充数组long long arr[maxn][maxn];fill(arr[0], arr[0]+maxn*maxn, inf); } 二、NOI Linux相关@card{ ​ 1.Emacs相关（M为Alt键，C为Ctrl键 - M+x输入命令 C+x+k关闭当前窗口 - Options-Use CUA Keys (转换复制粘贴快捷键) - Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题） - Options-Set Default Font - Ubuntu Mono 20-30（变更字体 - C-x-2 水平切分当前Buffer, C-x-3 左右切分 - M-% 替换 - C-R 查找 - 命令 Find-file后， ~/.emacs 可以直接打开配置文件 123456789101112131415161718192021(global-linum-mode t) ;;line num 显示行号(setq c-basic-offset 3) ;; 变更缩进(setq default-tab-width 3) (electric-pair-mode t) ;;electric pair 括号补全(electric-layout-mode t)(electric-indent-mode t)(setq-default cursor-type 'bar) ;;光标竖线(show-paren-mode t) ;;show paren 括号配对(global-set-key [f4] 'shell) ;;摁F4进入shell(defun compile-file()(interactive)(compile(format \"g++ -o '%s' '%s' -lm -Wall -g\"(file-name-sans-extension(buffer-name))(buffer-name))))(global-set-key [f5] 'compile-file) ;;摁F5编译(global-set-key [f6] 'gdb) ;;摁F6进入gdb调试(global-set-key (kbd \"C-s\") 'save-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"C-a\") 'mark-the-whole-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"RET\") 'newline-and-indent) ;;回车自动缩进 } 四、对拍相关@card{ 1.程序运行时间12double t = clock();cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl; 1234#### 2.diff命令```diff -b -B test.out ans.out``` }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"STL","slug":"STL","permalink":"http://arintaro.com/tags/STL/"},{"name":"Linux","slug":"Linux","permalink":"http://arintaro.com/tags/Linux/"},{"name":"Emacs","slug":"Emacs","permalink":"http://arintaro.com/tags/Emacs/"}]},{"title":"常见代码实现细节","slug":"Detail/常见代码实现细节","date":"2019-04-27T09:01:25.528Z","updated":"2020-01-09T10:21:59.815Z","comments":true,"path":"2019/04/27/Detail/常见代码实现细节/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/常见代码实现细节/","excerpt":"这里记录的问题，全是我调过的问题orz。","text":"这里记录的问题，全是我调过的问题orz。 @card{ 我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码后面括号中*的个数是我在2020/1/4后写错的个数。 } 一、变量溢出问题 @card{ 乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘 int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long， unsigned类型：值域$[0,2^{8size}-1]$溢出后对$2^{8size}$取模。 signed类型: 值$[-2^{8size-1},2^{8size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。 long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数 double用memset初始化时，跟int型一样的最值用max: 0x42, min: 0xc2,，极限值max: 0x7f, min: 0xfe。 在long long数据范围使用左移时，一定得用1LL防止溢出。 设inf时一定要小心, 0x3f最多加两次, 0x7f不能加, 有时正常数据不会爆int, 但你设的两个inf之间运算爆了int 注意$\\text{for}$循环中的变量的溢出问题 注意有时候多项式求值，代进来的$x$已经超过模数，此时需要先对$x$取模再算。 } 二、运算问题@card{ 有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数 要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除 做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值， 维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf 注意非负整数与“正整数”的区别，值域里可能会有0 有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。 三目运算符一定要加括号！ } 三、语言问题@card{ 有时需要注意\\n \\r的问题，建议写手动读入的时候直接特判掉, scanf和getline混用时尤其要注意 宏定义千万别忘了括号，调一辈子，一般来说”有分割”的东西，不用加括号 lint 输入输出 %lld，ldob输入输出 %Lf 数组作为形参会退化成指针，不能再用sizeof求大小 题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0 程序中常量默认是INT型，设定 long long a = 10000 9999 9998 等一定要注意常量爆INT的问题 使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉 写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等 维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义 计算某些东西时，如果计算后需要移动指针，注意别先移动指针了（Acwing 294, 倍增LCA等） 写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧 维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。 常数优化主要考虑执行次数$10^7$到$10^8$规模的语句，这些语句微小的变化会巨大影响常数。 不要有巨大数组的寻址操作，尤其是结构体数组，这比除模运算还慢，经常会导致程序预处理了一些东西反而变慢，尤其是访问的元素还不临近的情况。 不要有结构体指针的解引用。 尽量不要有多次除模。 不要乱加register } 四、数学相关@card{ BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$ 123if(Z == 1) return 0; //Luogu P2485 [SDOI2011]计算器if(Y % P == 0) return Z%P == 0 ? 1 : -1; i*len - ht[Yk] &gt;= 0 无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况 exgcd会求出负数解，如果求出的东西需要最小非负整数解，或者作逆元等，一定要取模到正数。 如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的 计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\\ ||\\ m&lt;0\\ ||\\ n&lt;0$时0种方案 试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于 计算一些式子时，开括号时千万不要忘了常数乘下标数量，比如$\\sum_{1 \\leq i \\leq n}{(a_i + x)^2}$，开括号不是$\\sum{a_i^2} + 2x\\sum{a_i} + x^2$，而是$\\sum{a_i^2} + 2x\\sum{a_i} + n \\times x^2$，千万别忘了这个$n$ （* } 五、数据结构相关@card{ 维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1] 分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错 分块题开数组不要开混了 在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数” 常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2 静态线段树空间直接开4n防越界，动态开点的范围为 $[mlog_2m, 2n-1]$ 翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放 下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响 pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去 在操作任何“实点”前需要pushdown，在修改后需要pushup。（* 将操作重新排序后，注意是删除操作优先，还是增加操作优先 邻接表 i=nxt[i], 千万别写成 i=nxt[x] 如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。 有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。 有时需要特判“不存在”、”没找到“的情况 写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空相关指针，大部分情况数据清不清无所谓。 值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域。 树链剖分第二次$DFS$别忘了跳过重儿子。 Trie树是信息存在边的数据结构, 我们一般把其边上的信息下放到其深度较大的节点, 由于与其他我们常写的数据结构信息存储方式不同, 写的时候一定要注意。 Trie空树是有一个节点的, 即初始化时要设totnode为1 Trie节点维护信息时, 最后一次跳转后跳转终止, 但是访问到了最后一个节点, 也要更新最后一个节点的信息 12345678910111213141516171819// Accepted 由于根节点不需要存储信息void insert(int x) &#123; int p = 1, t = x; while(x != 0) &#123; int v = x % 10; x /= 10; if(pv[p][v] == 0) pv[p][v] = ++totnode, val[totnode] = t; p = pv[p][v], val[p] = min(val[p], t); &#125;&#125;// Wrong Answer 最后一个节点未被更新void insert(int x) &#123; int p = 1, t = x; while(x != 0) &#123; int v = x % 10; x /= 10; val[p] = min(val[p], t); if(pv[p][v] == 0) pv[p][v] = ++totnode, val[totnode] = t; p = pv[p][v]; &#125;&#125; 维护不相交区间的问题，可以定义小于号为$a.r &lt; b.l$，这样完全在左为小于，完全在右为大于，剩下的相等即相交 单调队列或平衡树等结构进行操作前一定要判空！！ 维护值域的线段树一定要注意有相同数字的情况，如二分找前$k$大和时，只设定$k \\geq cnt[p]$返回是错误的，可能有二分到$l == r$，但这个值有多于$k$个数字。 区间修改的线段树能标记永久化就标记永久化，会降低常数，尤其是在作为树套树的内层树时。 pushdown或pushup一定要考虑一下节点不存在时会不会正常更新。 } 六、图论相关@card{ 如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。 邻接矩阵注意初值是0还是inf，无向边一定要记得加两遍！！ 在有负权边时，树的直径不能通过两次DFS求。 无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。 带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。 在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。 建虚点，平移编号后一定要注意读入后别忘平移，节点数别忘增加。 有向图的$scc$，注意更新$low[x]$时，需要判断节点是否在栈里，回溯时判断并出栈。 无向图的$e-dcc$, 需要注意记录的是“来的边”，而不是父节点，来处理重边问题，回溯时判断并出栈，解决根节点的问题 无向图的$v-dcc$，需要注意按常规割点定义，搜索树的根节点需要有俩儿子判定成功，且割点会属于多个$v-dcc$，建议回溯到父节点时判断儿子，根节点需要特判。 缩点相关的题注意边界情况，缩成一个点等特殊情况。 找环后别忘了$tot+1$存的是最后一个节点到第一个节点的长度 用奇数偶数存正反边建正反图时, 注意对常数的影响。 邻接表不能乱删边，我们常用的删边方法会改变下标，使得”^1为反向边”不成立 网络流题一定要注意点的编号和数组大小，加的都是双向边。 网络流大部分操作都是在”残量网络”上进行的，扫到一个边一般都要判断”ew[i] == 0” 倍增LCA时，如果需要重构，重新计算倍增数组，一定要保证非法位置为0，否则：https://www.luogu.com.cn/discuss/show/101216 } 七、动态规划相关@card{ 要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \\forall j \\ \\ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。 状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$ 有不合法状态的递推时，一定要考虑“某个现在不合法的状态”，能否在以后变成一个合法状态，能的话不能直接不计算它，为了它后置状态的正确转移必须要计算它。 维护单调队列时, 从队头出队判断合法性一定要在入队操作之后。 1234567891011121314151617181920212223// Wrong Answerfor(int i=1; i&lt;=n; i++) &#123; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++; if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]);&#125;// Acceptedfor(int i=1; i&lt;=n; i++) &#123; while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]);&#125;// Acceptedfor(int i=1; i&lt;=n; i++) &#123; while(l &lt;= r &amp;&amp; !check(j, i)) l++; // 出队操作 if(l &lt;= r) dp[i] = dp[q[l]] + val(i, q[l]); while(j &lt; i &amp;&amp; cmp(q[r], j)) r--; // 入队操作 q[++r] = j++;&#125; 在动态规划中应用单调队列时，队列最大可能是值域，别顺手写成maxn了 动态规划中用队列or变量单独维护决策时，注意上下界剪枝可能导致该入队的决策没有入队 1234567891011121314// Acceptedfor(rint j=arr[i].s+arr[i].len-1; j&gt;=m; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len));&#125;for(rint j=min(arr[i].s+arr[i].len-1, m); j&gt;=arr[i].s; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len)); dp[j] = max(dp[j], res + j * arr[i].w);&#125; // Wrong Answerfor(rint j=min(arr[i].s+arr[i].len-1, m); j&gt;=arr[i].s; j--) &#123; if(j - arr[i].len &gt;= 0) res = max(res, calc(i, j - arr[i].len)); dp[j] = max(dp[j], res + j * arr[i].w);&#125; 初值不要瞎填，求最大值/最小值尽量初始化-inf/inf。} 八、杂项@card{ 题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;= 一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1 在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。 交换变量时，注意变量的附带属性别忘了一起交换。 有时候题目中可能不存在“能解决所有数据、能处理所有情况“的单一算法，注意大力讨论。 进行思考、推导时，一定要注意前提条件，例如“一定可以从这个点出发找到另一个点”，这个点真的存在么？$n=1$时还存在么？ 数组复用时，一定得是“赋值”，才不用清零，如果直接用++了，别忘了清零。 用前缀和时，千万别忘了还可以取整个前缀即“ - arr[0]” 写搜索时，中间的剪枝立即回溯前也别忘了还原现场。 开邻接矩阵时，有时会有重边，注意后面覆盖前面的问题 无论是倍增还是二分答案，尽量让指针保持在定义域内，不要让其自然溢出。 我们常用的1-index下标遇上模循环节的时候一定要注意，多举反例 一定要考虑边界状况, $n = 1$或$m = 1$时算法是否还能成立。 有多个上限$n$, $m$, $t$等, 循环时一定要分清上限是哪个 一定要注意$set$是无重集合，$multiset$才能重复，我们一般用$multiset$。 } 九、奇异的语言细节@card{ 1234567// 形参中的表达式一定会被计算，但是C++标准并没有规定参数的求值顺序void test(int x,int y)&#123; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;&#125;int x = 0;test(++x,x); // 输出 1 1test(++x,x-1); // 输出1 -1 } 十、Final Check@card{ 为了防止某题正解挂的连暴力都不如, 提交前必须检查。 对拍: 写正解的题必须拍, 包括T1, 虽然暴力可能写挂, 但是正解与暴力挂的一模一样的概率极低 极限数据: 在暴力的数据范围拍完后, 必须造一组极限数据检查是否会TLE/RE/MLE 数据类型检查: double, long long与int, 尤其是经常被忽略的函数返回值 运算溢出检查: 某个地方会不会有int之间的运算, 结果却需要long或double 数组越界检查: 数组是否开的不够大？ }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"OI中的常见解题思路与技巧（更新中）","slug":"Detail/OI中的常见解题思路与技巧","date":"2019-04-27T09:01:25.509Z","updated":"2019-11-03T13:37:09.351Z","comments":true,"path":"2019/04/27/Detail/OI中的常见解题思路与技巧/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/OI中的常见解题思路与技巧/","excerpt":"也许很有用，也许没什么卵用。","text":"也许很有用，也许没什么卵用。 一、最优化问题@card{ 二分答案：答案具有“单调性”，外层花费$log\\ ans$的时间转化为判定性问题 答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的 二分出的答案对check的进行有所帮助 动态规划：一定要有最优子结构性质，和易于确定的计算顺序 贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件。 可以小范围搜索+多重限制贪心乱搞，说不定就骗到了100pts呢，考试的时候要勇于乱搞，敢于乱搞 一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质。 出题人是傻的，数据是水的，贪心+暴力是能过的，是能$AC$的。 排序、邻项交换：注意严格弱序, 没有关系没有传递性肯定不行, 没有不可比传递性可以双关键字排序。性质证明可以枚举证明。 后悔法：先选上一组可行解, 再迭代的后悔选出最优解 } 二、计数概率期望问题@card{ 思路 绝大多数是动态规划, 少部分是纯数学推式子 计数 构造划分基点, 确立无重分类 概率 讨论所有情况, 应用全概率公式与条件概率 期望 状态设计绝大多数采用逆推, 即在DAG上该点到终点的期望价值 逆推转移即为每种转移的概率乘(转移代价与后续的期望价值), 注意概率和一定要为1 若有存在多种决策影响价值计算, 求一种最优期望的决策, 状态中记录影响价值计算的决策即可, 注意不能记录”概率成功”的决策结果 一定要确定给出的概率是”顺推概率”, 还是”逆推概率” } 三、数据结构题@card{ 思路 并查集也可以用来维护序列, 有着优秀的常数和时间。 } 四、数学题@card{ 求和题：核心思想：[交换求和顺序] } 五、图论问题@card{ } 六、搜索优化策略@card{ 优化搜索顺序 即从“后续变化较少”的状态开始搜 搜前排序 排除等效亢余 给搜索固定一个顺序，例如二元组(x, y)与(y, x)不要反复搜 例如往盒子里放东西，一个东西放在不同的“空盒子”即是等效的 贪心 考虑在一个状态下做了什么决策比另一些决策更优秀 可行性、最优性剪枝 / 估价函数 即“最理想的方法”都无法满足可行或可更新答案 估价函数必须比实际路径非严格更优 有时候与范围相关的可以通过不等式放缩来去掉一些状态 双向搜索 } 七、动态规划优化策略@card{ 费用提前/延后计算 没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算 环形的处理 一次断开、一次强制连接，以覆盖所有情况 破环成链、倍增环长 后效性的处理 有分阶段后效性，阶段内部按环形处理 高斯消元（构造复杂度更优的消元方式） 对某个值域范围特别小的部分进行状压压缩, 部分状压解决有限后效性 状态压缩的优化 预处理合法状态和每个状态合法的前置状态 矩阵快速幂 递推轮数很长，方程不变 快速幂与倍增 $dp[x]$与$dp[y]$ 能推出 $dp[x + y]$ 就可应用倍增或者快速幂 DAG上的多次询问问题经常需要倍增，“预处理与拼凑” 分离无关变量 让每个决策$j$的价值只与$j$有关，在$i$增大时，每个决策的价值不变，这样就容易维护最优决策 分段转移时，方程里尽量别写“段的长度”，而是写成$i-j$，即当前与决策点的距离 确定计算顺序 DP的核心是分阶段，高度有序的计算，一般可以利用贪心先确定计算顺序，以此应用DP 决策单调性 一维状态下尽量打表，不考虑证明，具体可用一个队列维护最优决策，每次状态更新后二分地去更新后面的最优决策 二维区间DP的决策单调性 $P[i, j-1] &lt;= P[i, j] &lt;= P[i+1，j]$ 确定划分基点，构造无重分类 } 七、常见有用思想与技巧、性质@card{ 正难则反：广泛应用于各种问题 答案不容易求、不容易划分，利用全集减去补集从而求出答案 字典序最小的方案：结合性质7，倒序处理 对某个点关于其他点的计算问题，可以转化为其余点对它的贡献 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数 凹凸性（二阶导数）：凸壳优化 对称性：优化枚举顺序、减少计算量 等效转换：常见于需要计算一些奇怪的东西，找出性质转化成别的问题。 递归处理：原问题可以划分为几个相同的子问题 “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于 例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于 试填法、字典序 树上、序列上的差分与前缀和 某些计数问题可以转化为 F(x)为至少满足x的有多少个，则满足X的答案为F(x) - F(x+1). 不对原数据处理，而是“对询问” 确定计算顺序 在某些“每个点都需要满足xx条件”时，如果确定了一种“如果这个条件现在不满足，以后都满足不了”的计算顺序，就可以贪心的考虑了 离散化 不关心集合中的数的具体大小，只关心其相对大小，映射成1-size的整数 在计数问题中作为等效性的一种应用 先考虑去掉限制条件、缩小数据范围的情况 之后再逐步扩大，如DP先考虑没有限制条件的情况，再通过转移范围约束 考虑退化情况，树转化成图 “要是这样就好了” =&gt; “怎么样能变成这样” 用适当的枚举与计算顺序覆盖所有情况 有时候会有错误的转移更新答案, 但肯定没有答案优秀, 所以不影响结果 调整法 先求出一组可行解, 在逐步调整至最优解 划分决策集合, 及时排除不可能的决策 全部决策集合不容易维护, 考虑按某种性质划分成多个集合, 集合内部满足单调性等优秀性质 价值转化 直接从题面描述的价值计算方式不容易计算，考虑对每个单元计算贡献。 有时候已知全集，并且全集被划分为了两部分，知道一个部分即可求出另一个部分。 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"},{"name":"细节","slug":"细节","permalink":"http://arintaro.com/tags/细节/"}]},{"title":"NOIP2018 D1T3 赛道修建","slug":"Contest/NOIP 2018/road","date":"2019-04-27T09:01:25.456Z","updated":"2019-11-01T00:04:33.469Z","comments":true,"path":"2019/04/27/Contest/NOIP 2018/road/","link":"","permalink":"http://arintaro.com/2019/04/27/Contest/NOIP 2018/road/","excerpt":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。","text":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。 Description:@card{ 给定一棵带权树，要求从树上划分出$m$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \\times 10^4$级别（实际上可以出到$5\\times10^5$左右，边权再缩小点甚至能更大，卡$sort$?(雾 } Solution:@card{ 分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助。 发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。 能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。考虑性质1：每条路径对答案的贡献其实是相同的，都是$1$，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之性质2：父节点只能有一条路径到当前节点，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在保证配对数最大的同时，还要保证剩下的深度最大，从而上传给父节点。 至此，我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下： 给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。 这里网上通常有三种实现形式，我从复杂到简洁讲： 算法1：贪心+平衡树/双向链表、删除标记首先，我们显然有性质1：应该优先配对较小的深度。 如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。 然后，我们有性质2：最优方案中，每个最小值都应该与能配对的最小的数配对，显然，不证了。基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \\ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（期望得分：55分，实际得分：100分 算法2：双指针+栈一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是能配对的最小的数。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。 STD算法：双指针那么有没有不用栈，常数更加优秀（并没有，更加简洁的算法呢？有，就是本题的std1。基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j$，配对到了左指针$i$，如果$j-1$不能与$i$配对，那么剩下的右指针也显然配对不了，所以$i$必须得与$j$配对，这时我们更新$last = j - 1$即可，如果最后考虑一个右指针$j$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]$成功配对的右指针平移到$[j,last-1]$，然后用$last$对应的值更新上传的最大值。由于网上$blog$没有对这个算法的讲解，$std$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std$在干什么。。 这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\\frac{\\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，从而实现了卡sort的可能。还有俩剪枝，二分上界可以设到$min{\\frac{\\sum{w_i}}{m}}{d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;const int rid = 8;int n, m;int root = 1, sumw = 0;int temp[maxn], rcnt[1&lt;&lt;rid], rmod = (1 &lt;&lt; rid) - 1;inline void rsort(int arr[], int n) &#123; if(n &lt; 256) &#123; sort(arr+1, arr+n+1); return; &#125; for(rint i=0; i&lt;=31; i+=rid) &#123; memset(rcnt, 0, sizeof(rcnt)); for(rint k=1; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++; for(rint j=1; j&lt;=rmod; j++) rcnt[j] += rcnt[j-1]; for(rint k=n; k&gt;=1; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k]; memcpy(arr, temp, sizeof(int) * (n+1)); &#125;&#125;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;int arr[maxn], dist[maxn];int dfs(int x, int fa, int mid) &#123; int res = 0, tot = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else arr[++tot] = dist[ev[i]] + ew[i]; &#125; rsort(arr, tot), dist[x] = 0; for(rint i=1, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123; while(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++]; if(i == j) &#123; dist[x] = arr[last]; break; &#125; if(j &amp;&amp; arr[i] + arr[j-1] &lt; mid) last = j-1; if(res &gt;= m) return res; &#125; return res;&#125;int maxd, dp[maxn];void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]); dp[x] = max(dp[x], dp[y] + ew[i]); &#125;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs2(root, root); int l = 1, r = min(maxd, sumw / m); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; } @card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define sit multiset&lt;int&gt;::iteratortemplate&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;int n, m;int root = 1;int sumw = 0, dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;multiset&lt;int&gt; s;int dfs(int x, int fa, int mid) &#123; int res = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; dist[x] = 0, s.clear(); for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else s.insert(dist[ev[i]] + ew[i]); &#125; for(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; // nxt一定在it后面 sit nxt = s.lower_bound(mid - (*it)); if(nxt == it &amp;&amp; nxt != s.end()) nxt++; if(nxt == s.end()) &#123; it++; continue; &#125; s.erase(nxt), s.erase(it++), res++; // 注意先删nxt, 不然it++可能等于nxt if(res &gt;= m) return res; &#125; if(!s.empty()) dist[x] = *s.rbegin(); return res;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; int l = 1, r = sumw / 2; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; }","categories":[{"name":"NOIP","slug":"NOIP","permalink":"http://arintaro.com/categories/NOIP/"},{"name":"题解","slug":"NOIP/题解","permalink":"http://arintaro.com/categories/NOIP/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"树上问题","slug":"树上问题","permalink":"http://arintaro.com/tags/树上问题/"},{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"}]},{"title":"树的相关性质(更新中)","slug":"Algorithm/树的相关性质","date":"2019-04-27T09:01:25.373Z","updated":"2019-09-26T09:29:08.998Z","comments":true,"path":"2019/04/27/Algorithm/树的相关性质/","link":"","permalink":"http://arintaro.com/2019/04/27/Algorithm/树的相关性质/","excerpt":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。","text":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。 一、树的直径@card{ （一）求法： 两次DFS比较容易求出具体路径，缺点是实现比树形DP麻烦，并且要求树的边权非负。 树形DP实现简单，但求具体路径比较麻烦，适用于只需要直径长度的情况（如二分答案的上界剪枝等），对边权没有要求。 （二）性质： 基本思想：分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。 任意一个节点作根，直径两端点一定是叶子节点。 距离任意点最远的点一定是直径的一个端点。（相当有用的性质 设从A出发找到最远点B 如果A已经是直径上一个端点，正确性显然。 如果不是，考虑反证，设直径为CD。 由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。 则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。 树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分(必须边，且除这部分外，无其他公共部分)，并且共侧的直径一段长度必然相等。 显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。 如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。 如果除这部分还有公共部分，就会形成一个环。 对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。 如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。 往一棵树里加一个点，直径的端点最多改变一个 先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。 （三）在具体题目下的证明例子 NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，然而原题不要求证明这些东西 在任意直径上求最小偏心距都相等 考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。 考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。 逃学的小孩 题意为树上要求选一个起始点与俩终点，要求最大化“起始点到两终点距离较小的+两终点的距离” 显然我们应该让直径作为这个“两个终点的距离”（如果你觉得并不显然：可以考虑三个点$A、B、C$，有三条路径$AB, BC, AC$，可以发现，如果令其中次长或最小的作为“两终点间的距离“，都没有令最长的作为优） 然后分别从直径上各个点出发暴力找起点即可。 } 二、树上点集路径","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://arintaro.com/categories/算法/图论/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"优雅的O(1)下取整log2","slug":"Template/小工具/log2","date":"2019-04-27T09:01:25.331Z","updated":"2019-10-27T10:21:41.707Z","comments":true,"path":"2019/04/27/Template/小工具/log2/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/小工具/log2/","excerpt":"还能不能再给力点呢？","text":"还能不能再给力点呢？ 1.转double法@card{ double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，是$O(1)$的。请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可） 123456#define lint long longinline lint mlog2(lint x)&#123; if(x == 1) return 0; double t = (double)x; return (lint)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1; // 注意最前面还要再转一次long long&#125; Luogu ST表 传统打表法 1011ms https://www.luogu.org/recordnew/show/13493959Luogu ST表 double法 1009ms https://www.luogu.org/recordnew/show/18155615实测后发现速度差异不大, 开了O2打表会快一些 } 2.打表法@card{ 显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论 $$\\forall k \\in [0,35], 2^kmod\\ 37,\\ 取遍[1,36]$$ } 3.double法的具体测试@card{ $test\\ site:$https://www.luogu.org/problemnew/show/P3865 $task:$ 实现函数mlog2，需要$O(1)$返回$\\lfloor log_2{x} \\rfloor​$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// test site: https://www.luogu.org/problemnew/show/P3865// 要求：实现函数mlog2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define rint register int#define lint long longusing namespace std;const int maxn = 1e5 + 10;int n, m, logn;int arr[maxn];inline lint mlog2(lint x) &#123; &#125;int rmq[20][maxn];inline void getrmq() &#123; for(rint i=1; i&lt;=n; i++) rmq[0][i] = arr[i]; for(rint d=1; d&lt;=logn; d++) &#123; int len = (1 &lt;&lt; d), half = (1 &lt;&lt; (d-1)); for(rint i=1; i+len-1&lt;=n; i++) &#123; rmq[d][i] = max(rmq[d-1][i], rmq[d-1][i+half]); &#125; &#125;&#125;inline int ask(int l, int r) &#123; int loglen = mlog2(r - l + 1); return max(rmq[loglen][l], rmq[loglen][r-(1&lt;&lt;loglen)+1]);&#125;int main() &#123; readint(n), readint(m); logn = ceil(log2(n)); for(rint i=1; i&lt;=n; i++) readint(arr[i]); getrmq(); int nl, nr; while(m--) &#123; readint(nl), readint(nr); printf(\"%d\\n\",ask(nl,nr)); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]}]}