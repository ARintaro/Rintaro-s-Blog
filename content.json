{"meta":{"title":"Rintaro's Blog","subtitle":"Algorithm and Anime","description":"某弱省一弱校高一OIer","author":"Rintaro","url":"http://arintaro.com","root":"/"},"pages":[{"title":"","date":"2019-09-26T07:06:06.945Z","updated":"2019-04-27T07:31:21.041Z","comments":false,"path":"categories/index.html","permalink":"http://arintaro.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Luogu P1654 OSU!","slug":"Answer/osu","date":"2019-10-24T05:40:42.504Z","updated":"2019-10-24T06:00:56.476Z","comments":true,"path":"2019/10/24/Answer/osu/","link":"","permalink":"http://arintaro.com/2019/10/24/Answer/osu/","excerpt":"感觉期望还是比较冷门的考察方向","text":"感觉期望还是比较冷门的考察方向 Description:@card{ 给定一个$n$个位置, 每个位置有$p_i$的概率为$1$, 否则为0, 每一段极大连续的$1$会产生长度的三次方的分数, 求分数的期望值 } Solution:@card{ 考虑逐个把1加入计算贡献, 不妨假设前$i-1$个位置的得分期望已经正确求出,。当该位为0时, 显然答案直接累加$i-1$的即可；当该位为1时, 会增大所有”后缀连续1”的贡献, 而对其他贡献没有影响: 对于一个长度在这之前已经为$x$的后缀1段, 增大的贡献显然为$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$, 对于所有这样的串考虑显然只需要代入期望值即可, 所以需要分别维护后缀长度平方的期望和后缀长度的期望。 注意后缀长度平方的期望不能直接由后缀长度的期望直接平方得到, 因为它自身显然是不独立的, 不能直接用期望的乘法性质, 乘法要求两个随机变量相互独立。则有: $$E(A^3_n) = p_i (E(A^3_n-1) + 3E(B^2_n-1) + 3E(B_n-1) + 1) + (1 - p_i) E(A^3_n-1)$$$$E(B^2_n) = p_i (E(B^2_n-1) + 2E(B_n-1) + 1) + (1 - p_i) \\times 0$$$$E(B_n) = p_i(E(B_n-1) + 1) + (1 - p_i) \\times 0$$ Luogu上的题解也有很多从另外的角度思考了, 复习的时候可以看一下：https://www.luogu.org/problemnew/solution/P1654} Code:@card{ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define ldob long double#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n;ldob EA3[maxn], EB1[maxn], EB2[maxn], p[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; scanf(\"%Lf\", &amp;p[i]); EB1[i] = p[i] * (EB1[i-1] + 1) + (1 - p[i]) * 0; EB2[i] = p[i] * (EB2[i-1] + 2 * EB1[i-1] + 1) + (1 - p[i]) * 0; EA3[i] = p[i] * (EA3[i-1] + 3 * EB2[i-1] + 3 * EB1[i-1] + 1) + (1 - p[i]) * EA3[i-1]; &#125; printf(\"%.1Lf\\n\", EA3[n]); return 0;&#125; }","categories":[{"name":"Luogu","slug":"Luogu","permalink":"http://arintaro.com/categories/Luogu/"},{"name":"NOIP2018","slug":"Luogu/NOIP2018","permalink":"http://arintaro.com/categories/Luogu/NOIP2018/"},{"name":"题解","slug":"Luogu/NOIP2018/题解","permalink":"http://arintaro.com/categories/Luogu/NOIP2018/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"递推","slug":"递推","permalink":"http://arintaro.com/tags/递推/"},{"name":"期望","slug":"期望","permalink":"http://arintaro.com/tags/期望/"}]},{"title":"NOIP2013 花匠","slug":"Contest/NOIP 2013/flower","date":"2019-10-23T11:53:29.869Z","updated":"2019-10-24T05:42:26.448Z","comments":true,"path":"2019/10/23/Contest/NOIP 2013/flower/","link":"","permalink":"http://arintaro.com/2019/10/23/Contest/NOIP 2013/flower/","excerpt":"与黄题斗智斗勇","text":"与黄题斗智斗勇 Description:@card{ 求一个整数序列的最长波峰序列, 详见https://www.luogu.org/problem/P1970 } Solution:@card{ 这个题思路没什么难的, 主要是实现细节与边界处理。 做法显然是划分出每个单调递增单调递减的子段, 选上峰点和开头结尾即可。 问题在于其中会有相等的数字, 对于一个区间内的很好处理, 相等是不影响当前区间的单调性的。然而我们在设初值时, 会设为$a[1], a[2]$的关系, 我一开始没有考虑$a[1]$, $a[i]$相等了该怎么办。另外, 当$n=1$和$n = 2 and a[1] == a[2]$时, “选上开头结尾”是无法做到的, 需要特判。 } Code:@card{ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e5 + 10;int n, ans = 2;int arr[maxn];int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) readint(arr[i]); if(n == 1) cout &lt;&lt; 1 &lt;&lt; endl; else if(n == 2) cout &lt;&lt; 1 + (arr[2] != arr[1]) &lt;&lt; endl; else &#123; int x = -1; for(rint i=2; i&lt;=n; i++) &#123; if(arr[i] == arr[i-1]) continue; if(x == -1) x = (arr[i] &gt; arr[i-1]); else if((arr[i] &gt; arr[i-1]) != x) ans++, x ^= 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; }","categories":[{"name":"比赛","slug":"比赛","permalink":"http://arintaro.com/categories/比赛/"},{"name":"NOIP2013","slug":"比赛/NOIP2013","permalink":"http://arintaro.com/categories/比赛/NOIP2013/"},{"name":"题解","slug":"比赛/NOIP2013/题解","permalink":"http://arintaro.com/categories/比赛/NOIP2013/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"边界处理","slug":"边界处理","permalink":"http://arintaro.com/tags/边界处理/"}]},{"title":"NOIP2010 观光公交","slug":"Contest/NOIP 2010/bus","date":"2019-10-23T09:33:02.040Z","updated":"2019-10-23T10:48:35.241Z","comments":true,"path":"2019/10/23/Contest/NOIP 2010/bus/","link":"","permalink":"http://arintaro.com/2019/10/23/Contest/NOIP 2010/bus/","excerpt":"你以为我是DP,其实我是贪心啦dio","text":"你以为我是DP,其实我是贪心啦dio Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1315要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。 } Solution:@card{ 对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。 接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(事实上远远跑不到); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。 我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(这两个名词都是我瞎编的) 算法1：贪心直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。 同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。 算法2：优化后的贪心发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(然而并没有), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。 算法3: 数据结构优化贪心考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。 } Code:@card{ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;const int inf = 1e9;int n, m, k;int cnt[maxn], leave[maxn], arrive[maxn], w[maxn];lint sum[maxn];int main() &#123; readint(n), readint(m), readint(k); for(rint i=2; i&lt;=n; i++) readint(w[i]); for(rint i=1; i&lt;=m; i++) &#123; int t, st, ed; readint(t), readint(st), readint(ed); cnt[ed]++, sum[ed] += t; leave[st] = max(leave[st], t); &#125; for(rint i=2; i&lt;=n; i++) arrive[i] = max(arrive[i-1], leave[i-1]) + w[i]; while(k != 0) &#123; int res_st = 0, res_ed = 0, res_w = 0, res_cnt = 0; for(rint i=2; i&lt;=n; ) &#123; if(w[i] == 0) &#123; i++; continue; &#125; int now_w = min(w[i], k), now_cnt = 0; rint j = i; for(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123; now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]); &#125; now_cnt += cnt[j]; if(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt; i = j + 1; &#125; if(res_w == 0) break; w[res_st] -= res_w, k -= res_w; for(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w; &#125; lint ans = 0; for(rint i=1; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"比赛","slug":"比赛","permalink":"http://arintaro.com/categories/比赛/"},{"name":"NOIP2009","slug":"比赛/NOIP2009","permalink":"http://arintaro.com/categories/比赛/NOIP2009/"},{"name":"题解","slug":"比赛/NOIP2009/题解","permalink":"http://arintaro.com/categories/比赛/NOIP2009/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"},{"name":"迭代","slug":"迭代","permalink":"http://arintaro.com/tags/迭代/"}]},{"title":"NOIP2009 道路游戏","slug":"Contest/NOIP 2009/road","date":"2019-10-23T02:52:08.757Z","updated":"2019-10-23T08:53:33.965Z","comments":true,"path":"2019/10/23/Contest/NOIP 2009/road/","link":"","permalink":"http://arintaro.com/2019/10/23/Contest/NOIP 2009/road/","excerpt":"千万不要以为普及组都是水题","text":"千万不要以为普及组都是水题 Description:@card{ 题意较为复杂,套的壳比较多,可见https://www.luogu.org/problem/P1070要点: 在任意时间必须有且仅有一个机器人,可以赔钱 } Solution:@card{ 分析一下思路,发现有明显的时间顺序,又是一个最优化问题,可以确定是动态规划。费用比较奇怪,题面描述是个边权,不过我们显然可以下放到到点上,比如$1 -&gt; 2 -&gt; 3$,从1走两次到3,累加了两段路上金币,可以发现从$i$走$p$次就是累加$[i, i + x - 1]$的金币。手玩一下可以发现只要对费用矩阵斜着求前缀和即可。由于是环形问题,为了方便最好把行上的编号重编至$[0, n-1]$。如果沿用$[1, n]$, 需要在每次”可能越界前”,先把编号-1取模再+1映射回来。 算法1：暴力DP题里没什么影响决策的限制条件,记录时间即可,转移显然需要枚举出发点和走多远,稍微算下复杂度$O(nmp)$。期望得分90pts, 实际得分100pts 算法2：转移优化DP由于给了较多的部分分,我们可以相信这与正解已经相差不远,所以先考虑转移优化,而不是状态优化。 这种求前缀和的分段转移模型,一般写出”我从哪里来”形式的方程,显然我们有: $$dp[i] = min{dp[j] + sum[x][i] - sum[(x - (i - j)) mod n][j] - val[(x - (i - j) + 1) mod n] } ( i - p &lt;= j &lt;= i - 1) $$ 注意一个细节, 序列上的”前缀和”求$[l, r]$的和时需要用$sum[r] - sum[l - 1]$,在方程中体现的是”出发点事实上是$x + 1$”。另外具体实现时,由于涉及到模意义下的减法,尽量加模数后再取模防止负数。 决策变量两维, 发现$n^2$可以接受, 考虑先枚举一维, 涉及$x$的量较多, 考虑先确定$x$, 略去$mod n$后 $$dp[i] = min{dp[j] - sum[x - (i - j)][j] - val[x - (i - j) + 1] } + sum[x][i] ( i - p &lt;= j &lt;= i - 1)$$ 可以发现与常规的优化DP不同, 一个决策$j$的价值可能与$x, i$有关,使得我们无法高效的维护决策集合,如果我们能使得$j$的价值与$x, i$无关,就可以用单调队列或平衡树等数据结构直接维护价值,每次直接转移,而不需要在得到$x, i$后对决策集合中的每个决策重新计算价值。 把确定的变量$x, i$整理到一起后, 发现内层价值数组中的下标只与$x - i$有关, 而在$mod n$意义下$x - i$的值显然至多只有$n$种,从多重背包在剩余系下的优化转移得到启发,我们可以按其在剩余系的模数分类,开$n$个不同的决策集合,这样对于决策$j$来讲关于$x - i$的部分即可化为定值。限制条件中上界下界单调递增, 显然可以用单调队列把转移的时间摊到$O(1)$ 从实际含义上讲,这对应了在费用矩阵上不同的”斜列”转移(即我们斜着求前缀和的$n$个不同序列), 每次内层$x$增加时, 对应在不同斜列上的移动。 此题启发我们可以对决策集合进行”分类”, 从而消除状态变量对一个决策价值的影响。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))#define eco(x) ((x) % n == 0 ? n : (x) % n)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000 + 10;int n, m, p;int id[maxn][maxn], w[maxn][maxn], c[maxn];int dp[maxn], ql[maxn], qr[maxn];pii mq[maxn][maxn];int main() &#123; memset(dp, 0xc0, sizeof(dp)); readint(n), readint(m), readint(p); for(rint i=1; i&lt;=n; i++) &#123; for(rint j=1; j&lt;=m; j++) &#123; readint(w[i][j]); &#125; &#125; for(rint i=1; i&lt;=n; i++) readint(c[i]); for(rint j=1; j&lt;=m; j++) &#123; for(rint i=1; i&lt;=n; i++) &#123; w[i][j] += w[eco(i-1)][j-1]; &#125; &#125; for(rint i=1; i&lt;=n; i++) &#123; int x = i, y = 1; ql[i] = 1, qr[i] = 1; mq[i][1] = mp(-c[i], 0); while(y &lt;= m) &#123; id[x][y] = i; x = eco(x + 1), y++; &#125; &#125; dp[0] = 0; for(rint t=1; t&lt;=m; t++) &#123; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; t - q[l].second &gt; p) l++; dp[t] = max(dp[t], w[x][t] + q[l].first); &#125; for(rint x=1; x&lt;=n; x++) &#123; int &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid]; pii (&amp;q)[maxn] = mq[qid]; while(l &lt;= r &amp;&amp; q[r].first &lt; dp[t] - w[x][t] - c[eco(x+1)]) r--; q[++r] = mp(dp[t] - w[x][t] - c[eco(x+1)], t); &#125; &#125; cout &lt;&lt; dp[m] &lt;&lt; endl; return 0;&#125; }","categories":[{"name":"比赛","slug":"比赛","permalink":"http://arintaro.com/categories/比赛/"},{"name":"NOIP2009","slug":"比赛/NOIP2009","permalink":"http://arintaro.com/categories/比赛/NOIP2009/"},{"name":"题解","slug":"比赛/NOIP2009/题解","permalink":"http://arintaro.com/categories/比赛/NOIP2009/题解/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://arintaro.com/tags/动态规划/"},{"name":"动态规划的转移优化","slug":"动态规划的转移优化","permalink":"http://arintaro.com/tags/动态规划的转移优化/"},{"name":"单调队列","slug":"单调队列","permalink":"http://arintaro.com/tags/单调队列/"},{"name":"环形处理","slug":"环形处理","permalink":"http://arintaro.com/tags/环形处理/"}]},{"title":"算法学习资料汇总","slug":"Essay/算法学习资料汇总","date":"2019-10-01T05:19:49.561Z","updated":"2019-10-16T23:22:04.397Z","comments":true,"path":"2019/10/01/Essay/算法学习资料汇总/","link":"","permalink":"http://arintaro.com/2019/10/01/Essay/算法学习资料汇总/","excerpt":"主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有","text":"主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有 一、数学@card{ 线性基 https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://blog.csdn.net/a_forever_dream/article/details/83654397 博弈论 https://www.cnblogs.com/Wolfycz/p/8430991.html 2007国家集训队论文：王晓珂《解析一类组合游戏》 2009国家集训队论文：贾志豪《组合游戏略述——浅谈SG游戏的若干拓展及变形》 奇异的数列 斐波那契数列：https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、 $f[n+m]=f[m−1]∗f[n]+f[m]∗f[n+1]$ } 二、图论@card{ 负环与差分约束 求最大值:初始化inf, 跑最短路、求最小值:初始化-inf, 跑最长路 SPFA的三种优化: 大于队头从队尾入队、每次队列变化时检查队头队尾距离swap、卡时2e7 双联通分量 https://linkfqy.github.io/posts/BCC_and_Tarjan/ 求点双联通分量，根节点在搜索树上需要有两个子树才能被判定为割点 } 三、字符串@card{ } 四、数据结构@card{ 莫队 https://www.cnblogs.com/WAMonster/p/10118934.html 《算法竞赛中的分块思想》 杭州学军中学 ⾕晟} 五、动态规划@card { 悬线法 2003国家集训队论文《浅谈用极大化思想解决最大子矩形问题》王知昆 }","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"}]},{"title":"基础数学总结","slug":"Algorithm/基础数学总结","date":"2019-09-25T07:56:33.502Z","updated":"2019-10-01T06:52:50.957Z","comments":true,"path":"2019/09/25/Algorithm/基础数学总结/","link":"","permalink":"http://arintaro.com/2019/09/25/Algorithm/基础数学总结/","excerpt":"","text":"一、数论@card{ (一) 质数与因子相关1.对于一个足够大的整数N，不超过N的质数大约有$\\frac{N}{ln(n)}$个2.一个数至少有一个小于$\\sqrt{n}$的因子，至多存在一个超过$\\sqrt{n}$的因子，因此不少算法可以只跑到$\\sqrt{n}​$3.埃筛(1) 每个数从$x^2​$开始筛即可 (2) 用$\\sqrt{r}$内的数就可以对$[l, r]$进行区间筛 4.线筛(1) 通过“积累最小质因子”的方法，去除合数 5.质因数分解(1) 不少题可以通过算术基本定理找出想法 (2) 试除法最后需要特判剩下来个大于$\\sqrt{n}$的质数的情况 (3) 有时候也可以反过来统计，不考虑它有什么因子，而是考虑“每个因子有多少个”，阶乘快速分解和倍数法基于此思想 } @card{ (二) 同余、取模相关1.不少模非质数的题目，需要对模数分解成质因子，最后用CRT/EXCTR合并答案}","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"数学","slug":"算法/数学","permalink":"http://arintaro.com/categories/算法/数学/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"}]},{"title":"基础数论","slug":"Template/算法/基础算法","date":"2019-09-23T13:41:18.234Z","updated":"2019-09-23T13:42:33.912Z","comments":true,"path":"2019/09/23/Template/算法/基础算法/","link":"","permalink":"http://arintaro.com/2019/09/23/Template/算法/基础算法/","excerpt":"","text":"1.归并排序求逆序对@card{ $Test Site:$ https://www.acwing.com/problem/content/109/ $Code:$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 5e5 + 10;// 9 1 0 5 4int n;lint ans = 0;int arr[maxn], temp[maxn];void msort(int l, int r) &#123; if(l == r) return; int mid = (l + r) &gt;&gt; 1; msort(l, mid), msort(mid+1, r); // 在后面还小 for(rint i=l, j=mid+1, p=l; p&lt;=r; p++) &#123; // 一定要讨论选完的情况 if(j &gt; r || i &lt;= mid &amp;&amp; arr[i] &lt;= arr[j]) temp[p] = arr[i++]; else temp[p] = arr[j++], ans += mid - i + 1; &#125; for(rint i=l; i&lt;=r; i++) arr[i] = temp[i];&#125;int main() &#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; ans = 0; for(rint i=1; i&lt;=n; i++) readint(arr[i]); msort(1, n); printf(\"%lld\\n\", ans); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"}]},{"title":"基础数论","slug":"Template/数论/基础数论","date":"2019-09-23T11:05:47.314Z","updated":"2019-09-23T11:12:04.557Z","comments":true,"path":"2019/09/23/Template/数论/基础数论/","link":"","permalink":"http://arintaro.com/2019/09/23/Template/数论/基础数论/","excerpt":"","text":"1.判断素数@card{ $Test Site:$ https://www.luogu.org/problem/P3383 $Code:$ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define read3(x,y,z) scanf(\"%d %d %d\",&amp;(x),&amp;(y),&amp;(z))#define putint(x) printf(\"%d \",(x))#define rint register intusing namespace std;bool isprime(int x)&#123; if(x==2||x==3) return 1; if(x==0||x==1||(x%6!=1&amp;&amp;x%6!=5)) return 0; int t = sqrt(x); for(rint i=5; i&lt;=t; i+=6) if(x%i==0||x%(i+2)==0) return 0; return 1;&#125;int main()&#123; int x , n; readint(x) , readint(n); while(n--)&#123; readint(x); puts(isp(x) ? \"Yes\" : \"No\"); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://arintaro.com/tags/数学/"},{"name":"数论","slug":"数论","permalink":"http://arintaro.com/tags/数论/"}]},{"title":"小型冷门知识点汇总","slug":"Algorithm/小型冷门知识点汇总","date":"2019-04-28T06:06:16.512Z","updated":"2019-05-05T03:33:51.723Z","comments":true,"path":"2019/04/28/Algorithm/小型冷门知识点汇总/","link":"","permalink":"http://arintaro.com/2019/04/28/Algorithm/小型冷门知识点汇总/","excerpt":"","text":"图论 Johnson 算法 /原始对偶算法 $site:$ https://zhuanlan.zhihu.com/p/48523094、https://www.cnblogs.com/tkandi/p/10532774.html 用途：用下界$O(NM)$的时间跑一遍$SPFA$消除图内所有负权边，用以之后跑$DJ$的全源最短路径或者跑费用流。适用于需要多次求最短路的问题，有时候甚至可以带来级 ##","categories":[],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"}]},{"title":"EX数据结构","slug":"Template/数据结构/ex数据结构","date":"2019-04-28T02:46:22.952Z","updated":"2019-04-28T06:08:20.155Z","comments":true,"path":"2019/04/28/Template/数据结构/ex数据结构/","link":"","permalink":"http://arintaro.com/2019/04/28/Template/数据结构/ex数据结构/","excerpt":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。","text":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。 EX堆-配对堆@card{ 请不要对我抱有会写斐波那契堆的期望。 $test\\ site: $&lt; https://lydsy.com/JudgeOnline/problem.php?id=3040&gt; $task:$ 实现配对堆完成最短路，每次$push$输入节点编号，$top$返回最短点的节点编号，注意空间要求$O(n)$，也就是说您要实现一个内存池。 $note: $维护这种多重编号映射，一定要列表需要维护的东西 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pii pair&lt;int, int&gt;template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000000 + 10;const int maxm = 10000000 + 10;const int inf = 0x7f7f7f7f;lint dist[maxn];struct Heap&#123;&#125;q;int n, m, s;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;void calc_sp() &#123; memset(dist, 0x7f, sizeof(lint) * (n+1)); dist[s] = 0, q.push(s); while(!q.empty()) &#123; int x = q.top(); q.pop(); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &gt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; q.update(y); &#125; &#125; &#125;&#125;int main() &#123; int T, nu, nv, nw; lint x = 0, y = 0, a, b; lint rxa, rxc, rya, ryc, rp; readint(n), readint(m), s = 1; readint(T), readint(rxa), readint(rxc), readint(rya), readint(ryc), readint(rp); while(T--) &#123; x=(x*rxa+rxc)%rp; y=(y*rya+ryc)%rp; a=min(x%n+1,y%n+1); b=max(y%n+1,y%n+1); addedge(a, b, 1e8 - 100 * a); &#125; while(m--) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); &#125; calc_sp(); printf(\"%lld\\n\", dist[n]); return 0;&#125; } 2.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/categories/数据结构/"}],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"},{"name":"新科技","slug":"新科技","permalink":"http://arintaro.com/tags/新科技/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"}]},{"title":"基础图论模板","slug":"Template/图论/基础图论","date":"2019-04-27T13:23:23.969Z","updated":"2019-05-08T08:04:19.163Z","comments":true,"path":"2019/04/27/Template/图论/基础图论/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/图论/基础图论/","excerpt":"需要$3min$内实现任意一个","text":"需要$3min$内实现任意一个 负环的判定@card{ $test\\ site: $https://www.luogu.org/problemnew/show/P3385 $task: $ 600ms以内判定负环，请注意，有多组数据，要求实现clear函数（包括邻接表 $tips: $ 对于$O(NM)$能跑过去复杂度正确的，建议写$BFS_SPFA + SLF_SWAP$，复杂度不对的写$DFS$ $extra:?$?”同时记录节点入队次数”、”卡时” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int arr[maxn]; int l, r, size; inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125; inline void push(int x) &#123; if(r == size) r = 0; arr[++r] = x; &#125; inline int pop() &#123; if(l == size) &#123;l = 1; return arr[size]; &#125; return arr[l++]; &#125; inline bool empty() &#123; return l == r + 1; &#125;&#125;q;void clear() &#123; &#125;bool check() &#123; &#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? &quot;YE5&quot; : &quot;N0&quot;); &#125; return 0;&#125; } 邻接表的删除操作card{ 可以维护一个删除标记，但是这么做在有些算法里会导致复杂度(空间or时间)退化，具体测试可以去写即时删除的配对堆。 显然我们可以再维护一个$pre$域，像普通链表一样删除，但是过于麻烦，我们可以直接把这条边的数据与表头交换，然后让表头指向下一个，但是这么做会导致边序号乱序，需要注意成对变换等对边序号有要求的信息。 } SPFA求最长路card{ 我们经常写$DJ$，也经常写最短路，但是最长路+$SPFA$我第一次写的时候却挂了。。 $test\\ stie: $ https://www.acwing.com/activity/content/code/content/34854/ $task:$ 实现循环队列，初始化$dist[1] = 0$，求最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair(x, y)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * (maxn + maxn);int n, max_val;int dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int q[maxn]; int l, r, size;&#125;q;void calc_sp() &#123; &#125;int main() &#123; int nu, nv, nw; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); nu += 1, nv += 2; // 节点编号[1, 50002] addedge(nu, nv, nw); max_val = max(max_val, max(nu, nv)); &#125; for(rint i=1; i&lt;=max_val-1; i++) addedge(i, i+1, 0), addedge(i+1, i, -1); calc_sp(); printf(\"%d\\n\", dist[max_val] - dist[1]); return 0;&#125; } 无向图的割边card{ $test\\ site: $https://www.acwing.com/problem/content/365/ $task: $实现判断割边，处理出搜索树的$deep$，$fa$数组，并在割边的子节点上标记$val[y] = 1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * 2 * maxn;int n, m, root = 1;int ans = 0;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int dfn[maxn], low[maxn], tot = 0;int deep[maxn], val[maxn], fa[maxn];void dfs(int x, int ind) &#123; low[x] = dfn[x] = ++tot; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == ind) continue; if(!dfn[y]) &#123; deep[y] = deep[x] + 1, fa[y] = x, dfs(y, i ^ 1); low[x] = min(low[x], low[y]); if(low[y] &gt; dfn[x]) val[y] = 1, ans++; &#125;else low[x] = min(low[x], dfn[y]); &#125;&#125;void clear() &#123; ans = tot = 0, totedge = 1; memset(head, 0, sizeof(int) * (n+1)); memset(dfn, 0, sizeof(int) * (n+1)); memset(val, 0, sizeof(int) * (n+1));&#125;int mem[maxn];void ask(int x, int y) &#123; int res = 0, s = 0; if(deep[x] &lt; deep[y]) swap(x, y); while(deep[x] &gt; deep[y]) &#123; mem[++s] = x, x = fa[x]; &#125; while(x != y) &#123; mem[++s] = x, mem[++s] = y; x = fa[x], y = fa[y]; &#125; for(rint i=1; i&lt;=s; i++) &#123; res += val[mem[i]], val[mem[i]] = 0; fa[mem[i]] = x; &#125; ans -= res;&#125;int main() &#123; int T = 0; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; clear(); printf(\"Case %d:\\n\", ++T); while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(root, 0); readint(m); while(m--) &#123; readint(nu), readint(nv); ask(nu, nv); printf(\"%d\\n\", ans); &#125; puts(\"\"); &#125; return 0;&#125; $Solution:$ 注意父节点来的边不能更新，具体用成对变换实现，割点不用记录，都能更新，但是要注意，按照常规割点定义，根节点必须有俩儿子“大于等于”，才能判断是，割边则是“大于”。 } 无向图的$v-dcc$缩点 + 二分图判定@card{ $test\\ site:​$ https://www.acwing.com/problem/content/367/ $task:$ 划分出图中的每个$vdcc$，并判定其是否是二分图（是否存在奇环），是的话将其每个节点的$suc$值设为$1$，并实现多组数据的清空函数 $note:$ 现用现标记，解决割点重叠问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e6 + 4 * maxn;int n, m;int edge[maxn][maxn];int head[maxn], nxt[maxm], ev[maxm], totedge = 1;inline void addedge(int x, int y) &#123; ev[++totedge] = y, nxt[totedge] = head[x], head[x] = totedge;&#125;int main() &#123; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; while(m--) readint(nu), readint(nv), edge[nu][nv] = edge[nv][nu] = 1; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=i+1; j&lt;=n; j++) &#123; // 虽然在完全图上用邻接表十分弱智,但可以降低常数 if(!edge[i][j]) addedge(i, j), addedge(j, i); &#125; &#125; int ans = 0; for(rint i=1; i&lt;=n; i++) ans += (suc[i] == 0); printf(\"%d\\n\", ans); clear(); &#125; return 0;&#125; } 欧拉回路的具体方案 $test\\ site:$ https://www.acwing.com/problem/content/368/ $task:$ 寻找一个从$1$出发，遍历所有边两次的具体方案，保证有解。 $tips:$ 注意入栈方法的实际含义。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e4 + 10;const int maxm = 1e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans[maxm], tot = 0;int s[maxm], top = 0;void solve() &#123; &#125;int main() &#123; int nu, nv; readint(n), readint(m); while(m--) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu); solve(); for(rint i=1; i&lt;=tot; i++) printf(\"%d\\n\",ans[i]); return 0;&#125; 7.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"基础数据结构","slug":"Template/数据结构/基础数据结构","date":"2019-04-27T12:44:23.105Z","updated":"2019-09-23T12:08:27.416Z","comments":true,"path":"2019/04/27/Template/数据结构/基础数据结构/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/数据结构/基础数据结构/","excerpt":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。","text":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。 循环队列@card{ $test \\ site:$https://www.luogu.org/problemnew/show/P3385 $task:$实现一个循环队列，要求有$empty \\ \\ push\\ init(O(1))\\ \\ pop\\ \\ front $ $note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// test site: https://www.luogu.org/problemnew/show/P3385// task: 实现一个循环队列，要求有empty push init(O(1)) pop front // note: 一般用于需要多次清空队列且已知\"队列里同时存在的最多元素数量\"，// 比起STL的queue，手写的可以O(1)清空。 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; &#125;q;int cnt_path[maxn], dist[maxn];bool inq[maxn];void clear() &#123; totedge = 0; q.init(); memset(head, 0, sizeof(int) * (n+1)); memset(inq, 0, sizeof(bool) * (n+1)); memset(cnt_path, 0, sizeof(int) * (n+1)); memset(dist, 0x3f, sizeof(int) * (n+1));&#125;bool check() &#123; q.push(start), dist[start] = 0; while(!q.empty()) &#123; int x = q.pop(); inq[x] = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[x] + ew[i] &lt; dist[y]) &#123; dist[y] = dist[x] + ew[i]; cnt_path[y] = cnt_path[x] + 1; if(cnt_path[y] &gt; n) return 1; if(!inq[y]) q.push(y), inq[y] = 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? \"YE5\" : \"N0\"); &#125; return 0;&#125; $Solution:$ 懒得写了，自己看代码吧 } 2.#### 整数hash表@card{ $Test Site:https://www.luogu.org/problem/CF670C $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pll pair&lt;lint, lint&gt;#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair((x), (y))template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 200000 * 3 + 10;const int mod = 599899;int arr[maxn];int n, m, totid;struct mhash&#123; int head[maxn], nxt[maxn], eco[maxn], tot; int pre[maxn], suf[maxn]; int find(int x) &#123; int nu = x % mod + 1; //别忘了+1 for(rint i=head[nu]; i; i=nxt[i]) &#123; if(pre[i] == x) return suf[i]; &#125; return 0; &#125; void insert(int x, int y) &#123; int nu = x % mod + 1; nxt[++tot] = head[nu], head[nu] = tot, pre[tot] = x, suf[tot] = y; &#125;&#125;ht;int ry[maxn], dz[maxn], dy[maxn];int cnt[maxn];int ansid = 1, ansy = -1, ansz = -1;int main() &#123; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(ry[i]); int t = ht.find(ry[i]); if(t == 0) t = ++totid, ht.insert(ry[i], t); cnt[t]++; &#125; readint(m); for(rint i=1; i&lt;=m; i++) readint(dy[i]), dy[i] = ht.find(dy[i]); for(rint i=1; i&lt;=m; i++) readint(dz[i]), dz[i] = ht.find(dz[i]); for(rint i=1; i&lt;=m; i++) &#123; if(cnt[dy[i]] &gt; ansy || (cnt[dy[i]] == ansy &amp;&amp; cnt[dz[i]] &gt; ansz)) ansid = i, ansy = cnt[dy[i]], ansz = cnt[dz[i]]; &#125; printf(\"%d\\n\", ansid); return 0;&#125; }3.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数据结构","slug":"模板/数据结构","permalink":"http://arintaro.com/categories/模板/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://arintaro.com/tags/队列/"}]},{"title":"LNOI2019 & 多省联考 游记","slug":"Essay/LNOI2019 & 多省联考 游记","date":"2019-04-27T09:01:25.797Z","updated":"2019-04-27T13:03:09.425Z","comments":true,"path":"2019/04/27/Essay/LNOI2019 & 多省联考 游记/","link":"","permalink":"http://arintaro.com/2019/04/27/Essay/LNOI2019 & 多省联考 游记/","excerpt":"","text":"Day1:待更，鸽了","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"无病呻吟","slug":"无病呻吟","permalink":"http://arintaro.com/tags/无病呻吟/"}]},{"title":"综合技巧与实践","slug":"Detail/综合技巧与实践","date":"2019-04-27T09:01:25.547Z","updated":"2019-10-11T12:04:41.167Z","comments":true,"path":"2019/04/27/Detail/综合技巧与实践/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/综合技巧与实践/","excerpt":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。","text":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。 一、STL相关@card{ 1.algorithm12345678910111213141.lower_bound &amp; upper_bound //我就算饿死，死外面，也不会自己写一个二分查找的 int pos = lower_bound(arr+1,arr+n+1,val) - arr; //在有序数组[1,n]中查第一个 &gt;=val的数 // 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater2.unique //常用于离散化 n = unique(arr+1,arr+n+1) - (arr+1); //去重，新元素存在[1,n] 3.inplace_merge merge // 常用于CDQ分治中，不要cdq里套sort了！！ // 数组 arr分为有序的两部分 [1,mid] [mid+1,n] inplace_merge(arr+1,arr+mid+1,arr+n+1); merge(first1,last1,first2,last2,result,compare);4.nth_element //数组中O(n)找第k大，前k个数一定都在[1，k] nth_element(arr+1,arr+k,arr+n+1);5.sort stable_sort // 后一个可以稳定排序 6.reverse // 跟sort传参一样，序列反转 7.next_permutation, prev_permutation //排列 2.vector121.vector的clear不会释放空间，需要释放空间的话，需要: vector&lt;int&gt;().swap(a); // 但是几乎比clear慢一倍 3.输入输出相关11.cin.getline(s+1, len+1, '\\0'); // 字符数组、长度、结束字符 4.cmath11.round(double x); // 返回四舍五入的整数 %.0lf也可以 } 二、NOI Linux相关@card{ ​ 1.Emacs相关（M为Alt键，C为Ctrl键 - M+x输入命令 C+x+k关闭当前窗口 - Options-Use CUA Keys (转换复制粘贴快捷键) - Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题） - Options-Set Default Font - Ubuntu Mono 20-30（变更字体 - C-x-2 水平切分当前Buffer, C-x-3 左右切分 - M-% 替换 - C-R 查找 - 命令 Find-file后， ~/.emacs 可以直接打开配置文件 123456789101112131415161718192021(global-linum-mode t) ;;line num 显示行号(setq c-basic-offset 3) ;; 变更缩进(setq default-tab-width 3) (electric-pair-mode t) ;;electric pair 括号补全(electric-layout-mode t)(electric-indent-mode t)(setq-default cursor-type 'bar) ;;光标竖线(show-paren-mode t) ;;show paren 括号配对(global-set-key [f4] 'shell) ;;摁F4进入shell(defun compile-file()(interactive)(compile(format \"g++ -o '%s' '%s' -lm -Wall -g\"(file-name-sans-extension(buffer-name))(buffer-name))))(global-set-key [f5] 'compile-file) ;;摁F5编译(global-set-key [f6] 'gdb) ;;摁F6进入gdb调试(global-set-key (kbd \"C-s\") 'save-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"C-a\") 'mark-the-whole-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"RET\") 'newline-and-indent) ;;回车自动缩进 } 四、对拍相关@card{ 1.程序运行时间12double t = clock();cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl; 1234#### 2.diff命令```diff -b -B test.out ans.out``` }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"STL","slug":"STL","permalink":"http://arintaro.com/tags/STL/"},{"name":"Linux","slug":"Linux","permalink":"http://arintaro.com/tags/Linux/"},{"name":"Emacs","slug":"Emacs","permalink":"http://arintaro.com/tags/Emacs/"}]},{"title":"常见代码实现细节","slug":"Detail/常见代码实现细节","date":"2019-04-27T09:01:25.528Z","updated":"2019-10-23T13:54:21.232Z","comments":true,"path":"2019/04/27/Detail/常见代码实现细节/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/常见代码实现细节/","excerpt":"","text":"这里记录的问题，全是我调过的问题orz。 &lt;!– more – &gt; @card{ 我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码 } 一、变量溢出问题@card{ 乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘 int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long， unsigned类型：值域$[0,2^{8size}-1]$溢出后对$2^{8size}$取模。 signed类型: 值$[-2^{8size-1},2^{8size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。 long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数 double用memset初始化时，跟int型一样的最值用max: 0x42, min: 0xc2,，极限值max: 0x7f, min: 0xfe。 在long long数据范围使用左移时，一定得用1LL防止溢出。 } 二、运算问题@card{ 有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数 要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除 做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值， 维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf 注意非负整数与“正整数”的区别，值域里可能会有0 有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。 } 三、语言问题@card{ 有时需要注意\\n \\r的问题，建议写手动读入的时候直接特判掉 宏定义千万别忘了括号，调一辈子，一般来说”有分割”的东西，不用加括号 lint 输入输出 %lld，ldob输入输出 %Lf 数组作为形参会退化成指针，不能再用sizeof求大小 题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0 程序中常量默认是INT型，设定 long long a = 10000 9999 9998 等一定要注意常量爆INT的问题 使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉 写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等 维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义 计算某些东西时，如果计算后需要移动指针，注意别先移动指针了（Acwing 294, 倍增LCA等） 写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧 维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。 } 四、数学相关@card{ 1. BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$ 123if(Z == 1) return 0; //Luogu P2485 [SDOI2011]计算器if(Y % P == 0) return Z%P == 0 ? 1 : -1; i*len - ht[Yk] &gt;= 0 2. 无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况 3. exgcd会求出负数解，如果求出的东西需要最小非负整数解，或者作逆元等，一定要取模到正数。 4. 如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的 5. 计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\\ ||\\ m&lt;0\\ ||\\ n&lt;0$时0种方案 6. 试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于 } 五、数据结构相关@card{ 1. 维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1] 2. 分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错 3. 分块题开数组不要开混了 4. 在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数” 5. 常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2 6. 静态线段树空间直接开4*n防越界，动态开点的范围为 $[mlog_2m, 2*n-1]$ 7. 翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放 8. 下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响 9. pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去 10. 在操作任何“实点”前需要pushdown，在修改后需要pushup 11. 将操作重新排序后，注意是删除操作优先，还是增加操作优先 12. 邻接表 i=nxt[i], 千万别写成 i=nxt[x] 13. 如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。 14. 有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。 15. 有时需要特判“不存在”、”没找到“的情况 16. 写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空**相关**指针，大部分情况数据清不清无所谓。 17. 值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域。 18. 树链剖分第二次$DFS$别忘了跳过重儿子。 19. Trie树一开始有个根节点，初始化时总节点数要设为1. 20. 维护不相交区间的问题，可以定义小于号为$a.r &lt; b.l$，这样完全在左为小于，完全在右为大于，剩下的相等即相交 } 六、图论相关@card{ 如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。 邻接矩阵注意初值是0还是inf，无向边一定要记得加两遍！！ 在有负权边时，树的直径不能通过两次DFS求。 无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。 带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。 在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。 建虚点，平移编号后一定要注意读入后别忘平移，节点数别忘增加。 有向图的$scc$，注意更新$low[x]$时，需要判断节点是否在栈里，回溯时判断并出栈。 无向图的$e-dcc$, 需要注意记录的是“来的边”，而不是父节点，来处理重边问题，回溯时判断并出栈，解决根节点的问题 无向图的$v-dcc$，需要注意按常规割点定义，搜索树的根节点需要有俩儿子判定成功，且割点会属于多个$v-dcc$，建议回溯到父节点时判断儿子，根节点需要特判。 缩点相关的题注意边界情况，缩成一个点等特殊情况。 找环后别忘了$tot+1$存的是最后一个节点到第一个节点的长度 } 七、动态规划相关@card{ 要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \\forall j \\ \\ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。 状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$ 有不合法状态的递推时，一定要考虑“某个现在不合法的状态”，能否在以后变成一个合法状态，能的话不能直接不计算它，为了它后置状态的正确转移必须要计算它。 } 八、杂项@card{ 题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;= 一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1 在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。 交换变量时，注意变量的附带属性别忘了一起交换。 有时候题目中可能不存在“能解决所有数据、能处理所有情况“的单一算法，注意大力讨论。 进行思考、推导时，一定要注意前提条件，例如“一定可以从这个点出发找到另一个点”，这个点真的存在么？$n=1$时还存在么？ 数组复用时，一定得是“赋值”，才不用清零，如果直接用++了，别忘了清零。 用前缀和时，千万别忘了还可以取整个前缀即“ - arr[0]” 写搜索时，中间的剪枝立即回溯前也别忘了还原现场。 开邻接矩阵时，有时会有重边，注意后面覆盖前面的问题 无论是倍增还是二分答案，尽量让指针保持在定义域内，不要让其自然溢出。 我们常用的1-index下标遇上模循环节的时候一定要注意，多举反例 一定要考虑边界状况, $n = 1$或$m = 1$时算法是否还能成立。 } 九、奇异的语言细节@card{ 123456// 形参中的表达式一定会被计算，但是C++标准并没有规定参数的求值顺序void test(int x,int y)&#123; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;&#125;test(++x,x); // 输出 1 1test(++x,x-1); // 输出1 -1 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"OI中的常见解题思路与技巧（更新中）","slug":"Detail/OI中的常见解题思路与技巧","date":"2019-04-27T09:01:25.509Z","updated":"2019-10-24T08:18:15.618Z","comments":true,"path":"2019/04/27/Detail/OI中的常见解题思路与技巧/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/OI中的常见解题思路与技巧/","excerpt":"也许很有用，也许没什么卵用。","text":"也许很有用，也许没什么卵用。 一、最优化问题@card{ 1. ###### 二分答案：答案具有“单调性”，外层花费$log\\ ans$的时间转化为判定性问题 - 答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的 - 二分出的答案对check的进行有所帮助 2. ###### 动态规划：一定要有最优子结构性质 3. ###### 贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件。 - 可以小范围搜索+多重限制贪心乱搞，说不定就骗到了100pts呢，考试的时候要~~勇于乱搞，敢于乱搞~~ - 一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质。 - 出题人是傻的，数据是水的，贪心+暴力是能过的，是能$AC$的。 } 二、计数概率期望问题@card{ 1. ###### 思路 - 绝大多数是动态规划, 少部分是纯数学推式子 2. ###### 计数 - 构造划分基点, 确立无重分类 3. ###### 概率 - 讨论所有情况, 应用全概率公式与条件概率 4. ###### 期望 - 状态设计绝大多数采用逆推, 即在DAG上该点到终点的期望价值 - 逆推转移即为每种转移的概率乘(转移代价与后续的期望价值), 注意概率和一定要为1 - 若有存在多种决策影响价值计算, 求一种最优期望的决策, 状态中记录影响价值计算的决策即可, 注意不能记录&quot;概率成功&quot;的决策结果 - 一定要确定给出的概率是&quot;顺推概率&quot;, 还是&quot;逆推概率&quot; 5. } 三、数据结构题@card{ } 四、数学题@card{ 1. ###### 求和题：核心思想：[交换求和顺序] } 五、图论问题@card{ } 六、搜索优化策略@card{ 1. ###### 优化搜索顺序 - 即从“后续变化较少”的状态开始搜 - 搜前排序 2. ###### 排除等效亢余 - 给搜索固定一个顺序，例如二元组(x, y)与(y, x)不要反复搜 - 例如往盒子里放东西，一个东西放在不同的“空盒子”即是等效的 3. ###### 贪心 - 考虑在一个状态下做了什么决策比另一些决策更优秀 4. ###### 可行性、最优性剪枝 / 估价函数 - 即“最理想的方法”都无法满足可行或可更新答案 - 估价函数必须比实际路径非严格更优 - 有时候与范围相关的可以通过不等式放缩来去掉一些状态 5. ###### 双向搜索 } 七、动态规划优化策略@card{ 1. ###### 费用提前/延后计算 - 没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算 2. ###### 环形的处理 - 一次断开、一次强制连接，以覆盖所有情况 - 破环成链、倍增环长 3. ###### 后效性的处理 - 有分阶段后效性，阶段内部按环形处理 - 高斯消元（构造复杂度更优的消元方式） - 对某个值域范围特别小的部分进行状压压缩, 部分状压解决有限后效性 4. ###### 状态压缩的优化 - 预处理合法状态和每个状态合法的前置状态 5. ###### 矩阵快速幂 - 递推轮数很长，方程不变 6. ###### 快速幂与倍增 - $dp[x]$与$dp[y]$ 能推出 $dp[x + y]$ 就可应用倍增或者快速幂 - DAG上的多次询问问题经常需要倍增，“预处理与拼凑” 7. ###### 分离无关变量 - 让每个决策$j$的价值只与$j$有关，在$i$增大时，每个决策的价值不变，这样就容易维护最优决策 - 分段转移时，方程里尽量别写“段的长度”，而是写成$i-j$，即当前与决策点的距离 8. ###### 确定计算顺序 - DP的核心是分阶段，高度有序的计算，一般可以利用贪心先确定计算顺序，以此应用DP 9. ###### 决策单调性 - 一维状态下尽量打表，不考虑证明，具体可用一个队列维护最优决策，每次状态更新后二分地去更新后面的最优决策 - 二维区间DP的决策单调性 $P[i, j-1] &lt;= P[i, j] &lt;= P[i+1，j]$ 10. ###### 确定划分基点，构造无重分类 } 七、常见有用思想与技巧、性质@card{ 1. ###### 正难则反：广泛应用于各种问题 - 答案不容易求、不容易划分，利用全集减去补集从而求出答案 - 字典序最小的方案：结合性质7，倒序处理 - 对某个点关于其他点的计算问题，可以转化为其余点对它的贡献 2. ###### 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数 3. ###### 凹凸性（二阶导数）：凸壳优化 4. ###### 对称性：优化枚举顺序、减少计算量 5. ###### 等效转换：常见于需要计算一些奇怪的东西，找出性质转化成别的问题。 6. ###### 递归处理：原问题可以划分为几个相同的子问题 7. ###### “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于 - 例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于 - 试填法、字典序 8. ###### 树上、序列上的差分与前缀和 - 某些计数问题可以转化为 F(x)为至少满足x的有多少个，则满足X的答案为F(x) - F(x+1). 9. ###### 不对原数据处理，而是“对询问” 10. ###### 确定计算顺序 - 在某些“每个点都需要满足xx条件”时，如果确定了一种“如果这个条件现在不满足，以后都满足不了”的计算顺序，就可以贪心的考虑了 12. ###### 离散化 - 不关心集合中的数的具体大小，只关心其相对大小，映射成1-size的整数 - 在计数问题中作为等效性的一种应用 13. ###### 先考虑去掉限制条件、缩小数据范围的情况 - 之后再逐步扩大，如DP先考虑没有限制条件的情况，再通过转移范围约束 - 考虑退化情况，树转化成图 - “要是这样就好了” =&gt; “怎么样能变成这样” 14. ###### 用适当的枚举与计算顺序覆盖所有情况 15. ###### 调整法 - 先求出一组可行解, 在逐步调整至最优解 16. ###### 划分决策集合 - 全部决策集合不容易维护, 考虑按某种性质划分成多个集合, 集合内部满足单调性等优秀性质 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"NOIP2018 D1T3 赛道修建","slug":"Contest/NOIP 2018/road","date":"2019-04-27T09:01:25.456Z","updated":"2019-10-24T05:41:57.528Z","comments":true,"path":"2019/04/27/Contest/NOIP 2018/road/","link":"","permalink":"http://arintaro.com/2019/04/27/Contest/NOIP 2018/road/","excerpt":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。","text":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。 Description:@card{ 给定一棵带权树，要求从树上划分出$m$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \\times 10^4$级别（实际上可以出到$5\\times10^5$左右，边权再缩小点甚至能更大，卡$sort$?(雾 } Solution:@card{ 分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助。 发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。 能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。考虑性质1：每条路径对答案的贡献其实是相同的，都是$1$，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之性质2：父节点只能有一条路径到当前节点，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在保证配对数最大的同时，还要保证剩下的深度最大，从而上传给父节点。 至此，我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下： 给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。 这里网上通常有三种实现形式，我从复杂到简洁讲： 算法1：贪心+平衡树/双向链表、删除标记首先，我们显然有性质1：应该优先配对较小的深度。 如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。 然后，我们有性质2：最优方案中，每个最小值都应该与能配对的最小的数配对，显然，不证了。基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \\ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（期望得分：55分，实际得分：100分 算法2：双指针+栈一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是能配对的最小的数。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。 STD算法：双指针那么有没有不用栈，常数更加优秀（并没有，更加简洁的算法呢？有，就是本题的std1。基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j$，配对到了左指针$i$，如果$j-1$不能与$i$配对，那么剩下的右指针也显然配对不了，所以$i$必须得与$j$配对，这时我们更新$last = j - 1$即可，如果最后考虑一个右指针$j$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]$成功配对的右指针平移到$[j,last-1]$，然后用$last$对应的值更新上传的最大值。由于网上$blog$没有对这个算法的讲解，$std$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std$在干什么。。 这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\\frac{\\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，从而实现了卡sort的可能。还有俩剪枝，二分上界可以设到$min{\\frac{\\sum{w_i}}{m}}{d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;const int rid = 8;int n, m;int root = 1, sumw = 0;int temp[maxn], rcnt[1&lt;&lt;rid], rmod = (1 &lt;&lt; rid) - 1;inline void rsort(int arr[], int n) &#123; if(n &lt; 256) &#123; sort(arr+1, arr+n+1); return; &#125; for(rint i=0; i&lt;=31; i+=rid) &#123; memset(rcnt, 0, sizeof(rcnt)); for(rint k=1; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++; for(rint j=1; j&lt;=rmod; j++) rcnt[j] += rcnt[j-1]; for(rint k=n; k&gt;=1; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k]; memcpy(arr, temp, sizeof(int) * (n+1)); &#125;&#125;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;int arr[maxn], dist[maxn];int dfs(int x, int fa, int mid) &#123; int res = 0, tot = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else arr[++tot] = dist[ev[i]] + ew[i]; &#125; rsort(arr, tot), dist[x] = 0; for(rint i=1, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123; while(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++]; if(i == j) &#123; dist[x] = arr[last]; break; &#125; if(j &amp;&amp; arr[i] + arr[j-1] &lt; mid) last = j-1; if(res &gt;= m) return res; &#125; return res;&#125;int maxd, dp[maxn];void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]); dp[x] = max(dp[x], dp[y] + ew[i]); &#125;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs2(root, root); int l = 1, r = min(maxd, sumw / m); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; } @card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define sit multiset&lt;int&gt;::iteratortemplate&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;int n, m;int root = 1;int sumw = 0, dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;multiset&lt;int&gt; s;int dfs(int x, int fa, int mid) &#123; int res = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; dist[x] = 0, s.clear(); for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else s.insert(dist[ev[i]] + ew[i]); &#125; for(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; // nxt一定在it后面 sit nxt = s.lower_bound(mid - (*it)); if(nxt == it &amp;&amp; nxt != s.end()) nxt++; if(nxt == s.end()) &#123; it++; continue; &#125; s.erase(nxt), s.erase(it++), res++; // 注意先删nxt, 不然it++可能等于nxt if(res &gt;= m) return res; &#125; if(!s.empty()) dist[x] = *s.rbegin(); return res;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; int l = 1, r = sumw / 2; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; }","categories":[{"name":"比赛","slug":"比赛","permalink":"http://arintaro.com/categories/比赛/"},{"name":"NOIP2018","slug":"比赛/NOIP2018","permalink":"http://arintaro.com/categories/比赛/NOIP2018/"},{"name":"题解","slug":"比赛/NOIP2018/题解","permalink":"http://arintaro.com/categories/比赛/NOIP2018/题解/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"}]},{"title":"树的相关性质(更新中)","slug":"Algorithm/树的相关性质","date":"2019-04-27T09:01:25.373Z","updated":"2019-09-26T09:29:08.998Z","comments":true,"path":"2019/04/27/Algorithm/树的相关性质/","link":"","permalink":"http://arintaro.com/2019/04/27/Algorithm/树的相关性质/","excerpt":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。","text":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。 一、树的直径@card{ （一）求法： 两次DFS比较容易求出具体路径，缺点是实现比树形DP麻烦，并且要求树的边权非负。 树形DP实现简单，但求具体路径比较麻烦，适用于只需要直径长度的情况（如二分答案的上界剪枝等），对边权没有要求。 （二）性质： 基本思想：分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。 任意一个节点作根，直径两端点一定是叶子节点。 距离任意点最远的点一定是直径的一个端点。（相当有用的性质 设从A出发找到最远点B 如果A已经是直径上一个端点，正确性显然。 如果不是，考虑反证，设直径为CD。 由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。 则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。 树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分(必须边，且除这部分外，无其他公共部分)，并且共侧的直径一段长度必然相等。 显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。 如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。 如果除这部分还有公共部分，就会形成一个环。 对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。 如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。 往一棵树里加一个点，直径的端点最多改变一个 先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。 （三）在具体题目下的证明例子 NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，然而原题不要求证明这些东西 在任意直径上求最小偏心距都相等 考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。 考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。 逃学的小孩 题意为树上要求选一个起始点与俩终点，要求最大化“起始点到两终点距离较小的+两终点的距离” 显然我们应该让直径作为这个“两个终点的距离”（如果你觉得并不显然：可以考虑三个点$A、B、C$，有三条路径$AB, BC, AC$，可以发现，如果令其中次长或最小的作为“两终点间的距离“，都没有令最长的作为优） 然后分别从直径上各个点出发暴力找起点即可。 } 二、树上点集路径","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://arintaro.com/categories/算法/图论/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"优雅的O(1)下取整log2","slug":"Template/小工具/log2的姿势","date":"2019-04-27T09:01:25.331Z","updated":"2019-04-27T13:10:15.091Z","comments":true,"path":"2019/04/27/Template/小工具/log2的姿势/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/小工具/log2的姿势/","excerpt":"还能不能再给力点呢？","text":"还能不能再给力点呢？ 1.转double法@card{ double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，几乎是$O(1)$的。请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可） 123456#define lint long longinline lint mlog2(lint x)&#123; if(x == 1) return 0; double t = (double)x; return (lint)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1; // 注意最前面还要再转一次long long&#125; Luogu ST表 传统打表法 1011ms https://www.luogu.org/recordnew/show/13493959Luogu ST表 double法 1009ms https://www.luogu.org/recordnew/show/18155615实测后发现速度差异不大, 开了O2打表会快一些 } 2.打表法@card{ 显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论 $$\\forall k \\in [0,35], 2^kmod\\ 37,\\ 取遍[1,36]$$ } 3.double法的具体测试@card{ $test\\ site:$https://www.luogu.org/problemnew/show/P3865 $task:$ 实现函数mlog2，需要$O(1)$返回$\\lfloor log_2{x} \\rfloor​$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// test site: https://www.luogu.org/problemnew/show/P3865// 要求：实现函数mlog2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define rint register int#define lint long longusing namespace std;const int maxn = 1e5 + 10;int n, m, logn;int arr[maxn];inline lint mlog2(lint x) &#123; &#125;int rmq[20][maxn];inline void getrmq() &#123; for(rint i=1; i&lt;=n; i++) rmq[0][i] = arr[i]; for(rint d=1; d&lt;=logn; d++) &#123; int len = (1 &lt;&lt; d), half = (1 &lt;&lt; (d-1)); for(rint i=1; i+len-1&lt;=n; i++) &#123; rmq[d][i] = max(rmq[d-1][i], rmq[d-1][i+half]); &#125; &#125;&#125;inline int ask(int l, int r) &#123; int loglen = mlog2(r - l + 1); return max(rmq[loglen][l], rmq[loglen][r-(1&lt;&lt;loglen)+1]);&#125;int main() &#123; readint(n), readint(m); logn = ceil(log2(n)); for(rint i=1; i&lt;=n; i++) readint(arr[i]); getrmq(); int nl, nr; while(m--) &#123; readint(nl), readint(nr); printf(\"%d\\n\",ask(nl,nr)); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]}]}