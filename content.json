{"meta":{"title":"Rintaro's Blog","subtitle":"Algorithm and Anime","description":"某弱省一弱校高一OIer","author":"Rintaro","url":"http://arintaro.com","root":"/"},"pages":[{"title":"","date":"2019-05-04T12:17:25.880Z","updated":"2019-04-27T07:31:21.041Z","comments":false,"path":"categories/index.html","permalink":"http://arintaro.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"小型冷门知识点汇总","slug":"Algorithm/小型冷门知识点汇总","date":"2019-04-28T06:06:16.512Z","updated":"2019-04-28T06:11:11.106Z","comments":true,"path":"2019/04/28/Algorithm/小型冷门知识点汇总/","link":"","permalink":"http://arintaro.com/2019/04/28/Algorithm/小型冷门知识点汇总/","excerpt":"","text":"图论 Johnson 算法 $site:$ https://zhuanlan.zhihu.com/p/48523094 用途：用下界$O(NM)$的时间消除图内所有负权边。 ##","categories":[],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"}]},{"title":"EX数据结构","slug":"Template/数据结构/ex数据结构","date":"2019-04-28T02:46:22.952Z","updated":"2019-04-28T06:08:20.155Z","comments":true,"path":"2019/04/28/Template/数据结构/ex数据结构/","link":"","permalink":"http://arintaro.com/2019/04/28/Template/数据结构/ex数据结构/","excerpt":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。","text":"所谓的EX，并不是指很厉害的数据结构，是指”额外的”。简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。 EX堆-配对堆@card{ 请不要对我抱有会写斐波那契堆的期望。 $test\\ site: $&lt; https://lydsy.com/JudgeOnline/problem.php?id=3040&gt; $task:$ 实现配对堆完成最短路，每次$push$输入节点编号，$top$返回最短点的节点编号，注意空间要求$O(n)$，也就是说您要实现一个内存池。 $note: $维护这种多重编号映射，一定要列表需要维护的东西 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define pii pair&lt;int, int&gt;template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1000000 + 10;const int maxm = 10000000 + 10;const int inf = 0x7f7f7f7f;lint dist[maxn];struct Heap&#123;&#125;q;int n, m, s;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;void calc_sp() &#123; memset(dist, 0x7f, sizeof(lint) * (n+1)); dist[s] = 0, q.push(s); while(!q.empty()) &#123; int x = q.top(); q.pop(); for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[y] &gt; dist[x] + ew[i]) &#123; dist[y] = dist[x] + ew[i]; q.update(y); &#125; &#125; &#125;&#125;int main() &#123; int T, nu, nv, nw; lint x = 0, y = 0, a, b; lint rxa, rxc, rya, ryc, rp; readint(n), readint(m), s = 1; readint(T), readint(rxa), readint(rxc), readint(rya), readint(ryc), readint(rp); while(T--) &#123; x=(x*rxa+rxc)%rp; y=(y*rya+ryc)%rp; a=min(x%n+1,y%n+1); b=max(y%n+1,y%n+1); addedge(a, b, 1e8 - 100 * a); &#125; while(m--) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); &#125; calc_sp(); printf(\"%lld\\n\", dist[n]); return 0;&#125; } 2.","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/categories/数据结构/"}],"tags":[{"name":"然而并没有什么卵用","slug":"然而并没有什么卵用","permalink":"http://arintaro.com/tags/然而并没有什么卵用/"},{"name":"新科技","slug":"新科技","permalink":"http://arintaro.com/tags/新科技/"},{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"}]},{"title":"基础图论模板","slug":"Template/图论/基础图论","date":"2019-04-27T13:23:23.969Z","updated":"2019-04-29T04:30:29.568Z","comments":true,"path":"2019/04/27/Template/图论/基础图论/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/图论/基础图论/","excerpt":"需要$3min$内实现任意一个","text":"需要$3min$内实现任意一个 负环的判定@card{ $test\\ site: $https://www.luogu.org/problemnew/show/P3385 $task: $ 600ms以内判定负环，请注意，有多组数据，要求实现clear函数（包括邻接表 $tips: $ 循环队列已实现好。 $extra:?$?”同时记录节点入队次数”、”卡时” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int arr[maxn]; int l, r, size; inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125; inline void push(int x) &#123; if(r == size) r = 0; arr[++r] = x; &#125; inline int pop() &#123; if(l == size) &#123;l = 1; return arr[size]; &#125; return arr[l++]; &#125; inline bool empty() &#123; return l == r + 1; &#125;&#125;q;void clear() &#123; &#125;bool check() &#123; &#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? &quot;YE5&quot; : &quot;N0&quot;); &#125; return 0;&#125; } 邻接表的删除操作card{ 可以维护一个删除标记，但是这么做在有些算法里会导致复杂度(空间or时间)退化，具体测试可以去写即时删除的配对堆。 显然我们可以再维护一个$pre$域，像普通链表一样删除，但是过于麻烦，我们可以直接把这条边的数据与表头交换，然后让表头指向下一个，但是这么做会导致边序号乱序，需要注意成对变换等对边序号有要求的信息。 } SPFA求最长路card{ 我们经常写$DJ$，也经常写最短路，但是最长路+$SPFA$我第一次写的时候却挂了。。 $test\\ stie: $ https://www.acwing.com/activity/content/code/content/34854/ $task:$ 实现循环队列，初始化$dist[1] = 0$，求最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define rint register int#define lint long long#define pii pair&lt;int, int&gt;#define mp(x, y) make_pair(x, y)#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * (maxn + maxn);int n, max_val;int dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; int q[maxn]; int l, r, size;&#125;q;void calc_sp() &#123; &#125;int main() &#123; int nu, nv, nw; readint(n); for(rint i=1; i&lt;=n; i++) &#123; readint(nu), readint(nv), readint(nw); nu += 1, nv += 2; // 节点编号[1, 50002] addedge(nu, nv, nw); max_val = max(max_val, max(nu, nv)); &#125; for(rint i=1; i&lt;=max_val-1; i++) addedge(i, i+1, 0), addedge(i+1, i, -1); calc_sp(); printf(\"%d\\n\", dist[max_val] - dist[1]); return 0;&#125; } 无向图的割边card{ $test\\ site: $https://www.acwing.com/problem/content/365/ $task: $实现判断割边，处理出搜索树的$deep$，$fa$数组，并在割边的子节点上标记$val[y] = 1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 100000 + 10;const int maxm = 2 * 2 * maxn;int n, m, root = 1;int ans = 0;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int dfn[maxn], low[maxn], tot = 0;int deep[maxn], val[maxn], fa[maxn];void dfs(int x, int ind) &#123; low[x] = dfn[x] = ++tot; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(i == ind) continue; if(!dfn[y]) &#123; deep[y] = deep[x] + 1, fa[y] = x, dfs(y, i ^ 1); low[x] = min(low[x], low[y]); if(low[y] &gt; dfn[x]) val[y] = 1, ans++; &#125;else low[x] = min(low[x], dfn[y]); &#125;&#125;void clear() &#123; ans = tot = 0, totedge = 1; memset(head, 0, sizeof(int) * (n+1)); memset(dfn, 0, sizeof(int) * (n+1)); memset(val, 0, sizeof(int) * (n+1));&#125;int mem[maxn];void ask(int x, int y) &#123; int res = 0, s = 0; if(deep[x] &lt; deep[y]) swap(x, y); while(deep[x] &gt; deep[y]) &#123; mem[++s] = x, x = fa[x]; &#125; while(x != y) &#123; mem[++s] = x, mem[++s] = y; x = fa[x], y = fa[y]; &#125; for(rint i=1; i&lt;=s; i++) &#123; res += val[mem[i]], val[mem[i]] = 0; fa[mem[i]] = x; &#125; ans -= res;&#125;int main() &#123; int T = 0; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; clear(); printf(\"Case %d:\\n\", ++T); while(m--) &#123; readint(nu), readint(nv); addedge(nu, nv), addedge(nv, nu); &#125; dfs(root, 0); readint(m); while(m--) &#123; readint(nu), readint(nv); ask(nu, nv); printf(\"%d\\n\", ans); &#125; puts(\"\"); &#125; return 0;&#125; $Solution:$ 注意父节点来的边不能更新，具体用成对变换实现，割点不用记录，都能更新，但是要注意，按照常规割点定义，根节点必须有俩儿子“大于等于”，才能判断是，割边则是“大于”。 } 无向图的$v-dcc$缩点 + 二分图判定@card{ $test\\ site:​$ https://www.acwing.com/problem/content/367/ $task:$ 划分出图中的每个$vdcc$，并判定其是否是二分图（是否存在奇环），是的话将其每个节点的$suc$值设为$1$，并实现多组数据的清空函数 $note:$ 现用现标记，解决割点重叠问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e3 + 10;const int maxm = 1e6 + 4 * maxn;int n, m;int edge[maxn][maxn];int head[maxn], nxt[maxm], ev[maxm], totedge = 1;inline void addedge(int x, int y) &#123; ev[++totedge] = y, nxt[totedge] = head[x], head[x] = totedge;&#125;int main() &#123; int nu, nv; while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; while(m--) readint(nu), readint(nv), edge[nu][nv] = edge[nv][nu] = 1; for(rint i=1; i&lt;=n; i++) &#123; for(rint j=i+1; j&lt;=n; j++) &#123; // 虽然在完全图上用邻接表十分弱智,但可以降低常数 if(!edge[i][j]) addedge(i, j), addedge(j, i); &#125; &#125; int ans = 0; for(rint i=1; i&lt;=n; i++) ans += (suc[i] == 0); printf(\"%d\\n\", ans); clear(); &#125; return 0;&#125; } 欧拉回路的具体方案 $test\\ site:$ https://www.acwing.com/problem/content/368/ $task:$ 寻找一个从$1$出发，遍历所有边两次的具体方案，保证有解。 $tips:$ 注意入栈方法的实际含义。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 1e4 + 10;const int maxm = 1e5 + 10;int n, m;int head[maxn], ev[maxm], nxt[maxm], totedge = 1;inline void addedge(int nu, int nv) &#123; ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;&#125;int ans[maxm], tot = 0;int s[maxm], top = 0;void solve() &#123; &#125;int main() &#123; int nu, nv; readint(n), readint(m); while(m--) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu); solve(); for(rint i=1; i&lt;=tot; i++) printf(\"%d\\n\",ans[i]); return 0;&#125; 7.","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"基础数据结构","slug":"Template/数据结构/基础数据结构","date":"2019-04-27T12:44:23.105Z","updated":"2019-04-27T13:13:10.879Z","comments":true,"path":"2019/04/27/Template/数据结构/基础数据结构/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/数据结构/基础数据结构/","excerpt":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。","text":"虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。 循环队列@card{ $test \\ site:$https://www.luogu.org/problemnew/show/P3385 $task:$实现一个循环队列，要求有$empty \\ \\ push\\ init(O(1))\\ \\ pop\\ \\ front $ $note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// test site: https://www.luogu.org/problemnew/show/P3385// task: 实现一个循环队列，要求有empty push init(O(1)) pop front // note: 一般用于需要多次清空队列且已知\"队列里同时存在的最多元素数量\"，// 比起STL的queue，手写的可以O(1)清空。 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 2000 + 10;const int maxm = 6000 + 10;int n, m, start = 1;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge;&#125;struct Queue&#123; &#125;q;int cnt_path[maxn], dist[maxn];bool inq[maxn];void clear() &#123; totedge = 0; q.init(); memset(head, 0, sizeof(int) * (n+1)); memset(inq, 0, sizeof(bool) * (n+1)); memset(cnt_path, 0, sizeof(int) * (n+1)); memset(dist, 0x3f, sizeof(int) * (n+1));&#125;bool check() &#123; q.push(start), dist[start] = 0; while(!q.empty()) &#123; int x = q.pop(); inq[x] = 0; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(dist[x] + ew[i] &lt; dist[y]) &#123; dist[y] = dist[x] + ew[i]; cnt_path[y] = cnt_path[x] + 1; if(cnt_path[y] &gt; n) return 1; if(!inq[y]) q.push(y), inq[y] = 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int T; readint(T); while(T--) &#123; int nu, nv, nw; readint(n), readint(m); clear(); for(rint i=1; i&lt;=m; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw); if(nw &gt;= 0) addedge(nv, nu, nw); &#125; puts(check() ? \"YE5\" : \"N0\"); &#125; return 0;&#125; $Solution:$ 懒得写了，自己看代码吧 }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"数据结构","slug":"模板/数据结构","permalink":"http://arintaro.com/categories/模板/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://arintaro.com/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"http://arintaro.com/tags/队列/"}]},{"title":"LNOI2019 & 多省联考 游记","slug":"Essay/LNOI2019 & 多省联考 游记","date":"2019-04-27T09:01:25.797Z","updated":"2019-04-27T13:03:09.425Z","comments":true,"path":"2019/04/27/Essay/LNOI2019 & 多省联考 游记/","link":"","permalink":"http://arintaro.com/2019/04/27/Essay/LNOI2019 & 多省联考 游记/","excerpt":"","text":"Day1:待更，鸽了","categories":[{"name":"文章","slug":"文章","permalink":"http://arintaro.com/categories/文章/"}],"tags":[{"name":"无病呻吟","slug":"无病呻吟","permalink":"http://arintaro.com/tags/无病呻吟/"}]},{"title":"综合技巧与实践","slug":"Detail/综合技巧与实践","date":"2019-04-27T09:01:25.547Z","updated":"2019-04-27T12:43:17.568Z","comments":true,"path":"2019/04/27/Detail/综合技巧与实践/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/综合技巧与实践/","excerpt":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。","text":"根据贪心策略，我们把这些东西背一背肯定是是不亏的。 一、STL相关@card{ 1.algorithm123456789101112131.lower_bound &amp; upper_bound //我就算饿死，死外面，也不会自己写一个二分查找的 int pos = lower_bound(arr+1,arr+n+1,val) - arr; //在有序数组[1,n]中查第一个 &gt;=val的数 // 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater2.unique //常用于离散化 n = unique(arr+1,arr+n+1) - (arr+1); //去重，新元素存在[1,n] 3.inplace_merge merge // 常用于CDQ分治中，不要cdq里套sort了！！ // 数组 arr分为有序的两部分 [1,mid] [mid+1,n] inplace_merge(arr+1,arr+mid+1,arr+n+1); merge(first1,last1,first2,last2,result,compare);4.nth_element //数组中O(n)找第k大，前k个数一定都在[1，k] nth_element(arr+1,arr+k,arr+n+1);5.sort stable_sort // 后一个可以稳定排序 6.reverse // 跟sort传参一样，序列反转 2.vector121.vector的clear不会释放空间，需要释放空间的话，需要: vector&lt;int&gt;().swap(a); // 但是几乎比clear慢一倍 } 二、NOI Linux相关@card{ ​ 1.Emacs相关（M为Alt键，C为Ctrl键 - M+x输入命令 C+x+k关闭当前窗口 - Options-Use CUA Keys (转换复制粘贴快捷键) - Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题） - Options-Set Default Font - Ubuntu Mono 20-30（变更字体 - C-x-2 水平切分当前Buffer, C-x-3 左右切分 - 命令 Find-file后， ~/.emacs 可以直接打开配置文件 123456789101112131415161718192021(global-linum-mode t) ;;line num 显示行号(setq c-basic-offset 3) ;; 变更缩进(setq default-tab-width 3) (electric-pair-mode t) ;;electric pair 括号补全(electric-layout-mode t)(electric-indent-mode t)(setq-default cursor-type 'bar) ;;光标竖线(show-paren-mode t) ;;show paren 括号配对(global-set-key [f4] 'shell) ;;摁F4进入shell(defun compile-file()(interactive)(compile(format \"g++ -o '%s' '%s' -lm -Wall -g\"(file-name-sans-extension(buffer-name))(buffer-name))))(global-set-key [f5] 'compile-file) ;;摁F5编译(global-set-key [f6] 'gdb) ;;摁F6进入gdb调试(global-set-key (kbd \"C-s\") 'save-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"C-a\") 'mark-the-whole-buffer) ;; Ctrl+s变为保存(global-set-key (kbd \"RET\") 'newline-and-indent) ;;回车自动缩进 } 四、对拍相关@card{ ​ #### 1.程序运行时间 12double t = clock();cerr &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; endl; #### 2.diff命令 1diff -b -B test.out ans.out }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"STL","slug":"STL","permalink":"http://arintaro.com/tags/STL/"},{"name":"Linux","slug":"Linux","permalink":"http://arintaro.com/tags/Linux/"},{"name":"Emacs","slug":"Emacs","permalink":"http://arintaro.com/tags/Emacs/"}]},{"title":"常见代码实现细节","slug":"Detail/常见代码实现细节","date":"2019-04-27T09:01:25.528Z","updated":"2019-05-03T12:23:54.526Z","comments":true,"path":"2019/04/27/Detail/常见代码实现细节/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/常见代码实现细节/","excerpt":"","text":"这里记录的问题，全是我调过的问题orz。 &lt;!– more – &gt; @card{ 我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码 } 一、变量溢出问题@card{ 乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘 int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long， unsigned类型：值域$[0,2^{8size}-1]$溢出后对$2^{8size}$取模。 signed类型: 值$[-2^{8size-1},2^{8size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。 long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数 } 二、运算问题@card{ 有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数 要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除 做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值， 维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf 注意非负整数与“正整数”的区别，值域里可能会有0 有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。 } 三、语言问题@card{ 有时需要注意\\n \\r的问题，建议写手动读入的时候直接特判掉 宏定义千万别忘了括号，调一辈子，一般来说”有分割”的东西，不用加括号 lint 输入输出 %lld，ldob输入输出 %Lf 数组作为形参会退化成指针，不能再用sizeof求大小 题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0 程序中常量默认是INT型，设定 long long a = 10000 9999 9998 等一定要注意常量爆INT的问题 使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉 写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等 维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义 计算某些东西时，如果计算后需要移动指针，注意别先移动指针了（Acwing 294, 倍增LCA等） 写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧 维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。 } 四、数学相关@card{ BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$ 123if(Z == 1) return 0; //Luogu P2485 [SDOI2011]计算器if(Y % P == 0) return Z%P == 0 ? 1 : -1; i*len - ht[Yk] &gt;= 0 无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况 exgcd求出的d，如果要算最小非负解，一定把模数取决定值，才能用我们惯用的写法 如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的 计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\\ ||\\ m&lt;0\\ ||\\ n&lt;0$时0种方案 试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于 } 五、数据结构相关@card{ 维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1] 分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错 分块题开数组不要开混了 在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数” 常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2 静态线段树空间直接开4n防越界，动态开点的范围为 $[mlog_2m, 2n-1]$ 翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放 下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响 pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去 将操作重新排序后，注意是删除操作优先，还是增加操作优先 邻接表 i=nxt[i], 千万别写成 i=nxt[x] 如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。 有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。 有时需要特判“不存在”、”没找到“的情况 写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空相关指针，大部分情况数据清不清无所谓。 值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域。 } 六、图论相关@card{ 如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。 邻接矩阵注意初值是0还是inf 在有负权边时，树的直径不能通过两次DFS求。 无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。 带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。 在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。 建虚点，平移编号后一定要注意读入后别忘平移，节点数别忘增加。 有向图的$scc$，注意更新$low[x]$时，需要判断节点是否在栈里。无向图的$e-dcc$, 需要注意记录的是“来的边”，而不是父节点，来处理重边问题。无向图的$v-dcc$，需要注意按常规割点定义，搜索树的根节点需要有俩儿子判定成功，且割点会属于多个$v-dcc$。 } 七、动态规划相关@card{ 要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \\forall j \\ \\ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。 状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$ } 八、杂项@card{ 题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;= 一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1 在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。 交换变量时，注意变量的附带属性别忘了一起交换。 } 九、奇异的语言细节@card{ 123456// 形参中的表达式一定会被计算，但是C++标准并没有规定参数的求值顺序void test(int x,int y)&#123; cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl;&#125;test(++x,x); // 输出 1 1test(++x,x-1); // 输出1 -1 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"OI中的常见解题思路与技巧（更新中）","slug":"Detail/OI中的常见解题思路与技巧","date":"2019-04-27T09:01:25.509Z","updated":"2019-04-27T12:30:07.233Z","comments":true,"path":"2019/04/27/Detail/OI中的常见解题思路与技巧/","link":"","permalink":"http://arintaro.com/2019/04/27/Detail/OI中的常见解题思路与技巧/","excerpt":"也许很有用，也许没什么卵用。","text":"也许很有用，也许没什么卵用。 一、最优化问题@card{ 二分答案：答案具有“单调性”，外层花费$log\\ ans$的时间转化为判定性问题 答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的 二分出的答案一般对check的进行有所帮助 动态规划：一定要有最优子结构性质 贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件。 可以小范围搜索+多重限制贪心乱搞，说不定就骗到了100pts呢，考试的时候要勇于乱搞，敢于乱搞 一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质。 出题人是傻的，数据是水的，贪心+暴力是能过的，是能$Au$的。 } 二、计数问题@card{ } 三、数据结构题@card{ } 四、数学题@card{ 求和题：核心思想：[交换求和顺序] } 五、图论问题@card{ } 六、搜索优化策略@card{ } 七、动态规划优化策略@card{ 费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算 } 七、常见有用思想与技巧、性质@card{ 正难则反：广泛应用于各种问题 答案不容易求、不容易划分，利用全集减去补集从而求出答案 字典序最小的方案：结合性质5，倒序处理 单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数 凹凸性（二阶导数）：凸壳优化 对称性：优化枚举顺序、减少计算量 “一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于 例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于 试填法、字典序 }","categories":[{"name":"细节","slug":"细节","permalink":"http://arintaro.com/categories/细节/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"方法论","slug":"方法论","permalink":"http://arintaro.com/tags/方法论/"}]},{"title":"NOIP2018 D1T3 赛道修建","slug":"Contest/NOIP 2018/D1T3 赛道修建","date":"2019-04-27T09:01:25.456Z","updated":"2019-04-27T13:25:53.432Z","comments":true,"path":"2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/","link":"","permalink":"http://arintaro.com/2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/","excerpt":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。","text":"祭奠我考场写挂的55pts, 那时我真是个ruozhi。 Description:@card{ 给定一棵带权树，要求从树上划分出$m$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \\times 10^4$级别（实际上可以出到$5\\times10^5$左右，边权再缩小点甚至能更大，卡$sort$?(雾 } Solution:@card{ 分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助。 发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。 能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。考虑性质1：每条路径对答案的贡献其实是相同的，都是$1$，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之性质2：父节点只能有一条路径到当前节点，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在保证配对数最大的同时，还要保证剩下的深度最大，从而上传给父节点。 至此，我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下： 给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。 这里网上通常有三种实现形式，我从复杂到简洁讲： 算法1：贪心+平衡树/双向链表、删除标记首先，我们显然有性质1：应该优先配对较小的深度。 如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。 然后，我们有性质2：最优方案中，每个最小值都应该与能配对的最小的数配对，显然，不证了。基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \\ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（期望得分：55分，实际得分：100分 算法2：双指针+栈一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是能配对的最小的数。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。 STD算法：双指针那么有没有不用栈，常数更加优秀（并没有，更加简洁的算法呢？有，就是本题的std1。基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j$，配对到了左指针$i$，如果$j-1$不能与$i$配对，那么剩下的右指针也显然配对不了，所以$i$必须得与$j$配对，这时我们更新$last = j - 1$即可，如果最后考虑一个右指针$j$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]$成功配对的右指针平移到$[j,last-1]$，然后用$last$对应的值更新上传的最大值。由于网上$blog$没有对这个算法的讲解，$std$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std$在干什么。。 这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\\frac{\\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，从而实现了卡sort的可能。还有俩剪枝，二分上界可以设到$min{\\frac{\\sum{w_i}}{m} ,d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。 } Code:@card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')template&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;const int rid = 8;int n, m;int root = 1, sumw = 0;int temp[maxn], rcnt[1&lt;&lt;rid], rmod = (1 &lt;&lt; rid) - 1;inline void rsort(int arr[], int n) &#123; if(n &lt; 256) &#123; sort(arr+1, arr+n+1); return; &#125; for(rint i=0; i&lt;=31; i+=rid) &#123; memset(rcnt, 0, sizeof(rcnt)); for(rint k=1; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++; for(rint j=1; j&lt;=rmod; j++) rcnt[j] += rcnt[j-1]; for(rint k=n; k&gt;=1; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k]; memcpy(arr, temp, sizeof(int) * (n+1)); &#125;&#125;int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;int arr[maxn], dist[maxn];int dfs(int x, int fa, int mid) &#123; int res = 0, tot = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else arr[++tot] = dist[ev[i]] + ew[i]; &#125; rsort(arr, tot), dist[x] = 0; for(rint i=1, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123; while(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++]; if(i == j) &#123; dist[x] = arr[last]; break; &#125; if(j &amp;&amp; arr[i] + arr[j-1] &lt; mid) last = j-1; if(res &gt;= m) return res; &#125; return res;&#125;int maxd, dp[maxn];void dfs2(int x, int fa) &#123; for(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123; if(y == fa) continue; dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]); dp[x] = max(dp[x], dp[y] + ew[i]); &#125;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; dfs2(root, root); int l = 1, r = min(maxd, sumw / m); while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; } @card{ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define rint register int#define lint long long#define isnum(x) ('0' &lt;= (x) &amp;&amp; (x) &lt;= '9')#define sit multiset&lt;int&gt;::iteratortemplate&lt;typename tint&gt;extern inline void readint(tint&amp; x) &#123; int f = 1; char ch = getchar(); x = 0; for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1; for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0'; x *= f;&#125;using namespace std;const int maxn = 50000 + 10;const int maxm = 2 * maxn;int n, m;int root = 1;int sumw = 0, dist[maxn];int head[maxn], ev[maxm], ew[maxm], nxt[maxm];int totedge = 0;inline void addedge(int nu, int nv, int nw) &#123; ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu]; head[nu] = totedge; sumw += nw;&#125;multiset&lt;int&gt; s;int dfs(int x, int fa, int mid) &#123; int res = 0; for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; res += dfs(ev[i], x, mid); if(res &gt;= m) return res; &#125; dist[x] = 0, s.clear(); for(rint i=head[x]; i; i=nxt[i]) &#123; if(ev[i] == fa) continue; if(dist[ev[i]] + ew[i] &gt;= mid) res++; else s.insert(dist[ev[i]] + ew[i]); &#125; for(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; // nxt一定在it后面 sit nxt = s.lower_bound(mid - (*it)); if(nxt == it &amp;&amp; nxt != s.end()) nxt++; if(nxt == s.end()) &#123; it++; continue; &#125; s.erase(nxt), s.erase(it++), res++; // 注意先删nxt, 不然it++可能等于nxt if(res &gt;= m) return res; &#125; if(!s.empty()) dist[x] = *s.rbegin(); return res;&#125;int main() &#123; int nu, nv, nw; readint(n), readint(m); for(rint i=1; i&lt;n; i++) &#123; readint(nu), readint(nv), readint(nw); addedge(nu, nv, nw), addedge(nv, nu, nw); &#125; int l = 1, r = sumw / 2; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(dfs(root, root, mid) &gt;= m) l = mid; else r = mid - 1; &#125; printf(\"%d\\n\", l); return 0;&#125; }","categories":[{"name":"比赛","slug":"比赛","permalink":"http://arintaro.com/categories/比赛/"},{"name":"NOIP2018","slug":"比赛/NOIP2018","permalink":"http://arintaro.com/categories/比赛/NOIP2018/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"},{"name":"双指针","slug":"双指针","permalink":"http://arintaro.com/tags/双指针/"},{"name":"二分答案","slug":"二分答案","permalink":"http://arintaro.com/tags/二分答案/"},{"name":"贪心","slug":"贪心","permalink":"http://arintaro.com/tags/贪心/"}]},{"title":"树的相关性质(更新中)","slug":"Algorithm/树的相关性质","date":"2019-04-27T09:01:25.373Z","updated":"2019-04-27T13:25:28.309Z","comments":true,"path":"2019/04/27/Algorithm/树的相关性质/","link":"","permalink":"http://arintaro.com/2019/04/27/Algorithm/树的相关性质/","excerpt":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。","text":"本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。 一、树的直径@card{ （一）求法： 两次DFS比较容易求出具体路径，缺点是实现比树形DP麻烦，并且要求树的边权非负。 树形DP实现简单，但求具体路径比较麻烦，适用于只需要直径长度的情况（如二分答案的上界剪枝等），对边权没有要求。 （二）性质： 基本思想：分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。 任意一个节点作根，直径两端点一定是叶子节点。 距离任意点最远的点一定是直径的一个端点。（相当有用的性质 设从A出发找到最远点B 如果A已经是直径上一个端点，正确性显然。 如果不是，考虑反证，设直径为CD。 由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。 则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。 树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分，且在这部分两侧的长度一定相等。 显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。 如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。 对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。 如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。 往一棵树里加一个点，直径的端点最多改变一个 先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。 （三）在具体题目下的证明例子 NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，然而原题不要求证明这些东西 在任意直径上求最小偏心距都相等 考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。 考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。 }","categories":[{"name":"算法","slug":"算法","permalink":"http://arintaro.com/categories/算法/"},{"name":"图论","slug":"算法/图论","permalink":"http://arintaro.com/categories/算法/图论/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://arintaro.com/tags/总结/"},{"name":"图论","slug":"图论","permalink":"http://arintaro.com/tags/图论/"}]},{"title":"优雅的O(1)下取整log2","slug":"Template/小工具/log2的姿势","date":"2019-04-27T09:01:25.331Z","updated":"2019-04-27T13:10:15.091Z","comments":true,"path":"2019/04/27/Template/小工具/log2的姿势/","link":"","permalink":"http://arintaro.com/2019/04/27/Template/小工具/log2的姿势/","excerpt":"还能不能再给力点呢？","text":"还能不能再给力点呢？ 1.转double法@card{ double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，几乎是$O(1)$的。请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可） 123456#define lint long longinline lint mlog2(lint x)&#123; if(x == 1) return 0; double t = (double)x; return (lint)((lint&amp;)t &gt;&gt; 52 &amp; 63) + 1; // 注意最前面还要再转一次long long&#125; Luogu ST表 传统打表法 1011ms https://www.luogu.org/recordnew/show/13493959Luogu ST表 double法 1009ms https://www.luogu.org/recordnew/show/18155615实测后发现速度差异不大, 开了O2打表会快一些 } 2.打表法@card{ 显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论 $$\\forall k \\in [0,35], 2^kmod\\ 37,\\ 取遍[1,36]$$ } 3.double法的具体测试@card{ $test\\ site:$https://www.luogu.org/problemnew/show/P3865 $task:$ 实现函数mlog2，需要$O(1)$返回$\\lfloor log_2{x} \\rfloor​$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445// test site: https://www.luogu.org/problemnew/show/P3865// 要求：实现函数mlog2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define readint(x) scanf(\"%d\",&amp;(x))#define rint register int#define lint long longusing namespace std;const int maxn = 1e5 + 10;int n, m, logn;int arr[maxn];inline lint mlog2(lint x) &#123; &#125;int rmq[20][maxn];inline void getrmq() &#123; for(rint i=1; i&lt;=n; i++) rmq[0][i] = arr[i]; for(rint d=1; d&lt;=logn; d++) &#123; int len = (1 &lt;&lt; d), half = (1 &lt;&lt; (d-1)); for(rint i=1; i+len-1&lt;=n; i++) &#123; rmq[d][i] = max(rmq[d-1][i], rmq[d-1][i+half]); &#125; &#125;&#125;inline int ask(int l, int r) &#123; int loglen = mlog2(r - l + 1); return max(rmq[loglen][l], rmq[loglen][r-(1&lt;&lt;loglen)+1]);&#125;int main() &#123; readint(n), readint(m); logn = ceil(log2(n)); for(rint i=1; i&lt;=n; i++) readint(arr[i]); getrmq(); int nl, nr; while(m--) &#123; readint(nl), readint(nr); printf(\"%d\\n\",ask(nl,nr)); &#125; return 0;&#125; }","categories":[{"name":"模板","slug":"模板","permalink":"http://arintaro.com/categories/模板/"},{"name":"工具","slug":"模板/工具","permalink":"http://arintaro.com/categories/模板/工具/"}],"tags":[{"name":"语言","slug":"语言","permalink":"http://arintaro.com/tags/语言/"},{"name":"奇淫技巧","slug":"奇淫技巧","permalink":"http://arintaro.com/tags/奇淫技巧/"}]}]}