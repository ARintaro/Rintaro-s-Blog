<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2019-11-02T19:35:20.294Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《天气之子》观后感</title>
    <link href="http://arintaro.com/2019/11/03/Essay/%E3%80%8A%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>http://arintaro.com/2019/11/03/Essay/《天气之子》观后感/</id>
    <published>2019-11-02T16:40:16.669Z</published>
    <updated>2019-11-02T19:35:20.294Z</updated>
    
    <content type="html"><![CDATA[<p>退役警告</p><a id="more"></a><h2><span id="一-前言-amp-观影体验">一、前言 &amp; 观影体验</span></h2><p>@card{</p><p>先讲讲我对新海诚的认识，毕竟这部动画很大一部分讨论都集中在他身上，这是一个蛮有趣的现象，其他日本动画电影在宣发时主要强调的是IP，毕竟深夜动画圈相对整个观影人群还是占绝对少数的，而君名和这部宣发很大程度上强调的是由”新海诚”这个人上，这是与”宫崎骏”在同等地位上的。</p><p>诚哥在《君名》之前，认知度还是集中在”平时就比较喜欢看日本动画”的人里，我在这个时间点大概只看过《秒速五厘米》。《君名》爆红之后，我才陆陆续续补了其他作品，当然，我作为一名萌二，肯定是现在还没看完的，记得《云端》只看了<a href="https://space.bilibili.com/927587" target="_blank" rel="noopener">木鱼水心</a>的解说视频，现在最喜欢的大概是《星之声》，当然这部从制作水准上肯定是没现在的作品强，但是我喜欢的是其中的”idea”。（比民俗我大概更喜欢科幻。</p><p>这次的《天气之子》是比《君名》在上映前更受到关注的，资本因素大概会更多一些？不过有趣的是，国内的引进速度都是差不多的（奇异的游戏人生zero，话说TV动画什么时候继续出啊？！），因此我在上映前就被各大位于日本的动漫高手剧透了大体剧情走向（当然出钱这么多的片子肯定也可以推测出不会让诚哥乱搞一个BE出来的）。</p><p>接着讲观影体验，具体观影我是在11/2的晚上刷了两遍，一开始本来只想看一场的，但是由于：<br>第一场：</p><ul><li>我一个人坐在了两对情侣之间-</li><li>儿童厅的小屏幕-</li><li>提前买了冰奶茶很好喝+</li><li>首次观影+</li></ul><p>第二场:</p><ul><li>有dbn陪我吹水+</li><li>imax的大屏幕+</li><li>有可爱的妹子+</li><li>人少可以随便换座+</li><li>明天放假+</li></ul><p>第一次在影院里看到《君名》女主翻译成”宫本茂”时，我的反映：</p><ul><li>这不是做马里奥的那个大叔嘛？</li><li>我是不是记错女主名字了，她不是叫宫水三叶么？</li><li>啊啊，应该是嫁给男主改姓了</li><li>可是男主不是叫”立花泷”么？</li><li>？？我记错哪个名字了？！</li></ul><p>}</p><h2><span id="二-杂项">二、杂项</span></h2><p>@card{</p><p>这部分放在前面，因为我确实啥也不懂，只能跟《君名》做做比较。</p><p>作画这部分似乎没什么人提，因为经费比较充足，确实作画质量吊打各大其余”类似画风”的动画。动作场面非常精彩，诚哥标志性的城市风景和天空也得到了充分的体现，对于我这样的非作豚肯定是只能吹爆了。（当然单从作监履历上来看，田村篤确实之前没有什么著名作品，肯定是没有《君名》的安藤雅司耀眼），anitama上贴了很多幕后制作故事、访谈，<a href="http://www.anitama.cn/series/357" target="_blank" rel="noopener">连接</a><br>。</p><p>人设上我认为女主的人设还是比较新颖的，男主的似乎见得比较多？</p><p>音乐，我这样五音不全的人就不评价了，单听都是非常好听，但从”契合度”上来讲，似乎是没有《君名》好，中间还有女主唱《逃耻》的曲子，我在电影院里居然反应过来。。</p><p>配音我认为都非常优秀，包括在日上映之前在zhihu上饱受怀疑的启用明星配音的小栗旬。</p><p>}</p><h2><span id="三-剧情-剧透警告">三、剧情 (剧透警告)</span></h2><p>@card{</p><p>由于我现在没读过小说，BD也没出，以下均按我在影院看了两遍的个人感受为准。</p><p>剧情主体还是传统的boy meets girl，再混合了一些超能力设定和<a href="https://www.bilibili.com/bangumi/play/ep263093" target="_blank" rel="noopener">小偷家族</a>的感觉？出来看了访谈，</p><blockquote><p>据说新海当初在观看是枝裕和导演执导的《小偷家族》时，就想着要酝酿一部，未必如揭示日本低层民众疾苦的《小偷家族》那般立意沉重深远，但在感觉上较为相近的作品。<br>登场人物中既有姐姐，年幼的孩子，也有上了年纪的老婆婆，以及少年。如此，便有望将影片打造成老少皆宜的作品。<br>作者：izumi<br>链接：<a href="http://www.anitama.cn/article/e49836264d7384cc" target="_blank" rel="noopener">http://www.anitama.cn/article/e49836264d7384cc</a><br>来源：Anitama  </p></blockquote><h4><span id="前期">前期</span></h4><p>剧情前期讲了男主离家出走，受到女主和大叔帮助，并用捡来的枪击退了劝拐女主从事风俗业的坏人，后来想到利用能力牟利并度过了一段欢乐日常。</p><p>一开始，男主离家出走时身上是带伤的，暂不清楚是因为他太皮被”合理的管教”了，还是单纯的家暴。这里如果解释成”男主被家暴”了，大概男主的形象会在”社会意义上”正面一些。</p><p>之后女主给了落魄的男主一个汉堡，并成为后来男主阻止女主从事风俗业的flag，后来女主被开除我个人倾向是女主说的”其他原因”，而不是因为给了男主一个汉堡，毕竟女主想给的话，应该是自己掏钱买，从女主其余地方表现的善良性格，大概是不会偷汉堡店的东西的。</p><p>中间前辈的两个女友玩了声优梗。(前辈太强了，orz)</p><p>这段大叔的戒指给了非常多的特写，疯狂暗示大叔的亡妻，看zhihu上说场刊废设有大叔是专门研究民俗的学者，而不是现在的八卦小报编辑。剧情中给了相当多的暗示大叔是有故事的人，我个人倾向于他妻子也是那种”牺牲小我成就大我的巫女”(是不是天气巫女不确定)，并且大叔没有像这次的男主一样选择老婆而不是世界，之后现在的大叔一直在后悔。但我认为他对这次阳菜能力的设定还是不太清楚的，如果清楚，恐怕他会在得知阳菜在滥用能力之后立刻阻止的吧。我认为如果大叔设定成”学者”，并将救阳菜的后果与方法研究出来，这个片子的剧情走向恐怕就会完全改变，这个之后再说。</p><p>捡到枪是非常重要的flag，它直接引起了后来的剧情冲突，但是这也恰恰是被很多人喷的点，还是之后再说。</p><p>在男主想到能力牟利后，剧情前期大概就再也没描写过生活不易，并且这段他们的活动已经引起了相当的关注。这里可以发现他们所在的世界(同时也是《君名》的世界)，虽然充斥着超自然现象，但在普通群众的认可度不高，政府也没有相关机构研究，换句话说，就是没有社会人认为能力是真的，也没有政府认为能力是真的，否则单凭这几个孩子肯定是要被抓走的。当然，这是与剧中大型活动单靠女主矛盾的，不过也可以解释成”当个吉祥物”，否则就是剧情出锅了。不少能力系的作品的核心矛盾就定在”政府/机构抓人研究上”，但是这部作品没有。我在这里就联想到了《哆啦A梦》，大雄每次适当用道具时就不会出事，一旦开始乱搞就肯定会出事，这其实是插上了BE的flag。</p><h4><span id="中期">中期</span></h4><p>中期大概是三人组的整个逃亡过程。</p><p>然后就到了主要争论点，这片没有不可调和的核心矛盾，所谓的矛盾大部分是男主决策失误自己作的。(这并不是定论，请接着往下看)</p><p>剧中中期阻碍两人在一起的是警察，后期阻碍的是警察+神隐。中期警察为什么抓他俩？</p><p>是因为男主捡到枪并使用了它，女主带着弟弟独立生活，由于剧中并没有描写警察势力有多么黑暗，从常理来讲”男主持枪”在暴力袭警之前，是完全可以解释清楚的。而”女主带着弟弟独立生活”也不是不可调和的，即使接受收容，女主反而可以接受教育，弟弟也能过上物质条件好一些的生活，并且接受稳定的教育，这与女主照顾弟弟的目标是契合的。剧中解释是想”两人在一起生活”，可接受收容后两人也并不是见不到了呀。现在剩下的问题其实是，一旦男主选择与警察和解，其必然要被遣返读完高中，事实上从结局给出的结果来看，这并不是不可接受的结果。然后最终他们选择了跑路，其成功性也非常渺茫，没有身份证件，黑活也很难找到，也没有其他有效收入与住所，事发之后控制天气的私活也很难干下去，还要面临警察全天候的追捕，并且弟弟再也接受不了义务教育了。</p><p>从上述视角看，这个故事是”不合逻辑的”，但是剧中作出决策的并不是拥有上帝视角的观众，而是会作出”毫无准备的离家出走”这种决策的男主，这样的男主会作出不理性的决策，导致观众认为的”主线任务”偏离。</p><p>我一开始认为的主线是”男女主与世界的对抗”，看完想想，不如说是”男女主走到一起的曲折过程”，它可能<strong>本来</strong>会非常顺利，但是因为意外或者是剧中人物的决策失误导致了偏离，从”对抗世界”转而”对抗警察”。</p><p>我认为从”事实上的事件”来看，这个过程是没有问题的；但是从剧作的角度来看，我们平时看到的剧本一定是符合<strong>逻辑</strong>的，即使存在意外也在合理的范围并存在铺垫的：比如白箱最后一集，放一个不知道哪里出现的纵火犯把武藏野烧了，这恐怕会被喷到死，但是这种事件在现实里的京都却发生了，这就是所谓的”现实比剧本更加离奇”。</p><p>当然，这种事件在现实里肯定会有铺垫，但是由于我们信息量太少，无法掌握，而这在剧本里是会给你的，比如”某人买了不知用途的汽油，并拿着攻击用品朝着京都动画走来”，这就是可能推测出”这个人以后会纵火”的关键信息，而在现实里没有上帝视角or编剧特意强调的信息，这种信息是根本无法掌握的。</p><p>所以，我认为从男主之前设定的性格来看，作出这些冲动决策其实是合理的。但这样的情节安排肯定会导致”故事性不强”，这也是评价两极分化的直接原因，我认为是没有必要得出一个定论”故事性不强”好不好的，喜欢的人自然喜欢，不喜欢的人自然不喜欢。</p><h4><span id="后期">后期</span></h4><p>后期讲了阳菜消失到拯救阳菜，及留白的遣返三年。</p><p>又到了一个争论点，不过大概没有上一个大，即男主的选择，在女主和东京之间果断选择了女主。</p><p>但是从影片中来看，男主做梦大概只做到了女主从神社升天(如果设定集改了这个前提，以下说明均不成立)，并没有给出他拯救女主的方法与后果。这也就是上文说的，”如果大叔设定成学者并研究成功”，这段男主的行为就从”观众的逻辑”完全解释的通了，而不是自我的”任性”。</p><p>仔细考虑一下，他被逮捕后，是不知道拯救女主的方法与后果的，这代表着即使他让大叔与姐姐成为共犯，即使他成功暴力袭警并选择为之承担后果，也不知道能否成功拯救女主，其成功概率是他无法预估的，而后果更是他无法预估的，是仅仅下雨几天，还是下雨几个月，或者是下雨三年淹了东京，还是最严重的淹了全世界。</p><p>他是根本不知道的，他是<strong>抱着仅有的一丝可能性，不顾之后的任何后果，选择了暴力袭警拯救女主</strong>，从这个角度考虑，这确实是能突出两人的羁绊的。从事后诸葛亮的角度来讲，恐怕任何观众换进去从逃亡开始走男主的流程，没有一个能打出GE的，反而是”任性”的男主打出了”个人较优解”。</p><p>不过，我相当奇怪的是女主的转变，在女主消失的那个晚上，她是愿意为世界而牺牲自己的，但是当后来男主不顾一切来找她的时候，她没有丝毫犹豫，直接跟男主走了。当然，由于没有女主视角，不知道女主这时对能力的前提与后果掌握的怎么样了，因此只能作为”奇怪的地方”。</p><p>不过也可以换个角度解释，也可以解释成那个晚上女主问男主愿不愿意停雨，那时男主说了”嗯”，所以女主依照男主的想法决定牺牲自己，但这时男主其实是不知道停雨的代价是女主消失，等到男主了解代价，并来救女主，其实就是告诉女主”我其实是不愿意你消失的”，所以女主又按照男主的想法立即回去了。大概这个角度能更突出两人的羁绊。</p><p>然后就是几人被抓后的现实社会情节，这部分一点没讲，但这其实是之前为何逃亡的重要原因，但影片自始自终没表现最后被抓回去有多惨，反而是男主只判了一个保护观察正常接收教育，男主未成年就忍了，但作为成年人共犯的大叔，就算能洗掉诱拐，可是暴力袭警怎么洗呀，基于开头的讨论，法官也肯定不会相信是因为一些超自然力，但是大叔三年后反而还混的更好了，这部分等设定集洗吧，不知道能如何解释。</p><p>当然，如果不考虑得这么复杂，我们抽象一点，东京和女主选哪个，或者更大一点，世界和女主选哪个，从我的立场来说，我选女主。</p><p>最后男女主的相见还是经典的坡道梗，虽然上面这么说了，但真正在电影院里看的时候，还是非常有感染力的。</p><p>}</p><h2><span id="四-总结">四、总结</span></h2><p>@card{</p><p>制作顶尖的作品。</p><p>如果你在意剧情，那么主要看您对”故事性不强”的故事的接受程度。我认为不在意剧情的人，这片都会看得非常开心。</p><p>知乎上有非常多的补充细节和剧情分析，如果您看完了这部，并对这些东西感兴趣十分推荐阅读，这里我就懒得放链接了。</p><p>最后，散发的女主真好看.jpg，等出了BD我要截下来。</p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;退役警告&lt;/p&gt;
    
    </summary>
    
      <category term="文章" scheme="http://arintaro.com/categories/%E6%96%87%E7%AB%A0/"/>
    
      <category term="观后感" scheme="http://arintaro.com/categories/%E6%96%87%E7%AB%A0/%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    
    
      <category term="动画" scheme="http://arintaro.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="颓废" scheme="http://arintaro.com/tags/%E9%A2%93%E5%BA%9F/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P3400 仓鼠窝</title>
    <link href="http://arintaro.com/2019/11/01/Answer/hamster/"/>
    <id>http://arintaro.com/2019/11/01/Answer/hamster/</id>
    <published>2019-11-01T08:46:01.002Z</published>
    <updated>2019-11-01T09:35:37.443Z</updated>
    
    <content type="html"><![CDATA[<p>转化后不难的问题。<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一个$n \times n$的$01$矩阵，求出其中均为$1$的子矩阵个数。</p><p>$1 \leq n \leq 3000$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先考虑几个朴素做法，枚举子矩阵的三个角，暴力判断其中是否都是$1$，$O(n^6)$。</p><p>发现判断很耗时，不如用hash，降到$O(n^4)$。</p><p>考虑只枚举两个角，即枚举两个行，然后判断两行间有多少子矩阵。只要把多行压成一行，然后转化成一维问题解决即可。降到$O(n^3)$。</p><p>再写出暴力对拍后，考虑能否只枚举一个角解决问题。</p><h4><span id="算法一-单调栈-分行计算贡献">算法一: 单调栈 + 分行计算贡献</span></h4><p>考虑之前经常做的最大子矩阵问题，我们可以枚举一行，然后每列之上连续的$1$的数量作为一列的高度。</p><p>同时注意不要重复计算，我们每次计算的是”底端在这行上”的数量，类似最大子矩阵问题，我们在出栈时计算贡献。</p><p>与之前相同，因为我们维护了矩形的单调性，我们出栈时倒序计算可以保证右边的矩形都比当前矩形高，从而快速累加贡献。但是这里我们需要计算什么呢？为了防止重复计算，我们规定出栈时只计算”跨多个矩形构成的子矩阵”，出栈一个矩形时，分成它自己的左端，和这次之前出栈的右端，不妨设左端宽度$w$，右端宽度$now$，左端高度$h$，则这次的贡献显然是$w \times now \times h$。</p><p>之后注意入栈时不能只入$now + 1$一个矩形，而是要入一个$now$和一个$1$的，因为新加进来的矩形与之前的矩形的贡献还未计算。</p><h4><span id="算法二-单调栈-对每个右下角计算贡献">算法二： 单调栈 + 对每个右下角计算贡献</span></h4><p>考虑对一个右下角有多少个左上角能与其匹配，手玩后发现其在列上满足一定的单调性。所以分列转移，用递推预处理出每个点向左最多能扩展$1$的长度，再用单调栈维护一下即可，具体做法与上个方法类似。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> ma[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h[maxn], w[maxn], stop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意n, m别写反了</span></span><br><span class="line"><span class="function">lint <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stop = <span class="number">0</span>;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m+<span class="number">1</span>; i++) &#123;</span><br><span class="line">res += arr[i];</span><br><span class="line"><span class="keyword">if</span>(h[stop] &lt; arr[i]) h[++stop] = arr[i], w[stop] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(stop &amp;&amp; h[stop] &gt;= arr[i]) &#123;</span><br><span class="line">res += (lint)w[stop] * now * h[stop], now += w[stop];</span><br><span class="line">stop--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">h[++stop] = arr[i], w[stop] = now;</span><br><span class="line">h[++stop] = arr[i], w[stop] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">readint(ma[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) arr[j] = ma[i][j] ? arr[j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">ans += calc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法二</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> lt[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> ma[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> h[maxn], w[maxn];</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">readint(ma[i][j]);</span><br><span class="line">lt[i][j] = ma[i][j] ? lt[i][j<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, stop = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">cnt += lt[i][j];</span><br><span class="line"><span class="keyword">if</span>(!stop || (stop &amp;&amp; w[stop] &lt;= lt[i][j])) &#123;</span><br><span class="line">w[++stop] = lt[i][j], h[stop] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(stop &amp;&amp; w[stop] &gt;= lt[i][j]) &#123;</span><br><span class="line">cnt -= (w[stop] - lt[i][j]) * h[stop];</span><br><span class="line">now += h[stop], stop--;</span><br><span class="line">&#125;</span><br><span class="line">w[++stop] = lt[i][j], h[stop] = now;</span><br><span class="line">&#125;</span><br><span class="line">ans += cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转化后不难的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调栈" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="悬线法" scheme="http://arintaro.com/tags/%E6%82%AC%E7%BA%BF%E6%B3%95/"/>
    
      <category term="多维问题" scheme="http://arintaro.com/tags/%E5%A4%9A%E7%BB%B4%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>USACO11OPEN 奇数度 Odd degrees</title>
    <link href="http://arintaro.com/2019/11/01/Answer/cow3/"/>
    <id>http://arintaro.com/2019/11/01/Answer/cow3/</id>
    <published>2019-11-01T02:41:11.874Z</published>
    <updated>2019-11-01T08:45:40.063Z</updated>
    
    <content type="html"><![CDATA[<p>转化后不难的问题。<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一张图，要求选出一些边，使每个点的度数为奇数。</p><p>$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>由于图上问题有”任意性”, 难以进行DP，所以先考虑性质与扫描。</p><p>发现这个问题与图的形态无关，其实就是给一个全$0$序列和$m$对关系，选一对关系是把两个都加一，最后求怎么选能让序列中的数都都是奇数，最后发现十分不可做，我们难以确定计算顺序，选了一对关系很可能会对后面带来无法估计与记录的影响。</p><p>考虑在树上怎么做，树上显然确定计算顺序自下而上即可，叶子节点连向父亲的边是必须选的，考虑完所有的叶子节点，再考虑向上一层，它们此时的度数的奇偶性是确定，也就是说成为新的”可以直接确定连向父亲边选不选的”叶子节点。</p><p>接着扩展到图上，发现图上随便一个生成树的所有方案其实覆盖了图上的所有方案。首先，对一条链来讲，把其中边选不选的状态取反，中间的节点度数奇偶性均不变，只有两头的节点奇偶性取反。那么如果存在一种方案有一条不在生成树上的边成立，那么去掉这条边，把它在生成树路径上的边取反，显然也是一种成立的方案。</p><p>所以随便求个生成树当树上问题做即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], id[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">    id[totedge] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图上问题在树上怎么做？</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], choose[maxm];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="number">0</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(y)) cnt++, choose[id[i]] = <span class="number">1</span>, res ^= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readint(n), readint(m);</span><br><span class="line">    <span class="keyword">int</span> nu, nv;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        readint(nu), readint(nv);</span><br><span class="line">        addedge(nu, nv, i), addedge(nv, nu, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(rint x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(vis[x]) <span class="keyword">continue</span>;</span><br><span class="line"> <span class="keyword">if</span>(!dfs(x)) &#123;</span><br><span class="line"> failed = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">if</span>(failed) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">        <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) <span class="keyword">if</span>(choose[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line"> &#125;</span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转化后不难的问题。&lt;br&gt;
    
    </summary>
    
      <category term="USACO" scheme="http://arintaro.com/categories/USACO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/USACO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="等效法" scheme="http://arintaro.com/tags/%E7%AD%89%E6%95%88%E6%B3%95/"/>
    
      <category term="生成树" scheme="http://arintaro.com/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>USACO13JAN 牛的阵容 Cow Lineup</title>
    <link href="http://arintaro.com/2019/10/31/Answer/cow2/"/>
    <id>http://arintaro.com/2019/10/31/Answer/cow2/</id>
    <published>2019-10-31T11:41:09.091Z</published>
    <updated>2019-10-31T11:46:54.171Z</updated>
    
    <content type="html"><![CDATA[<p>转化后不难的问题。<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个颜色序列，可以至多去掉$k$种颜色，使去除后一个连续相同颜色的子段最长。</p><p>$1 \leq k \leq 10^5$, $1 \leq k \leq n$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑一个颜色数不大于$k+1$的区间，它显然可以去掉$k$种留下区间颜色数最多的得到这个区间的答案。</p><p>然后双指针扫一扫，对每个$i$找颜色数尽量多的区间即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ht[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">eco</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lower_bound(ht+<span class="number">1</span>, ht+tot+<span class="number">1</span>, x) - ht;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt_color[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = (cnt_color[c] != <span class="number">0</span>);</span><br><span class="line">cnt_color[c] += x;</span><br><span class="line">cnt += (cnt_color[c] != <span class="number">0</span>) - pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cnt_color[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">readint(n), readint(k);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]);</span><br><span class="line">ht[++tot] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(ht+<span class="number">1</span>, ht+n+<span class="number">1</span>), tot = unique(ht+<span class="number">1</span>, ht+n+<span class="number">1</span>) - (ht + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = eco(arr[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= n &amp;&amp; cnt &lt;= k + <span class="number">1</span>) update(arr[++j], <span class="number">1</span>);</span><br><span class="line">ans = max(ans, cnt_color[arr[i]]);</span><br><span class="line">update(arr[i], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转化后不难的问题。&lt;br&gt;
    
    </summary>
    
      <category term="USACO" scheme="http://arintaro.com/categories/USACO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/USACO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="双指针" scheme="http://arintaro.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="等效法" scheme="http://arintaro.com/tags/%E7%AD%89%E6%95%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>POJ3017 Cut The Sequence</title>
    <link href="http://arintaro.com/2019/10/31/Answer/cut/"/>
    <id>http://arintaro.com/2019/10/31/Answer/cut/</id>
    <published>2019-10-31T06:20:01.041Z</published>
    <updated>2019-10-31T11:38:57.144Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个长度为$n$的序列A，要求把该序列分成若干段，在满足“每段中所有数的和”不超过$m$的前提下，让“每段中所有数的最大值”之和最小。</p><p>$1 \leq n \leq 10^5$, $1 \leq m \leq 10^{11}$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这题是个相当好的题目。</p><p>最优化问题，乍一看挺像一个二分答案的，答案显然具有单调性，然而仔细考虑一下，二分答案中，我们二分出来的“答案”需要对计算有帮助，然而这个答案““每段中所有数的最大值”之和”，对计算毫无卵用，根本无法check。</p><p>既然最优化问题的第一个想法二分答案不行，我们接着考虑最优化问题的第二个想法，DP。</p><p>不妨设$max[l,r] = max{arr[k],k \in [l,r]}$, 显然有状态转移方程：<br>$$<br>dp[i] = \min(dp[j] + max[j+1, i])<br>$$</p><p>是一种经典的枚举断点从而转移的序列分段DP，然而复杂度过高，稍微想想没什么显然的等效转移or状态。  </p><p>接着考虑优化此方程，然而也很困难，$max[k+1,i]$是一个与当前状态变量有关的函数，这样$i$每增加1，我们都必须得考虑每个合法决策来确定决策对当前状态的评分。这也不是简单多项式函数，可以利用斜率优化解决的。  </p><p>四边形不等式？需要有$max[k,i+1] + max[k+1,i] &gt;= max[k,i] + max[k+1,i+1]$，<br>这个式子乍一看像成立的，然而并不成立（虽然对不少小规模数据是可以成立的，这也提醒我们四边形不等式的打表一定要打的长一些，不能太懒），考虑$k$与$i+1$位置上出现有俩$inf$，此时等式左边只有一个$inf$，而等式右边俩$inf$，显然不成立。  </p><p>考虑定值，斜率优化，四边形不等式全挂了，只剩一个单调性了。  </p><p>从实际意义出发：<br>考虑前后两个决策$k$, $k+1$显然有<br>$$<br>dp[k] \leq dp[k+1]<br>$$<br>$$<br>max[k+1,i] \geq max[k+2,i]<br>$$<br>即非严格单调性，那如果$k+1$想成为最优决策，必须有$<br>max[k+2,i] &lt; max[k+1,i]$,进而可以推出$arr[k+1] = max[k+1,i]$（注意两个条件并不等价）  </p><p>可以发现，我们似乎把不确定的$max[k+1,i]$化为了一个数组中的定值，然而决策$k+1$中的函数是$max[k+2,i]$，那怎么办呢？既然$k+1$可能成为最优决策可以确定$max[k+1,i]$的值，那不妨我们就去找$k+2$或更后面的决策可能成为最优决策的时候$max[k+2,i]$的值也便确定了。  </p><p>基于此思路，由于前面的限制条件$sum[i] - sum[k] \leq m$,是一个”越前面越难满足的条件”，说白了就是从队头出队，所以我们可以维护一个单调队列，其中$arr[k]$单调递减，显然队列中第$k$项的$max$函数就是下一项的的值。这样对于一个决策，只要队列中的下一项不变，它的评分就与$i$无关，是一个定值，这样就化为了模板题，用堆or平衡树维护决策集合即可。由于本题中出队时，需要有删除操作，而堆要删除每次还要记录指针，相当麻烦，不如直接用平衡树，复杂度也是$O(nlogn)$，常数大一些。  </p><p>讨论至此，您写出来可能发现样例都过不了，因为忽视了讨论的“前提条件”，我们考虑了$k+1$，用$k$肯定or否定了它的最优性，那么有没有这样一个决策，前面没有决策呢？显然就是最小的满足$sum[i] - sum[k] \leq m$的$k$。  </p><p>程序实现上，由于队列中最后一项的$max$函数的值一定是$arr[i]$，我们可以在转移前把$arr[i]$入队计算即可。<br>另外要注意特判平衡树or队列为空的情况，避免RE或WA。  </p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> lint inf = <span class="number">1e16</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], q[maxn];</span><br><span class="line">lint m, sum[maxn], dp[maxn];</span><br><span class="line"><span class="built_in">multiset</span>&lt;lint&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[q[pos]] + arr[q[pos + <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readint(n), readint(m);</span><br><span class="line">    <span class="comment">// 无解与正常计算分开判断</span></span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        readint(arr[i]), sum[i] = sum[i<span class="number">-1</span>] + arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; m) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>, p=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; i &amp;&amp; sum[i] - sum[p] &gt; m) p++;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; sum[i] - sum[q[l]] &gt; m) s.erase(s.find(calc(l++)));</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r &amp;&amp; arr[q[r]] &lt;= arr[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; r) s.erase(s.find(calc(r - <span class="number">1</span>)));</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) s.insert(calc(r - <span class="number">1</span>));</span><br><span class="line">        dp[i] = dp[p] + arr[q[l]];</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) dp[i] = min(dp[i], *s.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个长度为$n$的序列A，要求把该序列分成若干段，在满足“每段中所有数的和”不超过$m$的前提下，让“每
      
    
    </summary>
    
      <category term="POJ" scheme="http://arintaro.com/categories/POJ/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/POJ/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="动态规划的转移优化" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%BC%98%E5%8C%96/"/>
    
      <category term="单调队列" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>高斯消元</title>
    <link href="http://arintaro.com/2019/10/31/Template/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    <id>http://arintaro.com/2019/10/31/Template/数学/线性代数/高斯消元/</id>
    <published>2019-10-31T02:54:23.836Z</published>
    <updated>2019-10-31T06:19:44.151Z</updated>
    
    <content type="html"><![CDATA[<p>注意无解和多解的判断<br><a id="more"></a> </p><h2><span id="一-概念">一、概念</span></h2><p>@card{</p><p>先确定这次要消哪元，然后从还没被确定的方程中选一个系数不为$0$的消其他所有该元系数不为$0$的方程，无解即存在$0 = 4$这种方程，多解即存在$0 = 0$的方程。</p><p>}</p><h2><span id="二-测试地址">二、测试地址</span></h2><p>@card{</p><p>Luogu高斯消元模版：<a href="https://www.luogu.org/record/26019277" target="_blank" rel="noopener">https://www.luogu.org/record/26019277</a></p><p>}</p><h2><span id="三-代码">三、代码</span></h2><p>@card{<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zero(x) (fabs((x)) &lt; eps)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> c[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint t=<span class="number">1</span>, p=<span class="number">1</span>; t&lt;=n; t++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=p; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(zero(c[i][t])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=n+<span class="number">1</span>; k++) swap(c[i][k], c[p][k]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(zero(c[p][t])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == p || zero(c[i][t])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">double</span> rate = c[i][t] / c[p][t];</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=n+<span class="number">1</span>; k++) c[i][k] -= c[p][k] * rate;</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, p=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(p &lt;= n &amp;&amp; zero(c[i][p])) p++;</span><br><span class="line"><span class="keyword">if</span>(p == n + <span class="number">1</span> &amp;&amp; !zero(c[i][p])) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, p=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(p &lt;= n &amp;&amp; zero(c[i][p])) p++;</span><br><span class="line"><span class="keyword">if</span>(p == n + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=n+<span class="number">1</span>; j++) readint(c[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = calc();</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"x%d=%.2lf\n"</span>, i, c[i][n+<span class="number">1</span>] / c[i][i]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注意无解和多解的判断&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数学" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性代数" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HAOI2015 树上染色</title>
    <link href="http://arintaro.com/2019/10/31/Answer/color/"/>
    <id>http://arintaro.com/2019/10/31/Answer/color/</id>
    <published>2019-10-31T02:03:25.740Z</published>
    <updated>2019-10-31T11:41:02.748Z</updated>
    
    <content type="html"><![CDATA[<p>换个思路，统计贡献<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>有一棵点数为$n$的树，树边有边权，你要在这棵树中选择$k$个点，将其染成黑色，并将其他的$n-k$个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益，问收益最大值。</p><p>$1&lt;=n&lt;=2000$，$0&lt;=k&lt;=n$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先迅速地打出暴力，枚举选哪些，然后每个节点作根暴力计算答案，手玩了一下没发现有什么贪心性质。</p><p>由于是树上的路径之和，考虑类似树上差分的想法，即有很多个点对，每次都会把它们之间的路径覆盖一次，求每个边的边权乘以覆盖次数的和，对每条边计算覆盖次数即可。</p><p>此题中的覆盖一条边的覆盖次数显然是子树中的某色点数量乘子树外的某色点数量，由于色点数量给定，一旦我们知道了一端的数量，就能通过整体减去局部的方法计算出另外一端。</p><p>所以可以先确定自下而上的计算顺序，状态定义为某个子树中选$k$个黑点所有边产生的最大贡献，类似费用提前计算，之后直接跑树上背包即可，注意应用上下界剪枝优化到$O(n^2)$</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计路径贡献 -&gt; 树上差分，考虑一条边的贡献 (费用提前计算)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体减局部为另外，正难则反</span></span><br><span class="line"><span class="comment">// 以x为根的子树，k个黑点，所有边的最大贡献</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">lint dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line"><span class="keyword">for</span>(rint j=min(m, size[x] + size[y]); j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint k=max(<span class="number">0</span>, j-size[x]); k&lt;=j &amp;&amp; k&lt;=size[y]; k++) &#123;</span><br><span class="line">dp[x][j] = max(dp[x][j], dp[x][j-k] + dp[y][k] + (lint)k * (m - k) * ew[i] +</span><br><span class="line">((lint)size[y] - k) * (n - size[y] - (m - k)) * (lint)ew[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[root][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;换个思路，统计贡献&lt;br&gt;
    
    </summary>
    
      <category term="省选" scheme="http://arintaro.com/categories/%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>USACO12FEB 附近的牛 Nearby Cows</title>
    <link href="http://arintaro.com/2019/10/31/Answer/cow1/"/>
    <id>http://arintaro.com/2019/10/31/Answer/cow1/</id>
    <published>2019-10-31T00:26:43.109Z</published>
    <updated>2019-10-31T01:22:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>强行与牛有关<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>树上每个点有一个点权，求每个点距离不超过$k$的点权。<br>其中$1&lt;=k&lt;=20$, $1&lt;=n&lt;=10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>注意要求全部点的答案，并且$k$较小，所以很可能是个换根DP。</p><p>又注意到对于任意一种转移顺序，某个点$x$的$dp[x][k]$，不可能转移到$y$的$dp[x][k+1]$，所以可以直接在状态内记录当前点范围为$k$的答案。规定计算顺序自下而上，先确定一个根，计算子树内的信息，之后再自上而下的根据父节点的答案算这个节点的答案即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">20</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxk], res[maxn][maxk];</span><br><span class="line"><span class="comment">// 从x出发不超过k</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=m; k++) sum[x][k] += sum[y][k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">res[y][<span class="number">0</span>] = sum[y][<span class="number">0</span>];</span><br><span class="line">res[y][<span class="number">1</span>] = sum[y][<span class="number">1</span>] + sum[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">2</span>; k&lt;=m; k++) &#123;</span><br><span class="line">res[y][k] = res[x][k<span class="number">-1</span>] - sum[y][k<span class="number">-2</span>] + sum[y][k];</span><br><span class="line">&#125;</span><br><span class="line">dfs2(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(x), readint(y);</span><br><span class="line">addedge(x, y), addedge(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(sum[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=m; k++) sum[i][k] = sum[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">dfs1(root, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;=m; k++) res[root][k] = sum[root][k];</span><br><span class="line">dfs2(root, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强行与牛有关&lt;br&gt;
    
    </summary>
    
      <category term="USACO" scheme="http://arintaro.com/categories/USACO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/USACO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2003 消防局的设立</title>
    <link href="http://arintaro.com/2019/10/30/Answer/fire/"/>
    <id>http://arintaro.com/2019/10/30/Answer/fire/</id>
    <published>2019-10-30T08:24:46.725Z</published>
    <updated>2019-10-30T09:44:29.080Z</updated>
    
    <content type="html"><![CDATA[<p>少数几道贪心扩展性超过DP的题目<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>从树上选出最少的点，每个点可以覆盖与它距离不超过2的点，求最少需要选出多少点。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>贪心做法扩展性强，且容易理解，但是这里不讲。<br>本问题有很多前置形态，比如”每条边连接的两点必须任选一个”, 只需要记录每个点选不选就行了，但是此题影响的距离是2，这启发我们需要在DP状态上记录更多的信息便于转移。</p><p>树上问题一般要先确定计算顺序是自上而下还是自下而上，这里选择自上而下显然不容易设计出状态，所以选择每次从子树向上转移的自下而上。</p><p>确定计算顺序后，容易想到状态是”某范围中的点都被管辖所需要的最少点数”，按常规考虑是一个点子树中的点都被管辖，但是手玩几组数据发现，这样设计状态，一个点是可以从它的孙子甚至曾孙转移来的，这样设计状态难以转移，如果暴力追溯转移，时间上显然会爆炸。不容易优化转移，考虑重新设计状态，又想到附加儿子或孙子选不选的小范围状压维度，进一步考虑，我们事实上不关心子树中选了什么点，而是想通过知道这些点选没选而得知它向上覆盖的范围，所以我们规定状态为”某个点向上/向下覆盖了多少层选的最少点数”, 考虑一个节点$x$，它向下两层的节点必须在它这里被覆盖，否则按照我们的计算顺序，它以后都没机会被覆盖了，所以状态中记录的向上向下的最大层数为2。</p><p>接着考虑如何转移，$dp[x][0]$为它的孙子被完全覆盖, 1为儿子都被覆盖, 2为自己被覆盖, 3为父亲被覆盖, 4为祖父为覆盖。</p><p>下设$y$为$x$的儿子，显然有<br>$$<br>dp[x][0] = \sum{dp[y][1]}<br>$$<br>与<br>$$<br>dp[x][1] = \sum{dp[y][2]}<br>$$</p><p>先暂缓一下，这样转移可能会遗漏某些情况，这样转移状态的严谨定义就变成”刚好覆盖到某层的最少点数”，但是会不会有时往上多覆盖了反而用了更少的点？考虑一个边界情况，按照此定义，对于一个叶子节点$x$，$dp[x][2]$显然无法成立，需要设成inf，这显然会影响后续的转移，所以不妨直接将状态定义为”至少覆盖到这层”的最小点数，也可以理解为对状态求后缀min。按此定义，我们可以先按照上述的递推式计算，当$x$的所有状态计算完毕后，再扫一遍取后缀min。</p><p>当覆盖到$x$下面时，子树是分叉的，所有点都需要被覆盖，因此需要求和。但当覆盖到$x$时或以上，变成了只有一支，所以我们只需要覆盖一次，其余子树选最小能覆盖的即可。所以有：<br>$$<br>dp[x][2] = \min(dp[y][3] + \sum_{s \not = y}{dp[s][2]})<br>$$<br>为了程序实现方便，上述方程可以改写为<br>$$<br>dp[x][2] = dp[x][1] + \min(dp[y][3] - dp[y][2])<br>$$<br>当能覆盖$x$上一层时，需要某个子节点向上覆盖两层，需要注意这个覆盖对于其他子树也会成立，因此有<br>$$<br>dp[x][3] = \min(dp[y][4] + \sum_{s \not = y}{dp[s][1]})<br>$$<br>当$x$向上覆盖两层，显然$x$一定是被选上的，所以有<br>$$<br>dp[x][4] = \sum{dp[y][0]} + 1<br>$$<br>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 影响后续计算的放状态里</span></span><br><span class="line"><span class="comment">// 树形问题计算顺序自下而上，自上而下</span></span><br><span class="line"><span class="comment">// 自下而上</span></span><br><span class="line"><span class="comment">// dp[x][0]表示x一层以下都被覆盖最少代价</span></span><br><span class="line"><span class="comment">// dp[x][1] x以下都被覆盖</span></span><br><span class="line"><span class="comment">// dp[x][2] x被覆盖</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[x][2] = dp[x][1] + min&#123;- dp[y][2] + dp[y][3]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dp[x][<span class="number">2</span>] = dp[x][<span class="number">3</span>] = maxn;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line">dp[x][<span class="number">4</span>] += dp[y][<span class="number">0</span>];</span><br><span class="line"><span class="comment">// x一层以下都被覆盖</span></span><br><span class="line">dp[x][<span class="number">0</span>] += dp[y][<span class="number">1</span>];</span><br><span class="line"><span class="comment">// x以下被覆盖</span></span><br><span class="line">dp[x][<span class="number">1</span>] += dp[y][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// x被覆盖</span></span><br><span class="line">dp[x][<span class="number">2</span>] = min(dp[x][<span class="number">2</span>], dp[y][<span class="number">3</span>] - dp[y][<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// x上一层被覆盖</span></span><br><span class="line">dp[x][<span class="number">3</span>] = min(dp[x][<span class="number">3</span>], dp[y][<span class="number">4</span>] - dp[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">dp[x][<span class="number">4</span>]++, dp[x][<span class="number">2</span>] += dp[x][<span class="number">1</span>], dp[x][<span class="number">3</span>] += dp[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">3</span>; k&gt;=<span class="number">0</span>; k--) dp[x][k] = min(dp[x][k], dp[x][k+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">2</span>, y; x&lt;=n; x++) &#123;</span><br><span class="line">readint(y);</span><br><span class="line">addedge(x, y), addedge(y, x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[root][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;少数几道贪心扩展性超过DP的题目&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="后效性的处理" scheme="http://arintaro.com/tags/%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://arintaro.com/2019/10/28/Template/%E5%AD%97%E7%AC%A6%E4%B8%B2/ac/"/>
    <id>http://arintaro.com/2019/10/28/Template/字符串/ac/</id>
    <published>2019-10-28T14:07:45.546Z</published>
    <updated>2019-10-28T22:38:49.434Z</updated>
    
    <content type="html"><![CDATA[<p>大概可以用来AC, 本文主要是记录性质, 大概会看不懂。<br><a id="more"></a> </p><h2><span id="一-概念">一、概念</span></h2><p>@card{</p><p>AC自动机是基于Trie建立的, Trie上的一个节点到根节点的路径会确定唯一的一个字符串,表示的是插入Trie的某个字符串的前缀。</p><p>解决多模式串匹配问题时, 先把所有的模式串插入Trie中, 再进行建树。</p><p>AC自动机对于Trie上的每个节点构造fail指针, 其指向<strong>Trie上与这个节点的后缀匹配的最长真前缀</strong>的节点, 朴素的计算方法类似KMP或者是递推, 如果父节点的fail不能继续匹配自身, 就跳fail到次长, 如果找不到就连在根节点上, 时间复杂度显然不优, 优化后建出Trie图, 同时修改Trie上边的定义, 为<strong>当前节点加上这个字符后的后缀Trie上能匹配的最长前缀</strong>, 由于没有”真”, 这对原Trie上的边也是适用的。然后我们就可以递推地以深度作为状态去计算这两种指针, 当遍历到一个节点时, 遍历字符集, 当原Trie上有这条边时, 我们需要计算它的fail, 显然是$pv[fail[x]][c]$, 即与当前节点后缀匹配的最长真前缀再加上转移的字符的后缀在Trie上能匹配的最长前缀(大概用形式化的语言说出来就没有这么绕了), 感性的理解一下就是尝试给fail再加个字符去匹配, 需要对自身跳fail去找是因为fail需要是<strong>真</strong>前缀。</p><p>多模式串匹配时, 按序遍历主串, 每次当前节点跳Trie图上的边即可, 即对每个主串的前缀, 用它的后缀去找Trie上能匹配的最长前缀, 找到这个最长前缀后, 从它一直跳fail跳到根节点, 就能找到Trie上所有能与这个后缀匹配的前缀了。</p><p>注意每个节点有且仅有一条fail边, 那么其实所有fail边与点构成一棵树, 一个节点往上跳fail的过程其实就遍历它到根节点的路径, 基于这个性质, 我们可以在fail树上跑一些树形数据结构来维护一些东西。如维护出现次数树上差分等。</p><p>}</p><h2><span id="二-实现">二、实现</span></h2><h2><span id="三-代码">三、代码</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概可以用来AC, 本文主要是记录性质, 大概会看不懂。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="字符串" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="字符串" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>小型人类智慧题/脑筋急转弯汇总</title>
    <link href="http://arintaro.com/2019/10/27/Answer/brain/"/>
    <id>http://arintaro.com/2019/10/27/Answer/brain/</id>
    <published>2019-10-27T13:24:46.584Z</published>
    <updated>2019-10-27T13:37:28.570Z</updated>
    
    <content type="html"><![CDATA[<p>自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。<br><a id="more"></a></p><h2><span id="t1-盛最多水的容器">T1: 盛最多水的容器</span></h2><p>@card{</p><p>site: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>给定一个数组, 要求$O(n)$求出最大的$|i - j| \times \min(arr[i], arr[j])$。</p><p>考虑枚举一个端点, 用$O(1)$的时间求出另一端的最优决策, 发现很难维护, 没有决策单调性, 按照$arr[j]$的大小分组用斜率优化+数据结构维护复杂度势必要多个$log$。</p><p>考虑重排序, 发现无论按下标排序or按值排序$abs$与$min$都很难维护。</p><p>正解是左右两端指针往中间扫, 即不确定”主指针”, 而是每次考虑移动任意一个指针去掉不可能的答案。这里每次只要把值较小的指针往中间移动即可, 正确性显然, 考虑任意一个端点在当前指针区间$[l, r]$外的的决策已经被更新进答案, 不妨设$arr[l]$较小, 则移动$l$其实就是去掉了所有左端点为$l$, 右端点在$(l, r]$的决策, 这其中的决策显然没有$[l, r]$好, 所以就推到了指针区间$[l+1, r]$所有区间外的决策已经被正确更新, 由数学归纳法知这么做不会遗漏答案。</p><p>}</p><h2><span id="solution">Solution:</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="人类智慧" scheme="http://arintaro.com/tags/%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>小工具合集</title>
    <link href="http://arintaro.com/2019/10/27/Template/%E5%B0%8F%E5%B7%A5%E5%85%B7/small-tool/"/>
    <id>http://arintaro.com/2019/10/27/Template/小工具/small-tool/</id>
    <published>2019-10-27T10:21:08.341Z</published>
    <updated>2019-10-27T10:35:40.796Z</updated>
    
    <content type="html"><![CDATA[<p>比较有用, 但比较简短懒得单独开一页的技巧。<br><a id="more"></a></p><h4><span id="1二进制子集枚举">1.二进制子集枚举</span></h4><p>@card{<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">22</span>; <span class="comment">// 全集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=S; i; i=(i<span class="number">-1</span>)&amp;S) &#123;</span><br><span class="line">    <span class="comment">// 此时i即为S的子集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举$n$位二进制数, 再依次枚举它的子集, 复杂度为$O(3^n)$<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较有用, 但比较简短懒得单独开一页的技巧。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="工具" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="语言" scheme="http://arintaro.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="奇淫技巧" scheme="http://arintaro.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Luogu 买菜</title>
    <link href="http://arintaro.com/2019/10/27/Answer/vegetable/"/>
    <id>http://arintaro.com/2019/10/27/Answer/vegetable/</id>
    <published>2019-10-27T02:00:24.681Z</published>
    <updated>2019-10-27T02:26:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>模拟赛里的题, 没有题面(<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个字符串 𝑆 和一个字符串集合 𝑇，询问 𝑆 中最短的包含 𝑇 的子串。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>如果我们能够在不会T掉的时间内处理出所有字符串的出现位置, 这个问题就可以直接变成选区间问题, 从而应用双指针或其他算法解决。但我考场一想, 这个玩意不是$O(n^2)$级的么, 根本不可能。然而事实上远远不到这个级别, 考虑按长度分组, 去重后每个长度显然至多会有$O(n)$级的匹配数, 由于总长度给定, 不同长度的数量至多有$O(\sqrt{n})$种, 所以是$O(n\sqrt{n})$的。</p><h4><span id="算法1-字符串hash-双指针">算法1: 字符串hash + 双指针</span></h4><p>基于上述复杂度证明, 我们可以采用子串hash与hash表直接得到一个$O(n\sqrt{m} + m)$的多模式串匹配算法, 其中$m$为模式串总长度。具体做法是去重后按长度分组, 扫描前把这个长度的字符串的hash值插入hash表, 然后匹配即可。所以问题转化为:</p><blockquote><p>在长为m的直线上有n种区间, 求直线覆盖所有n种区间的最短线段</p></blockquote><p>做法有很多, 我的做法是开两个vector记录区间起点与终点：如果左指针扫到了一个起点, 那么对应种类的计数直接减一(其中可能会有当前右指针尚未扫到这个区间的终点, 导致计数器变成负数的情况, 不过不要紧); 如果右指针扫到了一个终点, 计数器直接加一, 如果计数器当前为负数, 就相当于”还上了之前欠的债”。每个区间被选上的条件是它自己的出现计数器大于等于$1$。对每个左指针让右指针一直往右扫, 直到当前选上了全部的区间。</p><h4><span id="算法2-ac自动机后缀平衡树-二叉堆">算法2: AC自动机/后缀平衡树 + 二叉堆</span></h4><p>我还不会, 待更。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eco(c) ((int)(c) - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">5000087</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mhash_set</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxnode = htmod + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxnode], nxt[<span class="number">2</span> * maxn], id[<span class="number">2</span> * maxn], totnode;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">2</span> * maxn], stop;</span><br><span class="line">ull val[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">totnode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(stop) head[s[stop--]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ull x, <span class="keyword">int</span> nid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = x % htmod;</span><br><span class="line">s[++stop] = pos;</span><br><span class="line">val[++totnode] = x, id[totnode] = nid;</span><br><span class="line">nxt[totnode] = head[pos], head[pos] = totnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(ull x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = x % htmod;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[pos]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] == x) <span class="keyword">return</span> id[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">calc_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">ull res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=len; i++) res = res * base + eco(s[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ull prehash[maxn], basepow[maxn];</span><br><span class="line"><span class="keyword">char</span> s1[maxn], temp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一维编号， 第二维1表示开始，-1表示结束</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line">ull x; <span class="keyword">int</span> len;</span><br><span class="line">str() &#123;&#125;</span><br><span class="line">str(ull xx, <span class="keyword">int</span> ll): x(xx), len(ll) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> str&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">calc_hash</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> prehash[R] - prehash[L - <span class="number">1</span>] * basepow[R - L + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=m; i++) &#123;</span><br><span class="line">ull res = calc_hash(i, i + len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nid = ht.find(res);</span><br><span class="line"><span class="keyword">if</span>(nid != <span class="number">0</span>) &#123;</span><br><span class="line">st[i].push_back(nid), ed[i + len - <span class="number">1</span>].push_back(nid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st[maxn], ed[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_color[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans_len, ans_l, ans_r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = (cnt_color[c] &gt;= <span class="number">1</span>);</span><br><span class="line">cnt_color[c] += x;</span><br><span class="line">cnt += (cnt_color[c] &gt;= <span class="number">1</span>) - pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ans_len = m;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= m &amp;&amp; cnt &lt; n) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;ed[j].size(); k++) update(ed[j][k], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j &gt; m) <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">if</span>(j - i + <span class="number">1</span> &lt; ans_len) &#123;</span><br><span class="line">ans_len = j - i + <span class="number">1</span>, ans_l = i, ans_r = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;st[i].size(); k++) update(st[i][k], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">basepow[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s1+<span class="number">1</span>), m = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">basepow[i] = basepow[i<span class="number">-1</span>] * base;</span><br><span class="line">prehash[i] = prehash[i<span class="number">-1</span>] * base + eco(s1[i]);</span><br><span class="line">&#125;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(temp + <span class="number">1</span>); ull res = calc_hash(temp, len);</span><br><span class="line"><span class="keyword">if</span>(!ht.find(res)) &#123;</span><br><span class="line">s2[++tot] = str(res, len), ht.insert(res, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = tot;</span><br><span class="line">sort(s2+<span class="number">1</span>, s2+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = i, r = i;</span><br><span class="line"><span class="keyword">while</span>(r &lt;= n &amp;&amp; s2[r].len == s2[l].len) r++;</span><br><span class="line">i = --r;</span><br><span class="line">ht.clear();</span><br><span class="line"><span class="keyword">for</span>(rint j=l; j&lt;=r; j++) ht.insert(s2[j].x, j);</span><br><span class="line">match(s2[l].len);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(rint i=ans_l; i&lt;=ans_r; i++) <span class="built_in">putchar</span>(s1[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟赛里的题, 没有题面(&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串匹配" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="双指针" scheme="http://arintaro.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1121 环状最大两段子段和</title>
    <link href="http://arintaro.com/2019/10/24/Answer/sum/"/>
    <id>http://arintaro.com/2019/10/24/Answer/sum/</id>
    <published>2019-10-24T13:24:25.109Z</published>
    <updated>2019-10-24T14:09:04.321Z</updated>
    
    <content type="html"><![CDATA[<p>大概特判才是主要难点(<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个环状序列, 可以选其中两段连续不相交的子段, 求它们的最大和</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于这种”两段”问题的处理, 一般有两种方法：第一种是枚举切点, 用前后两段的”一段”的最优去组合答案；第二种是在DP状态内记录当前选了几段, 从而进行转移。</p><h4><span id="算法1-枚举切点-正难则反">算法1: 枚举切点, 正难则反</span></h4><p>考虑序列上怎么做, 显然可以枚举切点用前后两段的最大子段和组合答案。顺着想到可以破环成链跑类似的算法, 然而可能前后两段的长度加起来超过$n$, 从而使答案变大, 这里可以用数据结构维护不同长度的答案(eg. 可持久化平衡树), 然而无论怎么样, 复杂度都会多个$log$。</p><p>考虑在序列上跑完遗落了什么情况, 显然是前后两段接到一起和中间的一段组成答案, 发现这其实在序列上体现为三段, 这三段又分出来了两段, 最优解中这两段之和显然是最小的, 那么用总和减去”序列上最小两段子段和”, 一定能覆盖这种情况。</p><p>然而到这里还远没有结束, 考虑边界情况, 第一种情况只要我们枚举的”两个数之间的断点”在序列中间, 前后两段加起来至少会有两个数字, 因此是没有问题的。但是第二种情况, 我们求出的”序列上最小两段子段和”的长度$len &gt; n-2$的话, 求出来的解就是没有意义的, 由于特判范围较小, 考虑进行讨论。当$len = n$时, 显然序列中必然全是负数, 否则我们在一个正数两边切点就能得到更小的解; 当$len = n-1$时, 我们用来更新答案的值必然是序列中最大的正数, 如果存在另外一个正数, 那么第一种情况一定会比第二种情况求出的答案优秀, 不影响答案, 如果不存在另外一个正数, 那么序列中有且仅有一个正数, 我们显然可以直接得到答案。</p><p>综上, 当序列中正数只有$0$个或$1$个时, 答案为序列中的最大值加次小值, 否则可以应用我们上述的算法, 正确求出答案。</p><h4><span id="算法2-动态规划-一次断开-一次强制连接">算法2: 动态规划, 一次断开, 一次强制连接</span></h4><p>考虑序列上怎么做, 显然我们可以在状态内记录当前选了几个, 以及上个选没选(其实记录上个选没选可以理解为一种小范围的状态压缩去解决一定的后效性)来转移。如果破环成链势必又面临维护麻烦的长度限制的问题, 所以考虑强制连接。</p><p>强制连接后前后两个视为一段, 在中间找第三段即可, 即求出不强制连接时的两段答案, 和强制连接后的三段答案就可覆盖所有情况。</p><p>这种方法常数不太好, 但是不用考虑麻烦的边界情况, 是考场比较优秀的算法。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = -inf, sum, max1 = -inf, max2 = -inf;</span><br><span class="line"><span class="keyword">int</span> presum[maxn], sufsum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) presum[i] = max(presum[i<span class="number">-1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line"><span class="keyword">for</span>(rint i=n; i&gt;=<span class="number">1</span>; i--) sufsum[i] = max(sufsum[i+<span class="number">1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) presum[i] = max(presum[i<span class="number">-1</span>], presum[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) sufsum[i] = max(sufsum[i+<span class="number">1</span>], sufsum[i]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]), sum += arr[i];</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt;= <span class="number">0</span>) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt;= max1) max2 = max1, max1 = arr[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; max2) max2 = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = max1 + max2;</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">calc();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) ans = max(ans, presum[i] + sufsum[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = -arr[i];</span><br><span class="line">calc();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) ans = max(ans, sum + presum[i] + sufsum[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概特判才是主要难点(&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="经典模型" scheme="http://arintaro.com/tags/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="正难则反" scheme="http://arintaro.com/tags/%E6%AD%A3%E9%9A%BE%E5%88%99%E5%8F%8D/"/>
    
      <category term="两段处理" scheme="http://arintaro.com/tags/%E4%B8%A4%E6%AE%B5%E5%A4%84%E7%90%86/"/>
    
      <category term="环形处理" scheme="http://arintaro.com/tags/%E7%8E%AF%E5%BD%A2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1654 OSU!</title>
    <link href="http://arintaro.com/2019/10/24/Answer/osu/"/>
    <id>http://arintaro.com/2019/10/24/Answer/osu/</id>
    <published>2019-10-24T05:40:42.504Z</published>
    <updated>2019-10-30T08:28:01.841Z</updated>
    
    <content type="html"><![CDATA[<p>感觉期望还是比较冷门的考察方向<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个$n$个位置, 每个位置有$p_i$的概率为$1$, 否则为0, 每一段极大连续的$1$会产生长度的三次方的分数, 求分数的期望值</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑逐个把1加入计算贡献, 不妨假设前$i-1$个位置的得分期望已经正确求出,。当该位为0时, 显然答案直接累加$i-1$的即可；当该位为1时, 会增大所有”后缀连续1”的贡献, 而对其他贡献没有影响: 对于一个长度在这之前已经为$x$的后缀1段, 增大的贡献显然为$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$, 对于所有这样的串考虑显然只需要代入期望值即可, 所以需要分别维护后缀长度平方的期望和后缀长度的期望。 </p><p>注意后缀长度平方的期望不能直接由后缀长度的期望直接平方得到, 因为它自身显然是不独立的, 不能直接用期望的乘法性质, 乘法要求两个随机变量相互独立。则有:</p><p>$$E(A^3_n) = p_i (E(A^3_n-1) + 3E(B^2_n-1) + 3E(B_n-1) + 1) + (1 - p_i) E(A^3_n-1)$$<br>$$E(B^2_n) = p_i (E(B^2_n-1) + 2E(B_n-1) + 1) + (1 - p_i) \times 0$$<br>$$E(B_n) = p_i(E(B_n-1) + 1) + (1 - p_i) \times 0$$</p><p>Luogu上的题解也有很多从另外的角度思考了, 复习的时候可以看一下：<a href="https://www.luogu.org/problemnew/solution/P1654" target="_blank" rel="noopener">https://www.luogu.org/problemnew/solution/P1654</a><br>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldob long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ldob EA3[maxn], EB1[maxn], EB2[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%Lf"</span>, &amp;p[i]);</span><br><span class="line">EB1[i] = p[i] * (EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * <span class="number">0</span>;</span><br><span class="line">EB2[i] = p[i] * (EB2[i<span class="number">-1</span>] + <span class="number">2</span> * EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * <span class="number">0</span>;</span><br><span class="line">EA3[i] = p[i] * (EA3[i<span class="number">-1</span>] + <span class="number">3</span> * EB2[i<span class="number">-1</span>] + <span class="number">3</span> * EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * EA3[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1Lf\n"</span>, EA3[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉期望还是比较冷门的考察方向&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="递推" scheme="http://arintaro.com/tags/%E9%80%92%E6%8E%A8/"/>
    
      <category term="期望" scheme="http://arintaro.com/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2013 花匠</title>
    <link href="http://arintaro.com/2019/10/23/Answer/flower/"/>
    <id>http://arintaro.com/2019/10/23/Answer/flower/</id>
    <published>2019-10-23T11:53:29.869Z</published>
    <updated>2019-11-01T00:02:57.951Z</updated>
    
    <content type="html"><![CDATA[<p>与黄题斗智斗勇<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>求一个整数序列的最长波峰序列, 详见<a href="https://www.luogu.org/problem/P1970" target="_blank" rel="noopener">https://www.luogu.org/problem/P1970</a></p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这个题思路没什么难的, 主要是实现细节与边界处理。</p><p>做法显然是划分出每个单调递增单调递减的子段, 选上峰点和开头结尾即可。</p><p>问题在于其中会有<strong>相等</strong>的数字, 对于一个区间内的很好处理, 相等是不影响当前区间的单调性的。然而我们在设初值时, 会设为$a[1], a[2]$的关系, 我一开始没有考虑$a[1]$, $a[i]$相等了该怎么办。另外, 当$n=1$和$n = 2 and a[1] == a[2]$时, “选上开头结尾”是无法做到的, 需要特判。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> + (arr[<span class="number">2</span>] != arr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] == arr[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">-1</span>) x = (arr[i] &gt; arr[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((arr[i] &gt; arr[i<span class="number">-1</span>]) != x) ans++, x ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与黄题斗智斗勇&lt;br&gt;
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="边界处理" scheme="http://arintaro.com/tags/%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2010 观光公交</title>
    <link href="http://arintaro.com/2019/10/23/Answer/bus/"/>
    <id>http://arintaro.com/2019/10/23/Answer/bus/</id>
    <published>2019-10-23T09:33:02.040Z</published>
    <updated>2019-11-01T00:02:51.743Z</updated>
    
    <content type="html"><![CDATA[<p>你以为我是DP,其实我是贪心啦dio<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>题意较为复杂,套的壳比较多,可见<a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">https://www.luogu.org/problem/P1315</a><br>要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。</p><p>接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(<del>事实上远远跑不到</del>); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。</p><p>我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(<del>这两个名词都是我瞎编的</del>)</p><h4><span id="算法1贪心">算法1：贪心</span></h4><p>直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。</p><p>同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。</p><h4><span id="算法2优化后的贪心">算法2：优化后的贪心</span></h4><p>发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(<del>然而并没有</del>), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。</p><h4><span id="算法3-数据结构优化贪心">算法3: 数据结构优化贪心</span></h4><p>考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], leave[maxn], arrive[maxn], w[maxn];</span><br><span class="line">lint sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(k);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) readint(w[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t, st, ed;</span><br><span class="line">readint(t), readint(st), readint(ed);</span><br><span class="line">cnt[ed]++, sum[ed] += t;</span><br><span class="line">leave[st] = max(leave[st], t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) arrive[i] = max(arrive[i<span class="number">-1</span>], leave[i<span class="number">-1</span>]) + w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> res_st = <span class="number">0</span>, res_ed = <span class="number">0</span>, res_w = <span class="number">0</span>, res_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; ) &#123;</span><br><span class="line"><span class="keyword">if</span>(w[i] == <span class="number">0</span>) &#123; i++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> now_w = min(w[i], k), now_cnt = <span class="number">0</span>;</span><br><span class="line">rint j = i;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123;</span><br><span class="line">now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]);</span><br><span class="line">&#125;</span><br><span class="line">now_cnt += cnt[j];</span><br><span class="line"><span class="keyword">if</span>(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt;</span><br><span class="line">i = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res_w == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">w[res_st] -= res_w, k -= res_w;</span><br><span class="line"><span class="keyword">for</span>(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w;</span><br><span class="line">&#125;</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你以为我是DP,其实我是贪心啦dio&lt;br&gt;
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="迭代" scheme="http://arintaro.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2009 道路游戏</title>
    <link href="http://arintaro.com/2019/10/23/Answer/road/"/>
    <id>http://arintaro.com/2019/10/23/Answer/road/</id>
    <published>2019-10-23T02:52:08.757Z</published>
    <updated>2019-11-01T00:02:46.515Z</updated>
    
    <content type="html"><![CDATA[<p>千万不要以为普及组都是水题<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>题意较为复杂,套的壳比较多,可见<a href="https://www.luogu.org/problem/P1070" target="_blank" rel="noopener">https://www.luogu.org/problem/P1070</a><br>要点: 在任意时间必须有且仅有一个机器人,可以赔钱</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>分析一下思路,发现有明显的时间顺序,又是一个最优化问题,可以确定是动态规划。<br>费用比较奇怪,题面描述是个边权,不过我们显然可以下放到到点上,比如$1 -&gt; 2 -&gt; 3$,从1走两次到3,累加了两段路上金币,可以发现从$i$走$p$次就是累加$[i, i + x - 1]$的金币。手玩一下可以发现只要对费用矩阵斜着求前缀和即可。<br>由于是环形问题,为了方便最好把行上的编号重编至$[0, n-1]$。如果沿用$[1, n]$, 需要在每次”可能越界前”,先把编号-1取模再+1映射回来。</p><h4><span id="算法1暴力dp">算法1：暴力DP</span></h4><p>题里没什么影响决策的限制条件,记录时间即可,转移显然需要枚举出发点和走多远,稍微算下复杂度$O(nmp)$。期望得分90pts, <del>实际得分100pts</del></p><h4><span id="算法2转移优化dp">算法2：转移优化DP</span></h4><p>由于给了较多的部分分,我们可以相信这与正解已经相差不远,所以先考虑转移优化,而不是状态优化。</p><p>这种求前缀和的分段转移模型,一般写出”我从哪里来”形式的方程,显然我们有: </p><p>$$dp[i] = min{dp[j] + sum[x][i] - sum[(x - (i - j)) mod n][j] - val[(x - (i - j) + 1) mod n] }   ( i - p &lt;= j &lt;= i - 1) $$</p><p>注意一个细节, 序列上的”前缀和”求$[l, r]$的和时需要用$sum[r] - sum[l - 1]$,在方程中体现的是”出发点事实上是$x + 1$”。另外具体实现时,由于涉及到模意义下的减法,尽量加模数后再取模防止负数。</p><p>决策变量两维, 发现$n^2$可以接受, 考虑先枚举一维, 涉及$x$的量较多, 考虑先确定$x$, 略去$mod n$后</p><p>$$dp[i] = min{dp[j] - sum[x - (i - j)][j] - val[x - (i - j) + 1] }  + sum[x][i] ( i - p &lt;= j &lt;= i - 1)$$</p><p>可以发现与常规的优化DP不同, 一个决策$j$的价值可能与$x, i$有关,使得我们无法高效的维护决策集合,如果我们能使得$j$的价值与$x, i$无关,就可以用单调队列或平衡树等数据结构直接维护价值,每次直接转移,而不需要在得到$x, i$后对决策集合中的每个决策重新计算价值。</p><p>把确定的变量$x, i$整理到一起后, 发现内层价值数组中的下标只与$x - i$有关, 而在$mod n$意义下$x - i$的值显然至多只有$n$种,从多重背包在剩余系下的优化转移得到启发,我们可以按其在剩余系的模数分类,开$n$个不同的决策集合,这样对于决策$j$来讲关于$x - i$的部分即可化为定值。限制条件中上界下界单调递增, 显然可以用单调队列把转移的时间摊到$O(1)$</p><p>从实际含义上讲,这对应了在费用矩阵上不同的”斜列”转移(即我们斜着求前缀和的$n$个不同序列), 每次内层$x$增加时, 对应在不同斜列上的移动。</p><p>此题启发我们可以对决策集合进行”分类”, 从而消除状态变量对一个决策价值的影响。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eco(x) ((x) % n == 0 ? n : (x) % n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> id[maxn][maxn], w[maxn][maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn], ql[maxn], qr[maxn];</span><br><span class="line">pii mq[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">readint(n), readint(m), readint(p);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">readint(w[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(c[i]);</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">w[i][j] += w[eco(i<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i, y = <span class="number">1</span>;</span><br><span class="line">ql[i] = <span class="number">1</span>, qr[i] = <span class="number">1</span>;</span><br><span class="line">mq[i][<span class="number">1</span>] = mp(-c[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(y &lt;= m) &#123;</span><br><span class="line">id[x][y] = i;</span><br><span class="line">x = eco(x + <span class="number">1</span>), y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint t=<span class="number">1</span>; t&lt;=m; t++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid];</span><br><span class="line">pii (&amp;q)[maxn] = mq[qid];</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; t - q[l].second &gt; p) l++;</span><br><span class="line">dp[t] = max(dp[t], w[x][t] + q[l].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid];</span><br><span class="line">pii (&amp;q)[maxn] = mq[qid];</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; q[r].first &lt; dp[t] - w[x][t] - c[eco(x+<span class="number">1</span>)]) r--;</span><br><span class="line">q[++r] = mp(dp[t] - w[x][t] - c[eco(x+<span class="number">1</span>)], t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千万不要以为普及组都是水题&lt;br&gt;
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="环形处理" scheme="http://arintaro.com/tags/%E7%8E%AF%E5%BD%A2%E5%A4%84%E7%90%86/"/>
    
      <category term="动态规划的转移优化" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%BC%98%E5%8C%96/"/>
    
      <category term="单调队列" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习资料汇总</title>
    <link href="http://arintaro.com/2019/10/01/Essay/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://arintaro.com/2019/10/01/Essay/算法学习资料汇总/</id>
    <published>2019-10-01T05:19:49.561Z</published>
    <updated>2019-11-01T13:55:22.292Z</updated>
    
    <content type="html"><![CDATA[<p>主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog<br>由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有</p><a id="more"></a><h2><span id="一-数学">一、数学</span></h2><p>@card{</p><ol><li><h6><span id="线性基">线性基</span></h6><p> <a href="https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br> <a href="https://blog.csdn.net/a_forever_dream/article/details/83654397" target="_blank" rel="noopener">https://blog.csdn.net/a_forever_dream/article/details/83654397</a></p></li><li><h6><span id="博弈论">博弈论</span></h6><p> <a href="https://www.cnblogs.com/Wolfycz/p/8430991.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wolfycz/p/8430991.html</a><br> 2007国家集训队论文：王晓珂《解析一类组合游戏》<br> 2009国家集训队论文：贾志豪《组合游戏略述——浅谈SG游戏的若干拓展及变形》</p></li><li><h6><span id="奇异的数列">奇异的数列</span></h6><ul><li>斐波那契数列：<a href="https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、" target="_blank" rel="noopener">https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、</a><br>  $f[n+m]=f[m−1]∗f[n]+f[m]∗f[n+1]$</li></ul></li><li><h6><span id="初等数论">初等数论</span></h6><ul><li><a href="https://sshwy.tk/2019/01/52170/" target="_blank" rel="noopener">https://sshwy.tk/2019/01/52170/</a></li></ul></li><li><h6><span id="康托展开">康托展开</span></h6><ul><li><a href="https://www.luogu.org/blog/abc123-yummy/huoxingren" target="_blank" rel="noopener">https://www.luogu.org/blog/abc123-yummy/huoxingren</a></li><li>其实是规定了一种新的进制</li></ul></li></ol><p>}</p><h2><span id="二-图论">二、图论</span></h2><p>@card{</p><ol><li><h6><span id="负环与差分约束">负环与差分约束</span></h6><p> 求最大值:初始化inf, 跑最短路、求最小值:初始化-inf, 跑最长路<br> SPFA的三种优化: 大于队头从队尾入队、每次队列变化时检查队头队尾距离swap、卡时2e7</p></li><li><h6><span id="双联通分量">双联通分量</span></h6><p> <a href="https://linkfqy.github.io/posts/BCC_and_Tarjan/" target="_blank" rel="noopener">https://linkfqy.github.io/posts/BCC_and_Tarjan/</a><br> 求点双联通分量，根节点在搜索树上需要有两个子树才能被判定为割点</p></li></ol><p>}</p><h2><span id="三-字符串">三、字符串</span></h2><p>@card{</p><ol><li><h6><span id="ac自动机">AC自动机</span></h6><a href="https://ouuan.github.io/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://ouuan.github.io/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener">https://oi-wiki.org/string/ac-automaton/</a></li></ol><p>}</p><h2><span id="四-数据结构">四、数据结构</span></h2><p>@card{</p><ol><li><h6><span id="莫队">莫队</span></h6> <a href="https://www.cnblogs.com/WAMonster/p/10118934.html" target="_blank" rel="noopener">https://www.cnblogs.com/WAMonster/p/10118934.html</a><br> 《算法竞赛中的分块思想》 杭州学军中学 ⾕晟</li></ol><p>}</p><h2><span id="五-动态规划">五、动态规划</span></h2><p>@card {</p><ol><li><h6><span id="悬线法">悬线法</span></h6><p> 2003国家集训队论文《浅谈用极大化思想解决最大子矩形问题》王知昆</p></li><li><h6><span id="树形背包的优化">树形背包的优化</span></h6><p> <a href="https://ouuan.github.io/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://ouuan.github.io/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/</a></p></li></ol><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog&lt;br&gt;由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>基础数学总结</title>
    <link href="http://arintaro.com/2019/09/25/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://arintaro.com/2019/09/25/Algorithm/基础数学总结/</id>
    <published>2019-09-25T07:56:33.502Z</published>
    <updated>2019-10-01T06:52:50.957Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="一-数论">一、数论</span></h2><p>@card{</p><h4><span id="一-质数与因子相关">(一) 质数与因子相关</span></h4><h6><span id="1对于一个足够大的整数n不超过n的质数大约有fracnlnn个">1.对于一个足够大的整数N，不超过N的质数大约有$\frac{N}{ln(n)}$个</span></h6><h6><span id="2一个数至少有一个小于sqrtn的因子至多存在一个超过sqrtn的因子因此不少算法可以只跑到sqrtn">2.一个数至少有一个小于$\sqrt{n}$的因子，至多存在一个超过$\sqrt{n}$的因子，因此不少算法可以只跑到$\sqrt{n}​$</span></h6><h6><span id="3埃筛">3.埃筛</span></h6><pre><code>(1) 每个数从$x^2​$开始筛即可(2) 用$\sqrt{r}$内的数就可以对$[l, r]$进行区间筛</code></pre><h6><span id="4线筛">4.线筛</span></h6><pre><code>(1) 通过“积累最小质因子”的方法，去除合数</code></pre><h6><span id="5质因数分解">5.质因数分解</span></h6><pre><code>(1) 不少题可以通过算术基本定理找出想法(2) 试除法最后需要特判剩下来个大于$\sqrt{n}$的质数的情况(3) 有时候也可以反过来统计，不考虑它有什么因子，而是考虑“每个因子有多少个”，阶乘快速分解和倍数法基于此思想</code></pre><p>}</p><p>@card{</p><h4><span id="二-同余-取模相关">(二) 同余、取模相关</span></h4><h6><span id="1不少模非质数的题目需要对模数分解成质因子最后用crtexctr合并答案">1.不少模非质数的题目，需要对模数分解成质因子，最后用CRT/EXCTR合并答案</span></h6><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;一-数论&quot;&gt;一、数论&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;一-质数与因子相关&quot;&gt;(一) 质数与因子相关&lt;/span&gt;&lt;/h4&gt;&lt;h6&gt;&lt;span id=&quot;1对于一个足够大的整
      
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
