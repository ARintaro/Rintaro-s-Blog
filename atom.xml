<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2020-01-14T13:40:35.624Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Luogu P3899 谈笑风生</title>
    <link href="http://arintaro.com/2020/01/14/Answer/naive/"/>
    <id>http://arintaro.com/2020/01/14/Answer/naive/</id>
    <published>2020-01-14T13:27:43.111Z</published>
    <updated>2020-01-14T13:40:35.624Z</updated>
    
    <content type="html"><![CDATA[<p>别看今天闹得欢，小心今后拉清单<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵 $n$ 个节点的有根树 $\text T$，节点的编号为 $1$ 到 $n$，根节点为 $1$ 号节点。</p><p>你需要回答 $q$ 个询问，询问给定两个整数$p$ 和 $k$，问有多少个有序三元组 $(a,b,c)$满足：</p><ol><li><p>$a,b,c$ 为 $\text T$ 中三个不同的点，且 $a$ 为 $p$ 号节点；</p></li><li><p>$a$和$b$都是$c$的祖先</p></li><li><p>$a$ 和 $b$ 的距离不超过$k$</p></li></ol><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>一开始没注意到$a,b$其实也在一条链上，想了好久。。</p><h4><span id="算法一在线-主席树">算法一：在线、主席树</span></h4><p>注意到$b$如果在$a$上面可以直接乘法原理算，如果在$a$下面，一个$b$的贡献显然是它的子树大小减一，那么问题即转化为询问一个子树中一个给定深度范围的点权和。</p><p>可以随便跑个<code>dfs</code>序，从而变成二维数点问题，由于不带修改，可以直接用主席树解决。</p><h4><span id="算法二离线-线段树合并">算法二：离线、线段树合并</span></h4><p>注意到我们如果得到了维护这个子树的线段树也可以直接查答案，于是从叶子节点不停合并线段树即可，复杂度分析类似启发式合并，为单$\log$</p><h4><span id="算法三离线-长链剖分">算法三：离线、长链剖分</span></h4><p>注意到这个二维数点有一维的信息是深度，可以拿来当下标，从而可以零代价合并一个儿子，其余儿子暴力合并即可，于是不需要用线段树合并啦，开个树状数组暴力合并轻儿子即可。</p><p>好像直接<code>dsu on tree</code>也可以做，大概要两个$\log$。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法三</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">10</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qk[maxn];</span><br><span class="line">lint ans[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点加区间查</span></span><br><span class="line"><span class="keyword">int</span> deep[maxn], size[maxn], maxd[maxn], wson[maxn], dfa[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], totdfn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfa[x] = fa, size[x] = <span class="number">1</span>, deep[x] = d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x), size[x] += size[y], maxd[x] = max(maxd[x], maxd[y] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(maxd[y] &gt; maxd[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lint c[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n) c[pos] += nval, pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pos) res += c[pos], pos -= lowbit(pos);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> nval)</span> </span>&#123; add(dfn[i] + j, nval); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> ask(dfn[i] + j) - ask(dfn[i] - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn;</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x] || y == wson[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y]; j++) add(x, j + <span class="number">1</span>, ask(y, j) - ask(y, j<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;qid[x].size(); i++) </span><br><span class="line">ans[qid[x][i]] = ask(x, min(qk[qid[x][i]], maxd[x])) + (lint)min(deep[x] - <span class="number">1</span>, qk[qid[x][i]]) * (size[x] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[x] &gt; <span class="number">1</span>) add(x, <span class="number">0</span>, size[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) readint(x), readint(qk[i]), qid[x].push_back(i);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;别看今天闹得欢，小心今后拉清单&lt;br&gt;
    
    </summary>
    
      <category term="POJ" scheme="http://arintaro.com/categories/POJ/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/POJ/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上差分" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    
      <category term="长链剖分" scheme="http://arintaro.com/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="线段树合并" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"/>
    
      <category term="主席树" scheme="http://arintaro.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「POI2014」HOT-Hotels</title>
    <link href="http://arintaro.com/2020/01/14/Answer/hot/"/>
    <id>http://arintaro.com/2020/01/14/Answer/hot/</id>
    <published>2020-01-14T09:03:42.515Z</published>
    <updated>2020-01-14T11:41:41.184Z</updated>
    
    <content type="html"><![CDATA[<p>直觉上复杂度很错的做法其实是线性<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一棵树，计数三个点两两距离相等的数量。</p><p>$1 \leq n \leq 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑如何计算，直接的想法是让每个三元组在一个特定位置被计算一次，即可做到无重无漏，不妨我们令$1$为根。</p><p>易证一定存在一个点到这三个点的距离都相等，不妨设这样的点为这个三元组的中心。</p><h4><span id="算法一每个三元组在中心被统计">算法一：每个三元组在中心被统计</span></h4><p>可以分成两类讨论，第一种是三个点都在中心的子树中；第二种是两个点在中心的子树中，另外一个点不在中心的子树中。</p><p>注意到弱化版的数据范围只有$5000$，所以我们可以扩展一维进行<code>DP</code>以保存距离信息。</p><p>设$f_{i,j}$为$i$子树中距离$i$为$j$的点的个数，$g_{i,j}$就是把$f_{i,j}$组合起来，在子树中距离$i$为$j$的点对的个数。</p><p>类似树上背包即可$O(n^2)$维护上述数组，第一种的贡献用$f$与$g$组合即可。</p><p>问题在于第二种，类似上面的想法，我们需要维护在各个距离下「不在$i$子树中的点距离$i$为$j$」的点数，可以用换根<code>DP</code>实现，设$h_{i,j}$为上述定义的数组，则有<br>$$<br>h_{i, j} = h_{fa_i, j - 1} + f_{fa_i, j - 1} - f_{i, j - 2}<br>$$</p><p>这样再用$h$与$g$组合，即可求出第二类的贡献。</p><p>然而这种方法比较复杂，难以优化，难写难调，并且在<code>Luogu</code>上由于只有128M，直接开数组会<code>MLE</code>掉，需要用<code>vector</code>卡下空间的常数.</p><h4><span id="算法二每个三元组在lca被统计">算法二：每个三元组在LCA被统计</span></h4><p>注意到上一种方法受树的形态影响，那不妨我们重新确认一个点，避免讨论两种情况，上个方法中难以维护的是不在其子树中的点，这次我们让三个点都在其子树中，所以确认这个点为三个点的<code>LCA</code>。</p><p>注意到至少有两个点的<code>LCA</code>在当前点的子树中（或者就是当前点），所以我们对每个点维护这样的点对，还需记录一个信息，即「还需要从这个点找多长的路径，才能组成一个三元组」</p><p>形式化地讲，即定义$g_{i,j}$为这样的点对$x, y$数量，且满足$x, y$在$i$子树中，并且对于$z = \text{LCA}(x, y)$有$d(z, x) = d(z, y) = d(z, i) + j$，其中$d(a, b)$为$a$到$b$点的距离。</p><p>所以我们再记录与算法一相同$f$，即找一个点的方案数，与$g$组合即可。</p><p>这样就得到了一个稍微简单一些的，只需维护子树信息的$O(n^2)$做法，由于第二维以「距离」，即深度为下标合并信息，可以利用长链剖分直接优化到$O(n)$。</p><p>代码实现上需要实现一个内存池，并且前后都要留空，以便递归重儿子时指针偏移，我懒得注意转移顺序了，就多次循环了，实现的不是很精细。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n^2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxu[maxn], dfa[maxn];</span><br><span class="line">pii maxd[maxn][<span class="number">2</span>];</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;lint&gt; f[maxn], g[maxn], h[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x, pii d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(d &gt; maxd[x][<span class="number">0</span>]) maxd[x][<span class="number">1</span>] = maxd[x][<span class="number">0</span>], maxd[x][<span class="number">0</span>] = d;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d &gt; maxd[x][<span class="number">1</span>]) maxd[x][<span class="number">1</span>] = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i])</span><br><span class="line"><span class="keyword">if</span>(y != fa) dfs1(y, d + <span class="number">1</span>, x), push(x, mp(maxd[y][<span class="number">0</span>].first + <span class="number">1</span>, y));</span><br><span class="line">f[x].resize(maxd[x][<span class="number">0</span>].first + <span class="number">5</span>), g[x].resize(maxd[x][<span class="number">0</span>].first + <span class="number">5</span>);</span><br><span class="line">f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 先计算选三个的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y][<span class="number">0</span>].first; j++) ans += g[x][j + <span class="number">1</span>] * f[y][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y][<span class="number">0</span>].first; j++) g[x][j + <span class="number">1</span>] += f[x][j + <span class="number">1</span>] * f[y][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y][<span class="number">0</span>].first; j++) f[x][j + <span class="number">1</span>] += f[y][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x != <span class="number">1</span>) </span><br><span class="line">maxu[x] = max(maxu[dfa[x]],</span><br><span class="line">  maxd[dfa[x]][<span class="number">0</span>].second != x ? maxd[dfa[x]][<span class="number">0</span>].first : maxd[dfa[x]][<span class="number">1</span>].first) + <span class="number">1</span>;</span><br><span class="line">h[x].resize(max(maxu[dfa[x]], maxd[dfa[x]][<span class="number">0</span>].first) + <span class="number">5</span>);</span><br><span class="line">h[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> maxi = max(maxu[dfa[x]], maxd[dfa[x]][<span class="number">0</span>].first);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=maxi; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; h[dfa[x]].size()) h[x][i+<span class="number">1</span>] += h[dfa[x]][i];</span><br><span class="line"><span class="keyword">if</span>(i &lt; f[dfa[x]].size()) h[x][i+<span class="number">1</span>] += f[dfa[x]][i];</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>) h[x][i + <span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i - <span class="number">1</span> &lt; f[x].size()) h[x][i + <span class="number">1</span>] -= f[x][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) <span class="keyword">if</span>(y != dfa[x]) dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, maxj=min((<span class="keyword">int</span>)min(g[x].size(), h[x].size()) - <span class="number">1</span>, min(maxd[x][<span class="number">0</span>].first, maxu[x])); j&lt;=maxj; j++) &#123;</span><br><span class="line">ans += (lint)g[x][j] * h[x][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lint ans = <span class="number">0</span>, *f[maxn], *g[maxn], mem[<span class="number">12</span> * maxn], mr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint* <span class="title">mnew</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = mr + len; mr += len &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> mem + pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> deep[maxn], wson[maxn], maxd[maxn];</span><br><span class="line"><span class="keyword">int</span> dfa[maxn], dfl[maxn], dfr[maxn], totdfn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">deep[x] = d, dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x), maxd[x] = max(maxd[x], maxd[y] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(maxd[y] &gt;= maxd[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x] == <span class="number">0</span>) f[x] = mnew(maxd[x] + <span class="number">3</span>), g[x] = mnew(maxd[x] + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(wson[x]) f[wson[x]] = f[x] + <span class="number">1</span>, g[wson[x]] = g[x] - <span class="number">1</span>, dfs2(wson[x]);</span><br><span class="line">f[x][<span class="number">0</span>] = <span class="number">1</span>, ans += g[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x] || y == wson[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y]; j++) </span><br><span class="line">ans += g[x][j + <span class="number">1</span>] * f[y][j] + (j ? f[x][j - <span class="number">1</span>] * g[y][j] : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y]; j++) g[x][j+<span class="number">1</span>] += f[x][j+<span class="number">1</span>] * f[y][j], g[x][j<span class="number">-1</span>] += g[y][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=maxd[y]; j++) f[x][j+<span class="number">1</span>] += f[y][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直觉上复杂度很错的做法其实是线性&lt;br&gt;
    
    </summary>
    
      <category term="POI" scheme="http://arintaro.com/categories/POI/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/POI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
      <category term="计数问题" scheme="http://arintaro.com/tags/%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    
      <category term="长链剖分" scheme="http://arintaro.com/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="树形问题" scheme="http://arintaro.com/tags/%E6%A0%91%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>长链剖分</title>
    <link href="http://arintaro.com/2020/01/14/Template/%E5%9B%BE%E8%AE%BA/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://arintaro.com/2020/01/14/Template/图论/树上问题/长链剖分/</id>
    <published>2020-01-14T05:44:46.768Z</published>
    <updated>2020-01-14T05:58:13.437Z</updated>
    
    <content type="html"><![CDATA[<p>懒得写了<br><a id="more"></a></p><h2><span id="一-概述">一、概述</span></h2><p>@card{</p><p><a href="https://blog.bill.moe/long-chain-subdivision-notes/" target="_blank" rel="noopener">https://blog.bill.moe/long-chain-subdivision-notes/</a></p><p><a href="https://www.cnblogs.com/zzqsblog/p/6700133.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzqsblog/p/6700133.html</a></p><p><a href="https://www.cnblogs.com/cjyyb/p/9479258.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/9479258.html</a></p><p>感觉$O(1)$求$k$级祖先并没有什么实用价值，跟$O(1)$求<code>LCA</code>一样没人写..</p><p>快速深度下标合并的复杂度就是每个长链链头会被暴力统计这个长链长的数量，所以每个长链的贡献就是它的长度，加起来就是$O(n)$了。</p><p>}</p><h2><span id="二-代码">二、代码</span></h2><p>@card{<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, st, ed;</span><br><span class="line"><span class="keyword">int</span> cur[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], ec[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge_one</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw, <span class="keyword">int</span> nc)</span> </span>&#123; <span class="comment">// 注意这里分清nw, nc</span></span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, ec[totedge] = nc;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge_two</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw, <span class="keyword">int</span> nc)</span> </span>&#123; <span class="comment">// 别忘了加反边</span></span><br><span class="line">addedge_one(nu, nv, nw, nc), addedge_one(nv, nu, <span class="number">0</span>, -nc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一维距离，第二维编号</span></span><br><span class="line">priority_queue&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;pii&gt; &gt; q;</span><br><span class="line">lint h[maxn], dist[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">dist[st] = <span class="number">0</span>, q.push(mp(<span class="number">0</span>, st));</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">pii now = q.top(); q.pop();</span><br><span class="line"><span class="keyword">int</span> x = now.second;</span><br><span class="line"><span class="keyword">if</span>(now.first &gt; dist[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ew[i] &amp;&amp; dist[y] &gt; dist[x] + ec[i] + h[x] - h[y]) &#123; <span class="comment">// 这里记得判此边是否还有容量</span></span><br><span class="line">dist[y] = dist[x] + ec[i] + h[x] - h[y];</span><br><span class="line">q.push(mp(dist[y], y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[ed] &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxflow = <span class="number">0</span>, mincost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == ed || rest == <span class="number">0</span>) <span class="keyword">return</span> rest;</span><br><span class="line">vis[x] = <span class="number">1</span>; <span class="comment">// 一般的正权图跑最短路生成DAG时不用这样，但此题中可能有"零环"</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint &amp;i = cur[x], y=ev[i]; i &amp;&amp; rest; i=nxt[i], y=ev[i]) &#123; <span class="comment">// 当前弧优化, &amp;&amp;rest 及时退出</span></span><br><span class="line"><span class="keyword">if</span>(ew[i] == <span class="number">0</span> || vis[y] || dist[y] != dist[x] + ec[i] + h[x] - h[y]) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">// 记得判边是否还有容量，以及为了避免无限递归零环而打的入栈标记。</span></span><br><span class="line">        <span class="comment">// 最短路生成DAG</span></span><br><span class="line"><span class="keyword">int</span> now = dinic(y, min(ew[i], rest));</span><br><span class="line">flow += now, rest -= now;</span><br><span class="line">ew[i] -= now, ew[i ^ <span class="number">1</span>] += now; <span class="comment">// 实时更新剩余容量</span></span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="number">0</span>; <span class="comment">// 回溯时还原标记，一个点可能会被多次访问</span></span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(st), readint(ed);</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw, nc;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw), readint(nc);</span><br><span class="line">addedge_two(nu, nv, nw, nc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(dijkstra()) &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(cur)); <span class="comment">// 当前弧优化</span></span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; <span class="comment">// 一次多路增光，降低常数</span></span><br><span class="line"><span class="keyword">while</span>((flow = dinic(st, INT_MAX))) maxflow += flow, mincost += flow * (dist[ed] - h[st] + h[ed]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++)  h[i] += dist[i]; <span class="comment">// 更新势能函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, maxflow, mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;懒得写了&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>UOJ284 快乐游戏鸡</title>
    <link href="http://arintaro.com/2020/01/14/Answer/chick/"/>
    <id>http://arintaro.com/2020/01/14/Answer/chick/</id>
    <published>2020-01-14T05:31:18.445Z</published>
    <updated>2020-01-14T05:37:31.931Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>快乐游戏鸡玩过的游戏是这样的：给定一棵 $n$ 个结点的树，其中 $1$ 号结点是根。每次玩家可以在树上行走，走过一条边需要 $1$ 秒的时间，但只能往当前所在的点的某个儿子走，不能往父亲走。每次游戏需要从 $s$ 号结点走到 $t$ 号结点去。</p><p>玩家有一个总死亡次数，初始为 $0$。每个结点上有一个程序猿和一个参数 $w_i$，如果走到结点 $i$ 的时候，当前总的死亡次数小于 $w_i$，那么玩家就会立刻死亡并回到起点 $s$，且该死亡过程不需要时间；如果总死亡次数大于等于 $w_i$，那么玩家就能熟练地对付程序猿从而安然无恙。注意每次游戏时不需要考虑 $s$ 和 $t$ 上的程序猿。</p><p>要求做到单$log$级别，询问与$n$同级。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>首先发现最优方案肯定是先找个地方练级，一直练到$s$与$t$之间的最大值，再直接走过去，这样就与$t$无关了，我们的问题即转化成从$s$出发至少多长时间能死到一定的次数。</p><p>再发现每次只要找个深度最浅的练级的地方练肯定是最优的，那么可能的决策就形成了一个深度单调递增，同时$w_i$也单调递增的数列，每次二分即可，好像这样就有$70pts$了。</p><p>问题在于怎么把这个过程放到树上，由于我第一次写这题时还不会长链剖分，于是直接用了重链剖分+平衡树维护单调栈，做到了两个$\log$。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mlog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> t = x;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)((lint&amp;)t &gt;&gt; <span class="number">52</span> &amp; <span class="number">63</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bst&#123;</span><br><span class="line"><span class="keyword">int</span> lson[maxn], rson[maxn];</span><br><span class="line"><span class="keyword">int</span> dep[maxn], val[maxn], det[maxn], size[maxn], rnd[maxn];</span><br><span class="line">lint sum_det[maxn], sum_mul[maxn];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">print(lson[p]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, p), print(rson[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; print(root), <span class="built_in">puts</span>(<span class="string">""</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; root = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">sum_det[p] = sum_det[lson[p]] + sum_det[rson[p]] + det[p];</span><br><span class="line">sum_mul[p] = sum_mul[lson[p]] + sum_mul[rson[p]] + (lint)dep[p] * det[p];</span><br><span class="line">size[p] = size[lson[p]] + size[rson[p]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; size[p] = <span class="number">1</span>, lson[p] = rson[p] = <span class="number">0</span>, rnd[p] = rand(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; size[lson[p]]) a = p, split_rank(rson[p], rson[a], b, k - size[lson[p]] - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> b = p, split_rank(lson[p], a, lson[b], k);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_val</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(nval &gt;= val[p]) a = p, split_val(rson[p], rson[a], b, nval);</span><br><span class="line"><span class="keyword">else</span> b = p, split_val(lson[p], a, lson[b], nval);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_dep</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span> ndep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; a = b = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(ndep &gt;= dep[p]) a = p, split_dep(rson[p], rson[a], b, ndep);</span><br><span class="line"><span class="keyword">else</span> b = p, split_dep(lson[p], a, lson[b], ndep);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>) &#123; p = a + b; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(rnd[a] &gt;= rnd[b]) p = a, merge(rson[p], rson[a], b);</span><br><span class="line"><span class="keyword">else</span> p = b, merge(lson[p], a, lson[b]);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlas</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> rson[p] ? getlas(rson[p]) : p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lt, mid, rt;</span><br><span class="line">split_dep(root, lt, rt, dep[p]);</span><br><span class="line"><span class="keyword">int</span> t = getlas(lt);</span><br><span class="line"><span class="keyword">if</span>(val[t] &gt;= val[p]) &#123; merge(root, lt, rt); <span class="keyword">return</span>; &#125;</span><br><span class="line">newnode(p), det[p] = val[p] - val[t], pushup(p);</span><br><span class="line">split_val(rt, mid, rt, val[p]), split_rank(rt, mid, rt, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(mid) det[mid] = val[mid] - val[p], pushup(mid);</span><br><span class="line">merge(lt, lt, p), merge(lt, lt, mid), merge(root, lt, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> aim, <span class="keyword">int</span> ndep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lt, mid, rt;</span><br><span class="line">split_val(root, lt, rt, aim - <span class="number">1</span>), split_rank(rt, mid, rt, <span class="number">1</span>);</span><br><span class="line">lint res = sum_mul[lt] - ndep * sum_det[lt] + (lint)(dep[mid] - ndep) * (aim + det[mid] - val[mid]);</span><br><span class="line">merge(lt, lt, mid), merge(root, lt, rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfa[maxn][maxd], deep[maxn], size[maxn], wson[maxn];</span><br><span class="line"><span class="keyword">int</span> maxval[maxn][maxd];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, deep[x] = d, bst::dep[x] = d;</span><br><span class="line">dfa[x][<span class="number">0</span>] = fa, maxval[x][<span class="number">0</span>] = arr[fa];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;t)&lt;=d; t++) </span><br><span class="line">dfa[x][t] = dfa[dfa[x][t<span class="number">-1</span>]][t<span class="number">-1</span>], maxval[x][t] = max(maxval[x][t<span class="number">-1</span>], maxval[dfa[x][t<span class="number">-1</span>]][t<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x), size[x] += size[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">bst::insert(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) dfs2(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qx[maxn], qy[maxn], qaim[maxn];</span><br><span class="line">lint ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> anc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=mlog2(deep[x] - deep[anc]); t&gt;=<span class="number">0</span>; t--) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[dfa[x][t]] &gt; deep[anc]) res = max(res, maxval[x][t]), x = dfa[x][t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qid[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) <span class="keyword">if</span>(y != wson[x]) dfs3(y, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs3(wson[x], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(!qid[x].size() &amp;&amp; flag) &#123; bst::clear(); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) <span class="keyword">if</span>(y != wson[x]) dfs2(y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;qid[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> now = qid[x][i];</span><br><span class="line">ans[now] = bst::ask(qaim[now], deep[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) bst::insert(x);</span><br><span class="line"><span class="keyword">else</span> bst::clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]), bst::val[i] = arr[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) readint(x), addedge(x, i);</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(qx[i]), readint(qy[i]);</span><br><span class="line">qaim[i] = ask(qy[i], qx[i]);</span><br><span class="line">qid[qx[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">dfs3(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i] + deep[qy[i]] - deep[qx[i]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;快乐游戏鸡玩过的游戏是这样的：给定一棵 $n$ 个结点的树，其中 $1$ 号结点是根。每次玩家可以在树上行走
      
    
    </summary>
    
      <category term="UOJ" scheme="http://arintaro.com/categories/UOJ/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/UOJ/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调栈" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="平衡树" scheme="http://arintaro.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="树上启发式合并" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="长链剖分" scheme="http://arintaro.com/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF741D Arpa</title>
    <link href="http://arintaro.com/2020/01/13/Answer/arpa/"/>
    <id>http://arintaro.com/2020/01/13/Answer/arpa/</id>
    <published>2020-01-13T10:45:48.889Z</published>
    <updated>2020-01-13T11:12:12.032Z</updated>
    
    <content type="html"><![CDATA[<p>为什么标签里有点分治？<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵树，每条边上有一个字符，求每个子树中的最长的一条路径，满足路径上所有字符任意排序后可以组成一个回文串。</p><p>$1 \leq n \leq 5 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这个题看着有点像点分治，但是没法做，因为这个树是定根的，点分治后改变了树的结构，是没法快速判断路径究竟在原来哪个子树中的。</p><p>首先注意到可以类似点分治，把问题转化成过每个点的在其子树中的最长路径，最后每个点对其子树中的点取个$\max$即可。</p><p>再注意到字符集其实很小，一般随便设的话应该会到z，但是本题只有$22$，这个范围是一个「很状压的范围」，所以需要重新注意「能组成回文串」这个条件究竟能转化成什么条件，发现其实就是至多只能有一个奇数出现次数的字母，所以一个路径上字母出现次数就能用$01$串进行状压，取并直接异或就好。</p><p>先考虑如何只对一个节点查询，发现异或后可以被统计的结果其实很有限，就是$0$和各位上只有一个$1$，所以可以直接枚举这个结果，然后异或上现在的状态，得到之前的状态，这样之前的状态就可以开个桶维护了。</p><p>还有一个问题，在多点查询时，如何维护路径长度和「子树中节点到当前节点的状态」，不然回溯时我们要进行在桶中进行大规模改动，完全无法接受，发现只要记录深度和根到当前节点的状态即可，深度可减，两个到根节点的状态异或一下其实到它们LCA的状态。</p><p>至此我得到了这样一个算法，每次先查询一次子树，再把子树的贡献加入桶中，回溯时撤销影响，显然可以用树上启发式合并优化。</p><p>同时需要注意几个细节，这样的点对我们可以给它固定一个顺序，即一个点对只要一个在桶中，一个是当前遍历到的即可，由于在启发式合并时，重子树是不能遍历两次的，而轻子树可以遍历多次，所以我们始终让重子树在桶中，让轻子树进行查询，最后别忘了重子树与根节点间形成的点对。</p><p>由于我比较ruozhi，第一次写的时候忘了这个最大值撤销影响是推平型，即撤销完全局数组是空的，以为需要有可减性，结果开了很多个multiset维护..</p><p>又看了题解dalao的写法，发现可以直接统计一个dfs序，后面没有pushup的dfs完全可以不用写..</p><p>代码懒得改了，是我ruozhi的带$22$倍常数的两个$\log$写法，幸好CF神机跑过去了。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mit multiset<span class="meta-string">&lt;int&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>) + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// deep[x] + deep[y] - 2 * deep[nlca]</span></span><br><span class="line"><span class="comment">// 特判lca</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], ew[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[maxn], deep[maxn], dfa[maxn], val[maxn];</span><br><span class="line"><span class="keyword">int</span> wson[maxn], ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, deep[x] = d, dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">val[y] = val[x] ^ (<span class="number">1</span> &lt;&lt; ew[i]);</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x), size[x] += size[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s[maxnode];</span><br><span class="line"><span class="comment">// val[x] ^ val[y] == (1 &lt;&lt; i)  =&gt; ans = max(deep[x] + deep[y]) - 2 * deep[x]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) s[val[x]].insert(deep[x]);</span><br><span class="line"><span class="keyword">else</span> s[val[x]].erase(s[val[x]].find(deep[x]));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y != dfa[x]) dfs2(y, f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>; i&lt;<span class="number">22</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = (i == <span class="number">-1</span> ? <span class="number">0</span> : (<span class="number">1</span> &lt;&lt; i)) ^ val[x];</span><br><span class="line"><span class="keyword">if</span>(s[t].size()) ans[rt] = max(ans[rt], deep[x] + *s[t].rbegin() - <span class="number">2</span> * deep[rt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y != dfa[x]) dfs3(y, rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) </span><br><span class="line"><span class="keyword">if</span>(y != dfa[x] &amp;&amp; y != wson[x]) dfs4(y, <span class="number">1</span>), ans[x] = max(ans[x], ans[y]);</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs4(wson[x], <span class="number">0</span>), ans[x] = max(ans[x], ans[wson[x]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1</span>; i&lt;<span class="number">22</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = (i == <span class="number">-1</span> ? <span class="number">0</span> : (<span class="number">1</span> &lt;&lt; i)) ^ val[x];</span><br><span class="line"><span class="keyword">if</span>(s[t].size()) ans[x] = max(ans[x], *s[t].rbegin() - deep[x]);</span><br><span class="line">&#125;</span><br><span class="line">s[val[x]].insert(deep[x]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) </span><br><span class="line"><span class="keyword">if</span>(y != dfa[x] &amp;&amp; y != wson[x]) dfs3(y, x), dfs2(y, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(flag) dfs2(x, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(x), readstr(str);</span><br><span class="line">addedge(x, i, str[<span class="number">0</span>] - <span class="string">'a'</span>), addedge(i, x, str[<span class="number">0</span>] - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), dfs4(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么标签里有点分治？&lt;br&gt;
    
    </summary>
    
      <category term="Codeforces" scheme="http://arintaro.com/categories/Codeforces/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="点分治" scheme="http://arintaro.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="树上启发式合并" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="可减性" scheme="http://arintaro.com/tags/%E5%8F%AF%E5%87%8F%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>CF600E Lomsat gelral</title>
    <link href="http://arintaro.com/2020/01/13/Answer/lomsat/"/>
    <id>http://arintaro.com/2020/01/13/Answer/lomsat/</id>
    <published>2020-01-13T09:24:05.574Z</published>
    <updated>2020-01-13T09:40:21.450Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵树，点带颜色，要求求出每个子树中的数量最多的颜色的编号和（数量最多的颜色可能有多个）。</p><p>$1 \leq n \leq 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>树上启发式合并模版，我们在计算一些树上信息时，常常要维护一些全局数组与变量，而一个问题的答案需要在这些全局数组中计算了一些点的贡献时才能被正确计算。</p><p>具体来说，这个问题中一个点的答案需要计算它子树中所有节点才能开始计算，我刚学OI时认为可以直接保留一个子树的贡献，从而避免多次统计，但是如果一个点有多个子树时，假设我们先计算了第一个子树，并在全局数组中保留了它的贡献，那么我们在计算第二个子树时，第一个子树的贡献就会影响到它答案的计算。</p><p>所以我们必须要再回溯时撤销贡献，才能正确计算答案，但是我们撤销了所有子树的答案，要计算当前节点的答案时，就必须在遍历一次所有子树去计算答案，这样做的时间复杂度显然是$O(n^2)$的。</p><p>但是仔细想想，我们其实可以保留一个子树的答案，就是最后一个计算的子树，它显然不会影响其他子树的答案，我们令这个子树为其最大的子树，就能降到$O(n\log{n})$了。</p><p>具体实现分为统计贡献和计算答案两个dfs过程。</p><p>在计算答案过程中，我们先去计算非重子树的答案，回溯时撤销对全局变量的影响，再去计算重子树的答案，回溯时不撤销影响，最后重新统计非重子树。</p><p>此时加上当前节点即统计了它子树中所有节点。</p><p>树上启发式合并要求问题可以离线，并且可以快速撤销影响，不然要多个维护数据的$\log$复杂度。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> cntc[maxn], maxpos = <span class="number">0</span>;</span><br><span class="line">lint sumv[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">sumv[cntc[c]] -= c, sumv[cntc[c] += f] += c;</span><br><span class="line">maxpos = max(maxpos, cntc[c]);</span><br><span class="line"><span class="keyword">if</span>(sumv[maxpos] == <span class="number">0</span>) maxpos--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[maxn], wson[maxn], dfa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>, dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x), size[x] += size[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">update(arr[x], f);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i])</span><br><span class="line"><span class="keyword">if</span>(y != dfa[x]) dfs2(y, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x] || y == wson[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs3(y, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs3(wson[x], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x] || y == wson[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">update(arr[x], <span class="number">1</span>), ans[x] = sumv[maxpos];</span><br><span class="line"><span class="keyword">if</span>(flag) dfs2(x, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs3(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一棵树，点带颜色，要求求出每个子树中的数量最多的颜色的编号和（数量最多的颜色可能有多个）。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Codeforces" scheme="http://arintaro.com/categories/Codeforces/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="树上启发式合并" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    
      <category term="众数" scheme="http://arintaro.com/tags/%E4%BC%97%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4299 首都</title>
    <link href="http://arintaro.com/2020/01/13/Answer/capital/"/>
    <id>http://arintaro.com/2020/01/13/Answer/capital/</id>
    <published>2020-01-13T02:44:49.569Z</published>
    <updated>2020-01-13T02:57:53.475Z</updated>
    
    <content type="html"><![CDATA[<p>祭奠我的D2T3<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个森林，要求支持link，保证link完还是一个树，和查询某棵树的重心。</p><p>$1 \leq 10^5 \leq n$， $1 \leq m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这里写一下重心的几个性质：</p><ol><li>对于一棵树，重心只可能有两个或一个，有两个的话一定相邻。</li><li>去掉重心树上剩下的连通块大小都不超过$\dfrac{n}{2}$，且最大的连通块大小最小</li><li>两棵树link起来，新的重心在两个旧重心的路径上</li><li>一棵树link一个点，新的重心至多移动一条边，如果移动的话肯定只朝着这个link点移动。</li><li>要求所有点到一个点的距离之和最小，这个点是重心，用调整法易证。</li></ol><p>那么根据性质4，我们可以直接启发式合并，把小的树中的点一个个link到大的上去，但是好像很难写的样子？并且还是两个$\log$。</p><p>考虑怎么直接link一棵树，根据性质3，我们可以直接考虑如何在两个旧重心的路径上找新重心，发现对于新重心来说，可能影响「剩下的连通块大小都不超过$\dfrac{n}{2}$」这个条件的的子树，只有它作根时，两个旧重心所在的子树，因为其他子树在link之前必然属于之前的一棵树，它肯定不超过旧树大小的一半，那么新树大小更大了，它更不可能超过一半了。</p><p>所以问题就转化为，我们要在这条链上找个位置，给这个树分成两半，使得左右两边大小都不超过一半，这个显然可以二分，大概像求kth一样，LCT可以很方便地拉出这条链的splay，从而我们可以直接在splay上进行二分过程，从而做到单$\log$。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> db = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], size[maxn], val[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, size[i] = <span class="number">1</span>, val[i] = i; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> val[find(x)]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">x = find(x), y = find(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">fa[x] = y, size[y] += size[x], val[y] = nval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;uset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nowans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isrt(x) (ch[fa[x]][0] != (x) &amp;&amp; ch[fa[x]][1] != (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (ch[fa[x]][1] == (x))</span></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], fa[maxn], size[maxn], fsize[maxn];</span><br><span class="line"><span class="keyword">bool</span> inv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; size[p] = size[ch[p][<span class="number">0</span>]] + size[ch[p][<span class="number">1</span>]] + <span class="number">1</span> + fsize[p]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; swap(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]); inv[p] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(inv[p]) rev(ch[p][<span class="number">0</span>]), rev(ch[p][<span class="number">1</span>]), inv[p] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(!isrt(p)) down(fa[p]); pushdown(p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y;</span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = fa[x]) &#123;</span><br><span class="line">splay(x), fsize[x] = fsize[x] + size[ch[x][<span class="number">1</span>]] - size[y];</span><br><span class="line">ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rev(access(x)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, pos = maxn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">pushdown(x);</span><br><span class="line"><span class="keyword">if</span>(now + size[ch[x][<span class="number">0</span>]] &lt;= tot / <span class="number">2</span> &amp;&amp; tot - now - size[ch[x][<span class="number">0</span>]] - fsize[x] - <span class="number">1</span> &lt;= tot / <span class="number">2</span>)</span><br><span class="line">pos = min(pos, x);</span><br><span class="line"><span class="keyword">if</span>(now + size[ch[x][<span class="number">0</span>]] + fsize[x] + <span class="number">1</span> &lt;= tot / <span class="number">2</span>) getpos(ch[x][<span class="number">1</span>], now + size[ch[x][<span class="number">0</span>]] + fsize[x] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> getpos(ch[x][<span class="number">0</span>], now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rx = uset.ask(x), ry = uset.ask(y);</span><br><span class="line"><span class="keyword">if</span>(rx == ry) <span class="keyword">return</span>;</span><br><span class="line">nowans ^= rx ^ ry;</span><br><span class="line"></span><br><span class="line">makeroot(x), splay(x), makeroot(y), splay(y);</span><br><span class="line">fa[x] = y, fsize[y] += size[x], pushup(y);</span><br><span class="line"></span><br><span class="line">tot = size[y], pos = maxn;</span><br><span class="line">makeroot(rx), getpos(access(ry), <span class="number">0</span>);</span><br><span class="line">uset.unio(x, y, pos);</span><br><span class="line">nowans ^= pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ins[<span class="number">10</span>];</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) nowans ^= i, size[i] = <span class="number">1</span>;</span><br><span class="line">uset.init(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readstr(ins);</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'X'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nowans);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'Q'</span>) readint(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, uset.ask(x));</span><br><span class="line"><span class="keyword">else</span> readint(x), readint(y), link(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;祭奠我的D2T3&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="树的重心" scheme="http://arintaro.com/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
      <category term="树链二分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「BJOI2014」大融合</title>
    <link href="http://arintaro.com/2020/01/12/Answer/maga/"/>
    <id>http://arintaro.com/2020/01/12/Answer/maga/</id>
    <published>2020-01-12T13:15:26.531Z</published>
    <updated>2020-01-12T13:20:55.341Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一个动态树，动态加边，询问子树大小。</p><p>$1 \leq n \leq 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于LCT而言，由于其「认父不认子」的结构，维护子树信息是比较困难的，但是在信息有可减性的情况下（没有的时候可能要多花个log维护一个数据结构），我们可以只在切换虚实边时计算贡献，对每个节点维护一个虚儿子的贡献。</p><p>具体来说，splay和rotate的过程都不会切换虚实边，无需改变。access时，要把原来实儿子的贡献加到虚贡献上，再减去原来虚儿子的贡献，才能把切换虚实边。</p><p>由于进行了这种操作，我们在某个节点修改信息时，信息必须pushup到整个lct的根节点，而不是之前的它splay的根节点，于是我们要么每次暴力pushup，要么修改前$x, y$都需要makeroot一下。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], fa[maxn], size[maxn], fsize[maxn];</span><br><span class="line"><span class="keyword">bool</span> inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isrt(x) (ch[fa[x]][0] != (x) &amp;&amp; ch[fa[x]][1] != (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (ch[fa[x]][1] == (x))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; size[p] = size[ch[p][<span class="number">0</span>]] + size[ch[p][<span class="number">1</span>]] + <span class="number">1</span> + fsize[p];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; swap(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]), inv[p] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(inv[p]) rev(ch[p][<span class="number">0</span>]), rev(ch[p][<span class="number">1</span>]), inv[p] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(!isrt(p)) down(fa[p]); pushdown(p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y;</span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变边的虚实时需要更新</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = fa[x]) &#123; <span class="comment">// 别忘了加上变成虚边的ch[x][1]</span></span><br><span class="line">splay(x), fsize[x] = fsize[x] + size[ch[x][<span class="number">1</span>]] - size[y], ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rev(access(x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x), splay(x), makeroot(y), splay(y);</span><br><span class="line">fa[x] = y, fsize[y] += size[x], pushup(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x), access(y), splay(x);</span><br><span class="line"><span class="keyword">return</span> (lint)(size[x] - size[y]) * size[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) size[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ins[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readstr(ins), readint(x), readint(y);</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'A'</span>) link(x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ask(x, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给一个动态树，动态加边，询问子树大小。&lt;/p&gt;
&lt;p&gt;$1 \leq n \leq 10^5$&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="NOI" scheme="http://arintaro.com/categories/NOI/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="可减性" scheme="http://arintaro.com/tags/%E5%8F%AF%E5%87%8F%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「NOI2014」魔法森林</title>
    <link href="http://arintaro.com/2020/01/12/Answer/forest/"/>
    <id>http://arintaro.com/2020/01/12/Answer/forest/</id>
    <published>2020-01-12T12:23:02.270Z</published>
    <updated>2020-01-12T12:36:15.477Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个图，边带两种权值$a_i$，$b_i$，要求找一条$1$到$n$路径使得$max{a_i} + max{b_i}$最小。</p><p>$1 \leq n \leq 5 \times 10^4$, $1 \leq m \leq 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>直接做显然没法做，这样扩展性的二维问题通常是排序后枚举一维，另一维用一些乱七八糟的数据结构保证。</p><p>具体到这个问题上，就是枚举$max{a_i}$，再令$max{b_i}$最小，直接的想法是跑个最短路，不过这个做法没什么扩展性，我们是没法动态维护最短路的，但是此题的边权并不是求和，而是取$\max$，所以我们可以联想到货车运输，跑最小生成树。但是这样就出现了一个问题，我们枚举的$max{a_i}$很可能不在$1$到$n$的路径上，然而实际上这并不是问题，这样答案只可能变小，变得更优。</p><p>所以我们得到这样一个算法，先按$a_i$排序，然后枚举一个$i$，代表我们用排序后编号在$[1, i]$的边中组成在$b_i$意义下的最小生成树，再在LCT上查$max{a_i} + max{b_i}$从而更新答案。</p><p>但是翻了一下题解，其实不需要在LCT上维护$max{a_i}$，而可以直接用$a_i$，这样更新可能会在某个$i$处错误更新答案，导致这次计算出的结果偏大，但是最优解一定会被取到，直接考虑贪心过程似乎不太显然，但是考虑一下最优方案的组成，其显然会有个$a_i$最大的边，同时我们又维护了$b_i$的最优性，所以最优解肯定会被取到。</p><p>代码我懒得改了，我没有考虑太多，直接在LCT上维护了两个权值。。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn + maxm;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w1, w2;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w1 &lt; b.w1; &#125;</span><br><span class="line">&#125;mem[maxm];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? fa[x] : fa[x] = find(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> find(x) == find(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = find(x), y = find(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">fa[x] = y, size[y] += size[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;uset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[maxnode][<span class="number">2</span>], fa[maxnode], val1[maxnode], val2[maxnode];</span><br><span class="line"><span class="keyword">bool</span> inv[maxnode];</span><br><span class="line">pii nmax1[maxnode], nmax2[maxnode];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isrt(x) (ch[fa[x]][0] != (x) &amp;&amp; ch[fa[x]][1] != (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (ch[fa[x]][1] == (x))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">nmax1[p] = max(mp(val1[p], p), max(nmax1[ch[p][<span class="number">0</span>]], nmax1[ch[p][<span class="number">1</span>]]));</span><br><span class="line">nmax2[p] = max(mp(val2[p], p), max(nmax2[ch[p][<span class="number">0</span>]], nmax2[ch[p][<span class="number">1</span>]]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; swap(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]), inv[p] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(inv[p]) rev(ch[p][<span class="number">0</span>]), rev(ch[p][<span class="number">1</span>]), inv[p] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(!isrt(p)) down(fa[p]); pushdown(p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y;</span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == x ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = fa[x]) &#123;</span><br><span class="line">splay(x), ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rev(access(x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x), splay(x), fa[x] = y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x), access(y), splay(x);</span><br><span class="line">ch[x][<span class="number">1</span>] = fa[y] = <span class="number">0</span>, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; link(mem[i].u, i + n), link(i + n, mem[i].v); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deledge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; cut(mem[i].u, i + n), cut(i + n, mem[i].v); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; makeroot(x); <span class="keyword">return</span> access(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) val1[i] = val2[i] = -inf, nmax1[i] = nmax2[i] = mp(-inf, i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(mem[i].u), readint(mem[i].v), readint(mem[i].w1), readint(mem[i].w2);</span><br><span class="line">&#125;</span><br><span class="line">uset.init();</span><br><span class="line">sort(mem+<span class="number">1</span>, mem+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">val1[i + n] = mem[i].w1, nmax1[i + n] = mp(val1[i + n], i + n);</span><br><span class="line">val2[i + n] = mem[i].w2, nmax2[i + n] = mp(val2[i + n], i + n);</span><br><span class="line"><span class="keyword">if</span>(mem[i].u == mem[i].v) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(uset.find(mem[i].u, mem[i].v)) &#123;</span><br><span class="line">pii res = nmax2[ask(mem[i].u, mem[i].v)];</span><br><span class="line"><span class="keyword">if</span>(res.first &gt; mem[i].w2) deledge(res.second - n), addedge(i);</span><br><span class="line">&#125; <span class="keyword">else</span> addedge(i), uset.unio(mem[i].u, mem[i].v);</span><br><span class="line"><span class="keyword">if</span>(uset.find(<span class="number">1</span>, n)) &#123;</span><br><span class="line"><span class="keyword">int</span> p = ask(<span class="number">1</span>, n);</span><br><span class="line">ans = min(ans, nmax1[p].first + nmax2[p].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans == inf) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个图，边带两种权值$a_i$，$b_i$，要求找一条$1$到$n$路径使得$max{a_i} + ma
      
    
    </summary>
    
      <category term="NOI" scheme="http://arintaro.com/categories/NOI/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOI/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="最小生成树" scheme="http://arintaro.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="二维问题" scheme="http://arintaro.com/tags/%E4%BA%8C%E7%BB%B4%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4234 最小差值生成树</title>
    <link href="http://arintaro.com/2020/01/12/Answer/mind/"/>
    <id>http://arintaro.com/2020/01/12/Answer/mind/</id>
    <published>2020-01-12T08:23:32.466Z</published>
    <updated>2020-01-12T08:32:48.309Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个图，带边权，求一个生成树，使得最大边权与最小边权的差值最小。</p><p>$1 \leq n \leq 5 \times 10^4$, $1 \leq m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>类似Krucal的过程，边排序后，枚举当前选中的最大边权，那么如果两点已连通，删掉其中的最小边权肯定对当前和后续问题更优，没连通连上即可。</p><p>维护连通可以用并查集，不用在LCT上跑，因为两点一旦连通，后续可能换个路径联通，但绝不会变回不联通的状态，相当于只有link没有cut。</p><p>需要动态维护这个生成树，但是LCT不支持维护边权，所以把边转化成点即可，把原来的点和0的点权都设为inf，方便程序实现。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; b.w; &#125;</span><br><span class="line">&#125;arr[maxn];</span><br><span class="line"><span class="comment">// 支持删边，加边，查询路径点权最小位置</span></span><br><span class="line"><span class="comment">// 对每条边建点 i + n，非边点权设为inf</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], size[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> find(x) == find(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = find(x), y = find(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">fa[x] = y, size[y] += size[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;uset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">// 这个点是否在生成树内</span></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], fa[maxn], val[maxn];</span><br><span class="line"><span class="keyword">bool</span> inv[maxn];</span><br><span class="line">pii nmin[maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isrt(x) (ch[fa[x]][0] != (x) &amp;&amp; ch[fa[x]][1] != (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (ch[fa[x]][1] == (x))</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; nmin[p] = min(mp(val[p], p), min(nmin[ch[p][<span class="number">0</span>]], nmin[ch[p][<span class="number">1</span>]])); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; swap(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]), inv[p] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(inv[p]) rev(ch[p][<span class="number">0</span>]), rev(ch[p][<span class="number">1</span>]), inv[p] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(!isrt(p)) down(fa[p]); pushdown(p); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y; <span class="comment">// 可能更新0的fa</span></span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = fa[x]) &#123;</span><br><span class="line">splay(x), ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rev(access(x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">makeroot(x), access(y), splay(x); <span class="comment">// 防止x, y位置颠倒</span></span><br><span class="line">ch[x][<span class="number">1</span>] = fa[y] = <span class="number">0</span>, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) readint(arr[i].u), readint(arr[i].v), readint(arr[i].w);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) nmin[i] = mp(inf, i), val[i] = inf;</span><br><span class="line">uset.init();</span><br><span class="line">sort(arr+<span class="number">1</span>, arr+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">   nmin[i + n] = mp(arr[i].w, i + n), val[i + n] = arr[i].w;</span><br><span class="line"><span class="keyword">int</span> x = arr[i].u, y = arr[i].v;</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(uset.find(x, y)) &#123;</span><br><span class="line">makeroot(x);</span><br><span class="line"><span class="keyword">int</span> p = nmin[access(y)].second - n;</span><br><span class="line">vis[p] = <span class="number">0</span>;</span><br><span class="line">cut(arr[p].u, p + n), cut(p + n, arr[p].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line">makeroot(x), splay(x);</span><br><span class="line">fa[x] = i + n, fa[i + n] = y;</span><br><span class="line">uset.unio(x, y);</span><br><span class="line"><span class="keyword">while</span>(!vis[j]) j++;</span><br><span class="line"><span class="keyword">if</span>(uset.size[uset.find(<span class="number">1</span>)] == n) ans = min(ans, arr[i].w - arr[j].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个图，带边权，求一个生成树，使得最大边权与最小边权的差值最小。&lt;/p&gt;
&lt;p&gt;$1 \leq n \l
      
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="点边转化" scheme="http://arintaro.com/tags/%E7%82%B9%E8%BE%B9%E8%BD%AC%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>「清华集训2013」长跑</title>
    <link href="http://arintaro.com/2020/01/12/Answer/run/"/>
    <id>http://arintaro.com/2020/01/12/Answer/run/</id>
    <published>2020-01-12T06:24:40.841Z</published>
    <updated>2020-01-12T06:39:41.439Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个图，带点权，三种操作：连一条边、单点修改一个点权、查询两个点间路径中的最大点权和(每条边只能从一个方向经过)。</p><p>$1 \leq n \leq 1.5 \times 10^5$，$1 \leq m \leq 5n$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>动态图肯定不普及，考虑怎么变成树上问题。</p><p>发现连边的时候只要连成环，则必然可以把这个环的点权都拿走再出去，于是每次连成环后就把它们缩成一个点即可，显然可以用LCT维护。改点权时只要计算出差值加上即可，注意把要改的点splay一下。</p><p>可以多开个并查集维护连通性，就不用在lct上查了，简化代码。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Uset</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn], size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i] = i, size[i] = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> find(x) == find(y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = find(x), y = find(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">size[y] += size[x], fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht, uset;</span><br><span class="line"><span class="comment">// fa懒惰修改</span></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], fa[maxn];</span><br><span class="line">lint sum[maxn], val[maxn];</span><br><span class="line"><span class="keyword">bool</span> inv[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; sum[p] = sum[ch[p][<span class="number">0</span>]] + sum[ch[p][<span class="number">1</span>]] + val[p]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; swap(ch[p][<span class="number">0</span>], ch[p][<span class="number">1</span>]), inv[p] ^= <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">if</span>(inv[p]) rev(ch[p][<span class="number">0</span>]), rev(ch[p][<span class="number">1</span>]), inv[p] = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> fa[p] = ht.find(fa[p]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isrt</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> ch[getf(p)][<span class="number">0</span>] != p &amp;&amp; ch[getf(p)][<span class="number">1</span>] != p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> ch[getf(p)][<span class="number">1</span>] == p; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(!isrt(x)) down(fa[x]); pushdown(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = getf(x), z = getf(y), c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y;</span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = getf(x)) &#123;</span><br><span class="line">splay(x), ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; rev(access(x)); &#125;</span><br><span class="line">lint now;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">ht.unio(x, rt), now += val[x];</span><br><span class="line">dfs(ch[x][<span class="number">0</span>], rt), dfs(ch[x][<span class="number">1</span>], rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = ht.find(x), y = ht.find(y);</span><br><span class="line"><span class="keyword">if</span>(uset.find(x, y)) &#123; <span class="comment">// 两点联通</span></span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">makeroot(x);</span><br><span class="line"><span class="keyword">int</span> z = access(y);</span><br><span class="line">now = <span class="number">0</span>, dfs(z, z), z = ht.find(z);</span><br><span class="line">val[z] = sum[z] = now, ch[z][<span class="number">0</span>] = ch[z][<span class="number">1</span>] = fa[z] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 两点不联通</span></span><br><span class="line">makeroot(x), splay(x);</span><br><span class="line">fa[x] = y, uset.unio(x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = nval - arr[x];</span><br><span class="line">arr[x] = nval, x = ht.find(x);</span><br><span class="line">splay(x), val[x] += d, sum[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!uset.find(x, y)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">x = ht.find(x), y = ht.find(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> val[x];</span><br><span class="line">makeroot(x);</span><br><span class="line"><span class="keyword">return</span> sum[access(y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(val[i]), sum[i] = arr[i] = val[i];</span><br><span class="line">&#125;</span><br><span class="line">uset.init(), ht.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> ins, x, y;</span><br><span class="line">readint(ins), readint(x), readint(y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) link(x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ins == <span class="number">2</span>) change(x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ask(x, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个图，带点权，三种操作：连一条边、单点修改一个点权、查询两个点间路径中的最大点权和(每条边只能从一个方
      
    
    </summary>
    
      <category term="BZOJ" scheme="http://arintaro.com/categories/BZOJ/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/BZOJ/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="缩点" scheme="http://arintaro.com/tags/%E7%BC%A9%E7%82%B9/"/>
    
      <category term="边双联通分量" scheme="http://arintaro.com/tags/%E8%BE%B9%E5%8F%8C%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>「SHOI2014」三叉神经树</title>
    <link href="http://arintaro.com/2020/01/12/Answer/three/"/>
    <id>http://arintaro.com/2020/01/12/Answer/three/</id>
    <published>2020-01-12T05:40:06.620Z</published>
    <updated>2020-01-12T05:52:47.925Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵三叉树，每个点的状态有$0$与$1$两种，除了叶子节点的状态给定，其余节点的状态为它子节点中较多的状态，每次要单点修改一个叶子节点的状态，和查询根节点现在的状态。</p><p>$O(n\log{n})$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑暴力，发现就是从叶子节点不停的向上修改，能改就改，同时要记录每个点底下有几个子节点的状态是$1$。</p><p>可以发现修改的节点必然是从叶子节点向上的连续的一段，所以我们可以利用树链剖分或者是LCT加速这个过程，同时维护一段树链的状态是不是都相同，树链剖分只需要在最后一段树链上的线段树进行二分，所以可以做到两个$\log$，如果利用LCT，利用其可以直接获得到根节点的Splay的特性，我们可以直接在整个路径上进行二分，与在线段树上二分不同的是，splay上二分一定要考虑不存在的情况，然后类似找前驱后继的过程递归去找即可。</p><p>标记维护的时候也一定要注意，递归时不要忘记pushdown，pushup时也一定要考虑如果左右节点不存在，标记该如何更新，写起来比树剖麻烦多了，但是跑的好像也不是很快。</p><p>另外在这里记一下数据该怎么造，具体来说就是用multiset先把$1-n$插进去，每个点在当前合法范围内，找multiset内最大数，在这个范围内rand一下，再lower_bound去set里找，这样就能保证三叉和无重。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin), p1 == p2) ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> son[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> dfa[<span class="number">3</span> * maxn], cnt[<span class="number">3</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isrt(x) (ch[fa[x]][0] != (x) &amp;&amp; ch[fa[x]][1] != (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get(x) (ch[fa[x]][1] == (x))</span></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], fa[maxn], cnt[maxn], same[maxn], ladd[maxn];</span><br><span class="line"><span class="comment">// 静态树不需要makeroot</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// 平衡树上的标记必须考虑不存在的情况</span></span><br><span class="line">same[p] = (!ch[p][<span class="number">0</span>] || same[ch[p][<span class="number">0</span>]] == cnt[p]) &amp;&amp; (!ch[p][<span class="number">1</span>] || same[ch[p][<span class="number">1</span>]] == cnt[p]) ? cnt[p] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">cnt[p] += nval, ladd[p] += nval, same[p] = same[p] == <span class="number">-1</span> ? <span class="number">-1</span> : same[p] + nval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ladd[p]) add(ch[p][<span class="number">0</span>], ladd[p]), add(ch[p][<span class="number">1</span>], ladd[p]), ladd[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = fa[x], z = fa[y], c = get(x);</span><br><span class="line"><span class="keyword">if</span>(!isrt(y)) ch[z][get(y)] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line">ch[y][c] = ch[x][c ^ <span class="number">1</span>], fa[ch[y][c]] = y;</span><br><span class="line">ch[x][c ^ <span class="number">1</span>] = y, fa[y] = x;</span><br><span class="line">pushup(y), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span>(!isrt(x)) down(fa[x]); pushdown(x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">down(x);</span><br><span class="line"><span class="keyword">for</span>(; !isrt(x); rotate(x)) &#123;</span><br><span class="line"><span class="keyword">if</span>(!isrt(fa[x])) rotate(get(fa[x]) == get(x) ? fa[x] : x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; y = x, x = fa[x]) &#123;</span><br><span class="line">splay(x), ch[x][<span class="number">1</span>] = y, pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; fa[x] = y; &#125;</span><br><span class="line"><span class="comment">// 找从下往上最长的一段aim, 返回顶点的坐标, 保证存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 到任意一个节点都保证其前缀节点已经可以</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pushdown(p);</span><br><span class="line"><span class="keyword">if</span>((!ch[p][<span class="number">1</span>] || same[ch[p][<span class="number">1</span>]] == aim) &amp;&amp; cnt[p] == aim) &#123; <span class="comment">// 可能成为答案</span></span><br><span class="line"><span class="keyword">int</span> res = getpos(ch[p][<span class="number">0</span>], aim);</span><br><span class="line"><span class="keyword">return</span> res == <span class="number">-1</span> ? p : res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getpos(ch[p][<span class="number">1</span>], aim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">splay(x);</span><br><span class="line"><span class="keyword">if</span>(cnt[x] != aim) cnt[x] += f, pushup(x);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">access(x), splay(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(same[<span class="number">1</span>] == aim) add(<span class="number">1</span>, f);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> y = dfa[getpos(<span class="number">1</span>, aim)];</span><br><span class="line">splay(y);</span><br><span class="line">cnt[y] += f, add(ch[y][<span class="number">1</span>], f);</span><br><span class="line">pushup(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">splay(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> cnt[<span class="number">1</span>] &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;lct;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfa[x] = fa;</span><br><span class="line"><span class="keyword">if</span>(x &gt; n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = son[x][i];</span><br><span class="line">dfs(y, x);</span><br><span class="line">cnt[x] += (cnt[y] &gt;= <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">lct.cnt[x] = lct.same[x] = cnt[x];</span><br><span class="line">lct.link(x, fa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">3</span>; k++) readint(son[i][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>; i&lt;=<span class="number">3</span>*n+<span class="number">1</span>; i++) readint(cnt[i]), cnt[i] = cnt[i] ? <span class="number">3</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">readint(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lct.change(dfa[x], cnt[x] == <span class="number">3</span> ? <span class="number">2</span> : <span class="number">1</span>, cnt[x] == <span class="number">3</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">cnt[x] = cnt[x] == <span class="number">3</span> ? <span class="number">0</span> : <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randint</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rand() % x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand(clock());</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">FILE* fp = fopen(<span class="string">"test.in"</span>, <span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">int</span> n = maxn, m = maxm;</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, n);</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) pre.insert(i), pre.insert(i), pre.insert(i), son[i].clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">3</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> r = *(--pre.lower_bound(min(n+<span class="number">1</span>, i)));</span><br><span class="line"><span class="keyword">int</span> fa = *pre.lower_bound(randint(r));</span><br><span class="line">pre.erase(pre.find(fa));</span><br><span class="line">son[fa].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">fprintf</span>(fp, <span class="string">"%d %d %d\n"</span>, son[i][<span class="number">0</span>], son[i][<span class="number">1</span>], son[i][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n+<span class="number">1</span>; i++) <span class="built_in">fprintf</span>(fp, <span class="string">"%d "</span>, randint(<span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">"\n%d\n"</span>, m);</span><br><span class="line"><span class="keyword">while</span>(m--) <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, randint(<span class="number">2</span> * n + <span class="number">1</span>) + n);</span><br><span class="line">fclose(fp);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"./three &lt; test.in &gt; test.out"</span>);</span><br><span class="line">system(<span class="string">"./force &lt; test.in &gt; ans.out"</span>);</span><br><span class="line"><span class="keyword">if</span>(system(<span class="string">"diff -b -B test.out ans.out"</span>)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"WA"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"AC"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一棵三叉树，每个点的状态有$0$与$1$两种，除了叶子节点的状态给定，其余节点的状态为它子节点中较多的状
      
    
    </summary>
    
      <category term="BZOJ" scheme="http://arintaro.com/categories/BZOJ/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/BZOJ/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="结论" scheme="http://arintaro.com/tags/%E7%BB%93%E8%AE%BA/"/>
    
      <category term="树链剖分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="树链二分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CQOI2018 异或序列</title>
    <link href="http://arintaro.com/2020/01/05/Answer/xor/"/>
    <id>http://arintaro.com/2020/01/05/Answer/xor/</id>
    <published>2020-01-05T14:13:35.729Z</published>
    <updated>2020-01-05T14:17:47.068Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>懒得写了，<a href="https://www.luogu.com.cn/problem/P4462。" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4462。</a></p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这题其实比较水，莫队的套路题。</p><p>但是为什么我还要开个页面写一下呢？因为我第一次做的时候没有注意可以直接转化成序列中两个数异或之和，而是分了从左面加入和右面加入两种情况，写的非常麻烦，记录一下教训，转化问题要彻底，不要觉得睿智题转化一下能做就开始写，很可能有更简单的写法。</p><p>对于写法来说，长短无所谓，重要是不容易写挂和写完能跑过去。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], bid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qry</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qry&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; <span class="number">1</span> ? r &lt; b.r : r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lcnt[maxn], rcnt[maxn];</span><br><span class="line">lint nowans = <span class="number">0</span>, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = arr[i] ^ k, b = arr[i<span class="number">-1</span>] ^ k;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) lcnt[a]++, rcnt[b]++;</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) nowans += f * lcnt[arr[i<span class="number">-1</span>]];</span><br><span class="line"><span class="keyword">else</span> nowans += f * rcnt[arr[i]];</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) lcnt[a]--, rcnt[b]--; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(k);</span><br><span class="line">len = n / <span class="built_in">sqrt</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]), arr[i] ^= arr[i<span class="number">-1</span>], bid[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) readint(q[i].l), readint(q[i].r), q[i].id = i;</span><br><span class="line">sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;懒得写了，&lt;a href=&quot;https://www.luogu.com.cn/problem/P4462。&quot;
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="异或问题" scheme="http://arintaro.com/tags/%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98/"/>
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="莫队" scheme="http://arintaro.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2016 大数</title>
    <link href="http://arintaro.com/2020/01/05/Answer/number/"/>
    <id>http://arintaro.com/2020/01/05/Answer/number/</id>
    <published>2020-01-05T13:35:58.533Z</published>
    <updated>2020-01-05T13:42:19.689Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个由$0-9$中的整数构成的字符串，每次给一个子串，询问这个子串的子串中有多少在一个给定的模数的模意义下为$0$。</p><p>$1 \leq n, m \leq 10^5$，$1 \leq mod \leq 10^9$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>难以维护的信息+可以离线，可以考虑莫队，莫队每次只要以新加入的点为端点产生的贡献即可，于是可以套路的左右两边推一下式子。</p><p>但是由于我最后忘了「由于$\gcd(10, mod) = 1$，模意义的$10$可以随意除下去」，导致最终的式子带着与$10$有关的次幂。更睿智的是我没有提前离散化，而是开了一个哈希表，这导致了我第一次交上去$\text{TLE}$了两个点，最终懒得思考如何优化，在写出数据生成器玄学地调了一下哈希模数和块长以$995ms$成功卡过。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line"><span class="keyword">return</span> s[len] = <span class="string">'\0'</span>, len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mHash_table</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">397751</span>;</span><br><span class="line"><span class="keyword">int</span> head[htmod], nxt[maxn], key[maxn], val[maxn];</span><br><span class="line"><span class="keyword">int</span> totnode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">find</span><span class="params">(<span class="keyword">int</span> nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[p]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i] == nkey) <span class="keyword">return</span> mp(val[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = find(nkey).second;</span><br><span class="line"><span class="keyword">if</span>(now != <span class="number">0</span>) &#123; val[now] += nval; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line">key[++totnode] = nkey, val[totnode] = nval;</span><br><span class="line">nxt[totnode] = head[p], head[p] = totnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;lht, rht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, bid[maxn], mod;</span><br><span class="line"><span class="keyword">int</span> len, arr[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line">lint ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qry</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qry&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; <span class="number">1</span> ? r &lt; b.r : r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> two_five&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn]; <span class="comment">// 结尾为特殊数字的数量</span></span><br><span class="line">lint nowans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) cnt[arr[pos]]++;</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(mod == <span class="number">2</span>) nowans += f * (cnt[<span class="number">0</span>] + cnt[<span class="number">2</span>] + cnt[<span class="number">4</span>] + cnt[<span class="number">6</span>] + cnt[<span class="number">8</span>]);</span><br><span class="line"><span class="keyword">else</span> nowans += f * (cnt[<span class="number">0</span>] + cnt[<span class="number">5</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[pos] == <span class="number">0</span> || (mod == <span class="number">2</span> &amp;&amp; (arr[pos] == <span class="number">2</span> || arr[pos] == <span class="number">4</span> || arr[pos] == <span class="number">6</span> || arr[pos] == <span class="number">8</span>))</span><br><span class="line">|| (mod == <span class="number">5</span> &amp;&amp; arr[pos] == <span class="number">5</span>)) nowans += f * (pos - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) cnt[arr[pos]]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = str[i] - <span class="string">'0'</span>;</span><br><span class="line">l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> others&#123;</span><br><span class="line"></span><br><span class="line">lint nowans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> divpow[maxn], div10;</span><br><span class="line"><span class="comment">// 在左边加 x * pow10[len] + y = 0</span></span><br><span class="line"><span class="comment">// 在右边加 y * 10 + x = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123; <span class="comment">// 0左边 1右边</span></span><br><span class="line"><span class="keyword">int</span> a = (lint)arr[pos] * divpow[pos] % mod, b = (lint)arr[pos - <span class="number">1</span>] * divpow[pos - <span class="number">1</span>] % mod;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) lht.add(a, <span class="number">1</span>), rht.add(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) nowans += f * lht.find(b).first; <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">else</span> nowans += f * rht.find(a).first;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) lht.add(a, <span class="number">-1</span>), rht.add(b, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">divpow[<span class="number">0</span>] = <span class="number">1</span>, div10 = qpow(<span class="number">10</span>, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) divpow[i] = (lint)divpow[i<span class="number">-1</span>] * div10 % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = ((lint)arr[i<span class="number">-1</span>] * <span class="number">10</span> + str[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> t = clock();</span><br><span class="line"></span><br><span class="line">readint(mod), n = readstr(str + <span class="number">1</span>);</span><br><span class="line">readint(m);</span><br><span class="line">len = (n &gt; <span class="number">5e4</span> ? <span class="number">600</span> : <span class="built_in">sqrt</span>(n));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(q[i].l), readint(q[i].r), q[i].id = i;</span><br><span class="line">bid[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mod == <span class="number">2</span> || mod == <span class="number">5</span>) two_five::work();</span><br><span class="line"><span class="keyword">else</span> others::work();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个由$0-9$中的整数构成的字符串，每次给一个子串，询问这个子串的子串中有多少在一个给定的模数的模意义
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="莫队" scheme="http://arintaro.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
      <category term="剩余系" scheme="http://arintaro.com/tags/%E5%89%A9%E4%BD%99%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2010 弹飞绵羊</title>
    <link href="http://arintaro.com/2020/01/05/Answer/sheep/"/>
    <id>http://arintaro.com/2020/01/05/Answer/sheep/</id>
    <published>2020-01-05T10:08:20.711Z</published>
    <updated>2020-01-05T10:24:43.946Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个序列$a_i$，每次给序列中的一个位置$p$，每次跳到$p + a_p$，直到跳出整个序列为止，问需要跳多少次，要求支持$a_i$单点修改。</p><p>$1 \leq n, m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>此题正解$\text{LCT}$，这里说一下分块做法。</p><p>显然我们需要利用类似「路径压缩」的思想，来平衡修改和查询的复杂度，像并查集一样直接压到终点查询$O(1)$，修改自闭，所以考虑根号平衡。</p><p>显然的想法是对每个点只压$len$步，修改一个点时重构到它距离小于$len$的节点，然而复杂度是错的，弄个菊花图反复修改菊花中心就会自闭，似乎加一些剪枝或者懒惰标记可以令复杂度正确，但是非常麻烦。</p><p>看了题解发现是直接按序列分块，每次只要保证至少跳到下一个块即可，这样修改时就比较方便，由于规定了至少跳到下一个块，这样它的前驱节点只能跟它在同一块中，于是暴力重构这个块即可。</p><p>似乎是这种类似带修改「跳节点」问题的通用分块法，按拓扑序分块一下，确保转移能至少能转移到下一块即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> len, tot;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], bnxt[maxn], bcnt[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bl(x) ((x - 1) * len + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> br(x) ((x) == tot ? n : (x) * len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bid(x) (((x) - 1) / len + 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=br(t); i&gt;=bl(t); i--) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + arr[i];</span><br><span class="line"><span class="keyword">if</span>(j &gt; br(t)) bnxt[i] = j, bcnt[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> bnxt[i] = bnxt[j], bcnt[i] = bcnt[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n), tot = <span class="built_in">ceil</span>((<span class="keyword">double</span>)n / len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) build(i);</span><br><span class="line"></span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">int</span> ins, x;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) &#123;</span><br><span class="line">readint(x), x++;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n) res += bcnt[x], x = bnxt[x];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">readint(x), x++, readint(arr[x]);</span><br><span class="line">build(bid(x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个序列$a_i$，每次给序列中的一个位置$p$，每次跳到$p + a_p$，直到跳出整个序列为止，问需
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="转移分块" scheme="http://arintaro.com/tags/%E8%BD%AC%E7%A7%BB%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu 3676 小清新数据结构题</title>
    <link href="http://arintaro.com/2020/01/04/Answer/free/"/>
    <id>http://arintaro.com/2020/01/04/Answer/free/</id>
    <published>2020-01-04T14:48:21.098Z</published>
    <updated>2020-01-04T15:00:38.973Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>在很久很久以前，有一棵$n$个点的树，每个点有一个点权。</p><p>现在有$m$次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。</p><p>$1 \leq n \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先想如何不换根带修改地做出答案。</p><p>一开始想了很久如何维护原权值做出来，想不出来，遂翻题解。</p><p>发现如果在数据结构上直接维护原权值，不容易计算答案，发现只有单点修改，那不妨记录每个点子树的点权和，修改一个点时只需要修改它到根链上的部分，问题转化成区间修改，区间询问平方和，显然能做。</p><p>再想如何换根，发现树中有很大一部分的答案是不变的，变的答案只有这个点到根这部分，除它自己单独计算外，发现这部分中的其他点的贡献可以通过整体减去局部后平方计算出来，由于整体和是个定值，平方后打开括号可以消除其影响，从而用之前维护的信息分别计算。</p><p>感觉这题不难，但是我还是翻了题解+调了很久，我在打开$\sum_{1 \leq i \leq n}{(a_i + x)^2}$时，把它变成了$\sum{a_i^2} + 2x\sum{a_i} + x^2$，这问题不是我第一次犯了，以后要注意。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn], dfn_val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lson[maxn], rson[maxn], sum[maxn], ladd[maxn];</span><br><span class="line">lint sum_pow[maxn];</span><br><span class="line"><span class="keyword">int</span> root, totnode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">sum[p] = sum[lson[p]] + sum[rson[p]];</span><br><span class="line">sum_pow[p] = sum_pow[lson[p]] + sum_pow[rson[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ladd[p] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">sum_pow[lson[p]] += (lint)<span class="number">2</span> * ladd[p] * sum[lson[p]] + (lint)(mid - l + <span class="number">1</span>) * ladd[p] * ladd[p];</span><br><span class="line">sum_pow[rson[p]] += (lint)<span class="number">2</span> * ladd[p] * sum[rson[p]] + (lint)(r - mid) * ladd[p] * ladd[p];</span><br><span class="line">sum[lson[p]] += (mid - l + <span class="number">1</span>) * ladd[p], sum[rson[p]] += (r - mid) * ladd[p];</span><br><span class="line">ladd[lson[p]] += ladd[p], ladd[rson[p]] += ladd[p];</span><br><span class="line">ladd[p] = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">p = ++totnode;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; sum[p] = dfn_val[l], sum_pow[p] = (lint)sum[p] * sum[p]; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson[p], l, mid), build(rson[p], mid + <span class="number">1</span>, r);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">sum_pow[p] += (lint)<span class="number">2</span> * x * sum[p] + (lint)(r - l + <span class="number">1</span>) * x * x, sum[p] += (r - l + <span class="number">1</span>) * x;</span><br><span class="line">ladd[p] += x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) add(lson[p], l, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) add(rson[p], mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123; add(root, <span class="number">1</span>, n, L, R, x); &#125;</span><br><span class="line"><span class="function">lint <span class="title">ask_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[p];</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res += ask_sum(lson[p], l, mid, L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res += ask_sum(rson[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask_sum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> ask_sum(root, <span class="number">1</span>, n, L, R); &#125;</span><br><span class="line"><span class="function">lint <span class="title">ask_pow</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum_pow[p];</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res += ask_pow(lson[p], l, mid, L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res += ask_pow(rson[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask_pow</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> ask_pow(root, <span class="number">1</span>, n, L, R); &#125;</span><br><span class="line">&#125;smt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> size[maxn], deep[maxn], dfa[maxn];</span><br><span class="line"><span class="keyword">int</span> wson[maxn], wtop[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], dfr[maxn], totdfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> color[maxn], sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa, <span class="keyword">int</span> nc)</span> </span>&#123;</span><br><span class="line">deep[x] = d, dfa[x] = fa, size[x] = <span class="number">1</span>, sum[x] = arr[x];</span><br><span class="line">color[x] = nc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x, x == root ? y : nc);</span><br><span class="line">size[x] += size[y], sum[x] += sum[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn, wtop[x] = top, dfn_val[totdfn] = sum[x];</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == wson[x] || y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, y);</span><br><span class="line">&#125;</span><br><span class="line">dfr[x] = totdfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先累加不在它到根链上点的总贡献 和它和它子树内部的贡献，用总体权值-链上权值</span></span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == root) <span class="keyword">return</span> smt.ask_pow(<span class="number">1</span>, n);</span><br><span class="line">lint sumr = smt.ask_sum(dfn[root], dfn[root]), now = <span class="number">0</span>;</span><br><span class="line">lint res = smt.ask_pow(<span class="number">1</span>, n) + (deep[x] - <span class="number">1</span>) * sumr * sumr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[color[x]]) &#123;</span><br><span class="line">now += smt.ask_sum(dfn[wtop[x]], dfn[x]);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line">now += smt.ask_sum(dfn[color[x]], dfn[x]);</span><br><span class="line"></span><br><span class="line">res -= <span class="number">2</span> * sumr * now;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = nval - arr[x];</span><br><span class="line">arr[x] = nval;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[root]) &#123;</span><br><span class="line">smt.add(dfn[wtop[x]], dfn[x], d);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line">smt.add(dfn[root], dfn[x], d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">dfs1(root, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), dfs2(root, root);</span><br><span class="line"></span><br><span class="line">smt.build(smt.root, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ins, x, y;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) readint(x), readint(y), change(x, y);</span><br><span class="line"><span class="keyword">else</span> readint(x), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ask(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;在很久很久以前，有一棵$n$个点的树，每个点有一个点权。&lt;/p&gt;
&lt;p&gt;现在有$m$次操作，每次操作是修改一
      
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
      <category term="线段树" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2016 美味</title>
    <link href="http://arintaro.com/2020/01/04/Answer/meal/"/>
    <id>http://arintaro.com/2020/01/04/Answer/meal/</id>
    <published>2020-01-04T12:07:07.179Z</published>
    <updated>2020-01-04T12:18:30.941Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一个序列$a_j$，每次询问给定$b_i$，$x_i$，$L, R$，要求对于$j \in[L, R]$，使$b_i \ xor\ (x_i + a_j)$最大</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>首先暴力肯定不行，不暴力又发现$x_i + a_j$对于$xor$结果的影响并不容易计算。</p><p>一开始一直考虑怎么在可持久化$Trie$上做，然后发现完全做不了，<del>（对每个$Trie$节点维护一个可持久化平衡树</del>。</p><p>题解是考虑一个类似过程，与位运算有关的问题一般要拆位考虑，对每一位考虑，判断这一位能否选与$b_i$这位不同的数字。</p><p>关键在于这个判断能否选的过程，判断是否存在一个$x_i + a_j$使得这位为$0$或$1$，与位运算不同，我一开始考虑这个东西怎么按位拆开判断，然而根本不用，对于加法和减法，最简单的约束条件就是转化成不等式，考虑使得这位$0$或这位为$1$的范围，不妨归纳地考虑，考虑之前的位的$x_i + a_j$已经选好设为$pre$。下面考虑这位$t$要选$0$的情况，其中$*$是前面的位，显然上面是下界，下面是上界。</p><center> <strong>**</strong>000000 </center><br><center> <strong>**</strong>011111 </center><p>雾，所以我们可以列出$x_i + a_j \in [pre, pre + (1 &lt;&lt; t) - 1]$这个不等式，把$x_i$移过去即消除了询问的影响，加上$[L, R]$，即转化成一个二维平面上的偏序问题，可以直接解决。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mlog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> t = x;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)((lint&amp;)t &gt;&gt; <span class="number">52</span> &amp; <span class="number">63</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxv = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[maxnode], rson[maxnode], sum[maxnode];</span><br><span class="line"><span class="keyword">int</span> root[maxn], totnode;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">p = ++totnode;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; sum[p] = sum[pre] + nval; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid) rson[p] = rson[pre], add(lson[p], lson[pre], l, mid, pos, nval);</span><br><span class="line"><span class="keyword">else</span> lson[p] = lson[pre], add(rson[p], rson[pre], mid + <span class="number">1</span>, r, pos, nval);</span><br><span class="line">sum[p] = sum[lson[p]] + sum[rson[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[p] - sum[pre];</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid &amp;&amp; ask(lson[p], lson[pre], l, mid, L, R)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid &amp;&amp; ask(rson[p], rson[pre], mid + <span class="number">1</span>, r, L, R)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(root[R], root[L<span class="number">-1</span>], <span class="number">0</span>, maxv, max(l, <span class="number">0</span>), min(r, maxv));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(x), add(root[i], root[i<span class="number">-1</span>], <span class="number">0</span>, maxv, x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b, L, R;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(b), readint(x), readint(L), readint(R);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 找 a + x</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=maxd; t&gt;=<span class="number">0</span>; t--) &#123;</span><br><span class="line"><span class="keyword">if</span>((b &gt;&gt; t) &amp; <span class="number">1</span>) &#123; <span class="comment">// a + x这位需要为0</span></span><br><span class="line"><span class="comment">// *****00000</span></span><br><span class="line"><span class="comment">// *****01111</span></span><br><span class="line"><span class="comment">// a + x \in [pre, pre + (1 &lt;&lt; t) - 1]</span></span><br><span class="line"><span class="keyword">bool</span> suc = ask(L, R, pre - x, pre + (<span class="number">1</span> &lt;&lt; t) - <span class="number">1</span> - x);</span><br><span class="line"><span class="keyword">if</span>(suc) ans += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line"><span class="keyword">else</span> pre += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// a + x这为需要为1</span></span><br><span class="line"><span class="comment">// ****10000</span></span><br><span class="line"><span class="comment">// ****11111</span></span><br><span class="line"><span class="keyword">bool</span> suc = ask(L, R, pre + (<span class="number">1</span> &lt;&lt; t) - x, pre + (<span class="number">1</span> &lt;&lt; (t + <span class="number">1</span>)) - <span class="number">1</span> - x);</span><br><span class="line"><span class="keyword">if</span>(suc) ans += (<span class="number">1</span> &lt;&lt; t), pre += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给一个序列$a_j$，每次询问给定$b_i$，$x_i$，$L, R$，要求对于$j \in[L, R]$，
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="可持久化数据结构" scheme="http://arintaro.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="异或问题" scheme="http://arintaro.com/tags/%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2015 开店</title>
    <link href="http://arintaro.com/2020/01/04/Answer/shop/"/>
    <id>http://arintaro.com/2020/01/04/Answer/shop/</id>
    <published>2020-01-04T11:05:48.020Z</published>
    <updated>2020-01-04T11:15:25.509Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一棵带边权和点权的树，每次询问一个点到所有点权范围为$[L, R]$的点的距离和，强制在线。</p><p>$n \leq 1.5 \times 10^5$，$m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>显然可以建出点分树，每次查询即可，如果可以离线就点分治就行。</p><p>重点说一下树剖的思路，这题显然是套了一个查点权范围的壳，以卡掉一些做法。所以先考虑不带点权怎么做，推一下式子发现重点是维护$\sum_{1 \leq j \leq n}{d_{\text{lca}(i, j)}}$，其中$d$表示某个节点到根的距离，从题解中学到一种做法，对每个点考虑它的贡献为「这两个点从到根的路径交集」，所以我们可以先对所有的$j$覆盖一次它到根的路径，查询时只查询问点到根就行。</p><p>然而树剖空间复杂度是错的，不少主席树的题空间两个$\log$，跑到上界大概都需要几G的空间，然而没人卡..</p><p>下面的代码是点分树的，由于我写的时候大脑短路，觉得好像要修改点权，就敲了个平衡树。。实际上不带修用$\text{vector}$即可，但是这样复杂度是一样，常数不太好。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, lint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxa;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ch[maxnode][<span class="number">2</span>], size[maxnode], key[maxnode], val[maxnode], totnode;</span><br><span class="line"><span class="keyword">static</span> lint sum[maxnode];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = ch[x][c];</span><br><span class="line">ch[x][c] = ch[y][c ^ <span class="number">1</span>], ch[y][c ^ <span class="number">1</span>] = x;</span><br><span class="line">size[y] = size[x], sum[y] = sum[x];</span><br><span class="line">size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">x = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size[ch[ch[x][c]][c]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size[ch[ch[x][c]][c ^ <span class="number">1</span>]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(ch[x][c], c ^ <span class="number">1</span>), rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">maintain(ch[x][<span class="number">0</span>], <span class="number">0</span>), maintain(ch[x][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">maintain(x, <span class="number">0</span>), maintain(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">size[++totnode] = <span class="number">1</span>, key[totnode] = nkey, val[totnode] = sum[totnode] = nval;</span><br><span class="line"><span class="keyword">return</span> totnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; p = totnode; <span class="keyword">return</span>; &#125;</span><br><span class="line">size[p]++, sum[p] += val[totnode];</span><br><span class="line">insert(ch[p][key[totnode] &gt;= key[p]]);</span><br><span class="line">maintain(p, key[totnode] &gt;= key[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123; newnode(nkey, nval), insert(root); &#125;</span><br><span class="line"><span class="comment">// 第一维cnt，第二维sum</span></span><br><span class="line"><span class="function">pii <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(nkey &gt;= key[p]) &#123;</span><br><span class="line">pii res = getsum(ch[p][<span class="number">1</span>], nkey);</span><br><span class="line">res.first += size[ch[p][<span class="number">0</span>]] + <span class="number">1</span>, res.second += sum[ch[p][<span class="number">0</span>]] + val[p];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> getsum(ch[p][<span class="number">0</span>], nkey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">pii rt = getsum(root, R), lt = getsum(root, L - <span class="number">1</span>);</span><br><span class="line">rt.first -= lt.first, rt.second -= lt.second;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> SBT::ch[maxnode][<span class="number">2</span>], SBT::size[maxnode], SBT::key[maxnode], SBT::val[maxnode], SBT::totnode;</span><br><span class="line">lint SBT::sum[maxnode];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> rmax, nrot, ntot;</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x), size[x] += size[y];</span><br><span class="line">nmax = max(nmax, size[y]);</span><br><span class="line">&#125;</span><br><span class="line">nmax = max(nmax, ntot - size[x]);</span><br><span class="line"><span class="keyword">if</span>(nmax &lt; rmax) rmax = nmax, nrot = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totbst = <span class="number">0</span>;</span><br><span class="line">SBT bst[maxnode];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prt[maxn], pdis[maxn], bstid[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rtbst[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">prt[x].push_back(nrot), pdis[x].push_back(d), bstid[x].push_back(totbst);</span><br><span class="line">bst[totbst].insert(arr[x], d), size[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, d + ew[i], x);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cerr &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">prt[x].push_back(x), pdis[x].push_back(<span class="number">0</span>), bstid[x].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">rtbst[x].push_back(++totbst), dfs2(y, ew[i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y] || size[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = size[y];</span><br><span class="line">dfs1(y, x), dfs3(nrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prt[x].size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prt[x][i] == x) &#123; <span class="comment">// 为根</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;rtbst[x].size(); j++) res += bst[rtbst[x][j]].ask(L, R).second;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不为根</span></span><br><span class="line"><span class="keyword">int</span> rt = prt[x][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;rtbst[rt].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(rtbst[rt][j] == bstid[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">pii now = bst[rtbst[rt][j]].ask(L, R);</span><br><span class="line">res += (lint)now.first * pdis[x][i] + now.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= arr[rt] &amp;&amp; arr[rt] &lt;= R) res += pdis[x][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(maxa);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = n;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs3(nrot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, a, b;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(x), readint(a), readint(b);</span><br><span class="line"><span class="keyword">int</span> l = (a + res) % maxa, r = (b + res) % maxa;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l, r);</span><br><span class="line">res = ask(x, l, r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line"><span class="comment">// res = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给一棵带边权和点权的树，每次询问一个点到所有点权范围为$[L, R]$的点的距离和，强制在线。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态点分治" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2007 捉迷藏</title>
    <link href="http://arintaro.com/2020/01/04/Answer/hide/"/>
    <id>http://arintaro.com/2020/01/04/Answer/hide/</id>
    <published>2020-01-04T09:08:14.865Z</published>
    <updated>2020-01-04T09:30:54.099Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一颗树，分两类点，一类黑点一类白点，要求支持两种操作，查询当前所有黑点两两间距离的最大值，和改变一个点的颜色。</p><p>$1 \leq n \leq 2000$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>点分治做法不提了，大概是动态模拟点分治的过程，开很多个堆维护答案，代码见下面。</p><p>括号序列做法难以想到，技巧性强，代码比点分治做法短很多，但是也不是很好写，非常容易写挂。</p><p>括号序列是像$(1(2)(3))$这样的东西，这表示它遍历点$1$，然后依次遍历了$2,3$两个儿子。</p><p>首先有一个结论，对于边权为$1$的树，跑一个它的括号序，两点间的距离即为对应括号序列子段不匹配的括号数。这个显然可以用线段树维护，类似摩尔投票法？但是一般我们求距离都用$LCA$，跑的比线段树快多了，所以这个结论就比较鸡肋。</p><p>但是本题中，我们考虑如何动态维护两个黑点间的最大距离，也就是在分治结构上，必须以较低代价合并左右两个儿子的信息，就能利用线段树维护答案。</p><p>显然在一次合并信息中，我们只需要考虑跨区间的答案，不妨对一段区间设$(x, y)$，其中$x$表示它未匹配的右括号数量，$y$表示左括号的。</p><p>显然可以快速合并这两个区间，并得到新区间的答案，大概是类似$x_l + y_l - x_r + y_r$或$x_l - y_l + x_r + y_r$，对应两种$y_l$和$x_r$大小关系不同的情况，但是问题是：在分治结构上，左边和右边都各有$O(n)$个区间，暴力匹配是$O(n^2)$，拆拆式子用单调队列似乎可以做到$O(n)$？这对不修改是可以接受的，但是对于修改后合并信息完全不行，单次修改的复杂度会变成$O(n)$。</p><p>所以，要想快速合并信息，我们必然要拆开左右两边的信息，使其独立，我们就可以分别找两面$\max$，然后简单的相加从而合并信息。</p><p>问题在于合并信息时，由于$y_l$和$x_r$的大小关系，会产生不同的贡献。容易想到是否存在一种计算方式使得不合法的信息不会被统计。</p><p>简单来说，我们发现一个区间合并信息对答案的贡献只有三种，即$x + y$，$x - y$， $y - x$。可以分别求出它们在各个情况下的最大值，然后直接相加合并。正确性是由于：考虑$x_l + y_l - x_r + y_r$的情况，这代表$y_l &gt; x_r$，如果存在一个$y_l &lt; x_r$，并且这样的式子成为了我们的答案，就会对答案造成影响，但是在这种情况下$x_l - y_l + x_r + y_r$显然会比它更大，只要我们考虑了这种情况，不合法的情况就不会影响答案。</p><p>这种「虽然当前统计了不合法的方案，但是在取最优的过程中不会影响答案」的方法，降低了限制条件的要求，从而可以在线段树上高效维护。</p><p>我们可以直接对于不合法的位置，把它节点三种答案贡献都设为$-inf$，即可简单的只求黑点间的答案，注意这个$inf$可能会被多次相加相减，因此千万不要开太大，比$maxn$大即可。</p><p>这种方法的代码在我写出来后，没过样例，于是准备拍个小数据调一下，把之前的数据生成器和暴力复制过来后，一不小心把之前的代码也复制过来了，导致这份代码被覆盖，也就是说：丢了。。丢了。。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch -<span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> son[maxnode], bro[maxnode], fa[maxnode], val[maxnode];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s[maxnode], stop, totnode;</span><br><span class="line"><span class="keyword">int</span> root, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span>(val[x] &gt; val[y]) swap(x, y); <span class="comment">// 大根堆</span></span><br><span class="line">bro[x] = son[y], fa[son[y]] = x;</span><br><span class="line">son[y] = x, fa[x] = y;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">fa[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || bro[x] == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> y = bro[x], p = bro[y];</span><br><span class="line">bro[x] = bro[y] = fa[y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> merge(merge(x, y), merge(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = stop ? s[stop--] : ++totnode;</span><br><span class="line">son[p] = bro[p] = fa[p] = <span class="number">0</span>, val[p] = nval;</span><br><span class="line">root = merge(root, p), cnt++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root ? val[root] : -inf; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top2</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> bro[p] ? max(top2(bro[p]), val[p]) : val[p]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> son[root] ? top2(son[root]) : -inf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; s[++stop] = root, root = merge(son[root]), cnt--; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x == root) &#123; pop(); <span class="keyword">return</span>; &#125;</span><br><span class="line">s[++stop] = x, cnt--;</span><br><span class="line"><span class="keyword">int</span>&amp; p = son[fa[x]] == x ? son[fa[x]] : bro[fa[x]];</span><br><span class="line">p = bro[x], fa[p] = fa[x];</span><br><span class="line">root = merge(root, merge(son[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">print(bro[p]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[p]), print(son[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"print: "</span>), print(root), <span class="built_in">putchar</span>(<span class="string">'\n'</span>); &#125;</span><br><span class="line">&#125;q[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::son[maxnode], Heap::bro[maxnode], Heap::fa[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::val[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::s[maxnode], Heap::stop, Heap::totnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="keyword">int</span> rmax = <span class="number">0</span>, nrot = <span class="number">0</span>, ntot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">nmax = max(nmax, size[y]);</span><br><span class="line">&#125;</span><br><span class="line">nmax = max(nmax, ntot - size[x]);</span><br><span class="line"><span class="keyword">if</span>(nmax &lt; rmax) rmax = nmax, nrot = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dark[maxn];</span><br><span class="line"><span class="keyword">int</span> totq, rt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mqid[maxn], qid[maxn], qpos[maxn], dist[maxn];</span><br><span class="line"><span class="keyword">int</span> ntpos[maxnode], mtpos[maxnode], mtlast[maxnode];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> d, <span class="keyword">int</span> mt, <span class="keyword">int</span> nt)</span> </span>&#123;</span><br><span class="line">dist[x].push_back(d), mqid[x].push_back(mt), qid[x].push_back(nt);</span><br><span class="line">qpos[x].push_back(dark[x] ? q[nt].push(d) : <span class="number">0</span>);</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, x, d + <span class="number">1</span>, mt, nt);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明主堆</span></span><br><span class="line"><span class="keyword">int</span> mt = ++totq;</span><br><span class="line">mqid[x].push_back(mt), qid[x].push_back(mt), dist[x].push_back(<span class="number">0</span>);</span><br><span class="line">qpos[x].push_back(dark[x] ? q[mt].push(<span class="number">0</span>) : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> nt = ++totq;</span><br><span class="line">dfs2(y, x, <span class="number">1</span>, mt, nt);</span><br><span class="line">ntpos[nt] = q[mt].push(q[nt].top1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[mt].size() &gt; <span class="number">1</span>) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y] || size[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = size[y];</span><br><span class="line">dfs1(y, x), dfs3(nrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">recalc</span><span class="params">(<span class="keyword">int</span> mt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mtpos[mt]) q[rt].erase(mtpos[mt]);</span><br><span class="line"><span class="keyword">if</span>(q[mt].size() &gt; <span class="number">1</span>) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2());</span><br><span class="line"><span class="keyword">else</span> mtpos[mt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dark[x]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mqid[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> mt = mqid[x][i], nt = qid[x][i], pos = qpos[x][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mt == nt) &#123; <span class="comment">// 是中心点</span></span><br><span class="line">q[mt].erase(pos), recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(q[nt].top1() == dist[x][i]) &#123; <span class="comment">// 不是中心点</span></span><br><span class="line">q[nt].erase(pos), q[mt].erase(ntpos[nt]);</span><br><span class="line"><span class="keyword">if</span>(q[nt].size()) ntpos[nt] = q[mt].push(q[nt].top1());</span><br><span class="line">recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> q[nt].erase(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mqid[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> mt = mqid[x][i], nt = qid[x][i], &amp;pos = qpos[x][i], d = dist[x][i]; <span class="comment">// 注意更新pos</span></span><br><span class="line"><span class="keyword">if</span>(mt == nt) &#123;</span><br><span class="line">pos = q[mt].push(<span class="number">0</span>), recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> pre = q[nt].top1();</span><br><span class="line"><span class="keyword">if</span>(d &gt; pre) &#123;</span><br><span class="line">pos = q[nt].push(d);</span><br><span class="line"><span class="keyword">if</span>(pre != -inf) q[mt].erase(ntpos[nt]);</span><br><span class="line">ntpos[nt] = q[mt].push(d);</span><br><span class="line">recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> pos = q[nt].push(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dark[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line">rt = ++totq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dark[i] = <span class="number">1</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = n;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs3(nrot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ins[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readstr(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'G'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q[rt].size() ? q[rt].top1() : <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> readint(x), change(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一颗树，分两类点，一类黑点一类白点，要求支持两种操作，查询当前所有黑点两两间距离的最大值，和改变一个点的
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态点分治" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="点分治" scheme="http://arintaro.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="括号序列" scheme="http://arintaro.com/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2015 接水果</title>
    <link href="http://arintaro.com/2020/01/03/Answer/fruit/"/>
    <id>http://arintaro.com/2020/01/03/Answer/fruit/</id>
    <published>2020-01-03T01:26:59.528Z</published>
    <updated>2020-01-03T01:57:25.053Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定树上一些路径，每个路径有一些权值，构成一个集合。每次询问给出一条路径，回答之前那个集合中为其子路径的所有路径中，权值第$k$大的路径。</p><p>$n, m, q \leq 4\times10^4$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>首先需要转化，<del>看见这个数据范围，我们可以选择用手写$\text{bitset}$水过去。</del></p><p>考虑一个路径什么时候是另一个路径的子路径，正常思路是考虑一个询问，再考虑之前集合中有哪些满足的，可以跑一遍$\text{DFS}$序从而转化成序列上的问题</p><p>显然需要分类讨论，即这个路径是否在树上「转弯」了，已知$x, y$是这条询问路径的两个端点</p><p>当$\text{lca}(x, y) = y$时，需要集合路径的两个端点$u, v$都在这里面，即$dfn[y] \leq dfn[u] \leq dfn[x] \leq dfr[u] \leq dfr[y]$，$v$也同样要满足这些条件，拆下不等式可以发现每个物品有$4$个属性，为两个端点开始和结束的时间戳，外层还有个$kth$，这种问题显然没法维护，<del>整体二分套KDT的优秀做法</del>。</p><p>所以我们需要反过来考虑，考虑离线之后，对集合中的每个路径考虑它可以被哪些询问统计：</p><p>这样对于询问两端点的$\text{lca}$是其中一个的情况，可以直接想象出为「一个端点在$x$的子树中，另一个端点在「把树横过来」$y$的子树中」，第一个条件可以直接用深度较大的节点开始和结束时间戳限制，第二个条件利用补集思想转化为「不在$y \rArr x$路径上的一个节点的子树中」即可；不是的情况，可以直接转化成两个端点子树内，更加简单。</p><p>这样我们发现我们只需要考虑询问两端点的$dfn$，这样就只有两个属性了，问题即转化成「二维平面上，每次选一个矩形，往这个矩形的每个格子中多放一个权值，结束后询问一些点中第$k$大的矩形」，对于外层的$kth$，我们可以直接整体二分去掉，问题变为二维矩形加，单点询问，可以直接$\text{KDT}$解决，但是由于这根本是个离线问题，我们可以用先排序，内层再扫描线维护矩形加的形式，把一个二维问题的两个$\log$分离，从做到$O(nlog^2n)$的复杂度。</p><p>实现时仍然需要注意细节，此问题中的点对是无序的，也就是说，如果不规定顺序把什么样的节点放第一维上，什么样的放第二维上，很可能会导致「在矩形加时，你规定第一维的节点在$x$的子树中，第二维在$y$的子树中，而一个询问它第一维的节点在$y$的子树中，而第二维在$x$的子树中」，就无法统计贡献，直接的想法是在矩形加时两种顺序都加，或者是询问时两种都计算贡献，然而都会多个二倍常数。</p><p>更好的办法是利用本题的性质，本题中的两维矩形加的区间都是「相互不包含的」，这样对于一个询问点$x, y$，如果存在一种顺序使这个矩形可以覆盖到它，那么一定是较小的点对应较小区间，也就是我们可以给它强行规定一个顺序。</p><p>代码写的比较麻烦，听人说封装结构体排序很慢，所以故意规避掉了在整体二分部分的封装，所以代码变得很长，但是速度似乎没怎么提升。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">8</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, totq;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], dfr[maxn], totdfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> size[maxn], deep[maxn], dfa[maxn];</span><br><span class="line"><span class="keyword">int</span> wson[maxn], wtop[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn, size[x] = <span class="number">1</span>, deep[x] = d, dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x);</span><br><span class="line">size[y] += size[x];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">dfr[x] = totdfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">wtop[x] = top;</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == wson[x] || y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_anc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> anc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[anc]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dfa[wtop[x]] == anc) <span class="keyword">return</span> wtop[x];</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wson[anc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bint</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxm], stop; <span class="comment">// 可能有很多次单点增加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">s[++stop] = pos;</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n) c[pos] += nval, pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nval)</span> </span>&#123; add(L, nval), add(R + <span class="number">1</span>, -nval); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pos) res += c[pos], pos -= lowbit(pos);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(stop) &#123;</span><br><span class="line"><span class="keyword">int</span> pos = s[stop--];</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n &amp;&amp; c[pos] != <span class="number">0</span>) c[pos] = <span class="number">0</span>, pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;bint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ht[maxn], toth;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">eco</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lower_bound(ht+<span class="number">1</span>, ht+toth+<span class="number">1</span>, x) - ht;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> px[maxm], py1[maxm], py2[maxm], pval[maxm], pf[maxm], totins;</span><br><span class="line"><span class="keyword">int</span> qx[maxn], qy[maxn], qaim[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1 &gt; x2 || y1 &gt; y2) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x1 &gt; y1) swap(x1, y1), swap(x2, y2);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; x1 &lt;&lt; " " &lt;&lt; x2 &lt;&lt; " " &lt;&lt; y1 &lt;&lt; " " &lt;&lt; y2 &lt;&lt; " " &lt;&lt; nval &lt;&lt; endl;</span></span><br><span class="line">px[++totins] = x1, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x2 != n) px[++totins] = x2 + <span class="number">1</span>, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmpval(x) ((x) &gt; totins ? qx[(x) - totins] : px[(x)])</span></span><br><span class="line"><span class="keyword">return</span> cmpval(i) &lt; cmpval(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1为修改，2为询问</span></span><br><span class="line"><span class="keyword">int</span> q[maxm], qc[maxm];</span><br><span class="line"><span class="keyword">int</span> lq[maxm], lqc[maxm], rq[maxm], rqc[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> suc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) <span class="keyword">if</span>(qc[i] == <span class="number">1</span>) &#123; suc = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(suc || l == r) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) <span class="keyword">if</span>(qc[i] == <span class="number">2</span>) ans[q[i]] = l;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> lc = <span class="number">0</span>, rc = <span class="number">0</span>;</span><br><span class="line">bint.reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = q[i];</span><br><span class="line"><span class="keyword">if</span>(qc[i] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(pval[k] &lt;= mid) bint.add(py1[k], py2[k], pf[k]), lq[++lt] = k, lqc[lt] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> rq[++rt] = k, rqc[rt] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lcnt = bint.ask(qy[k]);</span><br><span class="line"><span class="keyword">if</span>(qaim[k] &gt; lcnt) qaim[k] -= lcnt, rq[++rt] = k, rqc[rt] = <span class="number">2</span>, rc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lq[++lt] = k, lqc[lt] = <span class="number">2</span>, lc = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lc) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lt; i++) q[i + L - <span class="number">1</span>] = lq[i], qc[i + L - <span class="number">1</span>] = lqc[i];</span><br><span class="line"><span class="keyword">if</span>(rc) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=rt; i++) q[L + lt + i - <span class="number">1</span>] = rq[i], qc[L + lt + i - <span class="number">1</span>] = rqc[i];</span><br><span class="line"><span class="keyword">if</span>(lc) solve(l, mid, L, L + lt - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(rc) solve(mid + <span class="number">1</span>, r, L + lt, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(totq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(root, <span class="number">1</span>, <span class="number">0</span>), dfs2(root, root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, nval;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(x), readint(y), readint(nval), ht[i] = nval;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line"><span class="keyword">if</span>(dfn[y] &lt;= dfn[x] &amp;&amp; dfn[x] &lt;= dfr[y]) &#123; <span class="comment">// 链</span></span><br><span class="line">y = ask_anc(x, y);</span><br><span class="line">insert(dfn[x], dfr[x], <span class="number">1</span>, dfn[y] - <span class="number">1</span>, nval);</span><br><span class="line">insert(dfn[x], dfr[x], dfr[y] + <span class="number">1</span>, n, nval);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> insert(dfn[x], dfr[x], dfn[y], dfr[y], nval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ([dfn[x], dfr[x]], [dfn[y], dfr[y]])</span></span><br><span class="line"><span class="comment">// ([dfn[x], dfr[x]], [1, dfn[y] - 1]) ([dfn[x], dfr[x]], [dfn[y] + 1, n])</span></span><br><span class="line">sort(ht+<span class="number">1</span>, ht+m+<span class="number">1</span>), toth = unique(ht+<span class="number">1</span>, ht+m+<span class="number">1</span>) - (ht + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins; ) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + <span class="number">1</span>, res = eco(pval[i]);</span><br><span class="line"><span class="keyword">while</span>(j &lt;= totins &amp;&amp; pval[j] == pval[i]) j++;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; j; i++) pval[i] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totq; i++) &#123;</span><br><span class="line">readint(qx[i]), readint(qy[i]), readint(qaim[i]);</span><br><span class="line">qx[i] = dfn[qx[i]], qy[i] = dfn[qy[i]];</span><br><span class="line"><span class="keyword">if</span>(qx[i] &gt; qy[i]) swap(qx[i], qy[i]);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; qx[i] &lt;&lt; " " &lt;&lt; qy[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins+totq; i++) temp[i] = i;</span><br><span class="line">stable_sort(temp+<span class="number">1</span>, temp+totins+totq+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins+totq; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp[i] &gt; totins) q[i] = temp[i] - totins, qc[i] = <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> q[i] = temp[i], qc[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solve(<span class="number">1</span>, toth, <span class="number">1</span>, totins + totq);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totq; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ht[ans[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定树上一些路径，每个路径有一些权值，构成一个集合。每次询问给出一条路径，回答之前那个集合中为其子路径的所有
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="整体二分" scheme="http://arintaro.com/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
      <category term="扫描线" scheme="http://arintaro.com/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
</feed>
