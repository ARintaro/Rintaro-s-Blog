<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2020-01-05T14:17:47.068Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CQOI2018 异或序列</title>
    <link href="http://arintaro.com/2020/01/05/Answer/xor/"/>
    <id>http://arintaro.com/2020/01/05/Answer/xor/</id>
    <published>2020-01-05T14:13:35.729Z</published>
    <updated>2020-01-05T14:17:47.068Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>懒得写了，<a href="https://www.luogu.com.cn/problem/P4462。" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P4462。</a></p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这题其实比较水，莫队的套路题。</p><p>但是为什么我还要开个页面写一下呢？因为我第一次做的时候没有注意可以直接转化成序列中两个数异或之和，而是分了从左面加入和右面加入两种情况，写的非常麻烦，记录一下教训，转化问题要彻底，不要觉得睿智题转化一下能做就开始写，很可能有更简单的写法。</p><p>对于写法来说，长短无所谓，重要是不容易写挂和写完能跑过去。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], bid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qry</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qry&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; <span class="number">1</span> ? r &lt; b.r : r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lcnt[maxn], rcnt[maxn];</span><br><span class="line">lint nowans = <span class="number">0</span>, ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = arr[i] ^ k, b = arr[i<span class="number">-1</span>] ^ k;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) lcnt[a]++, rcnt[b]++;</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) nowans += f * lcnt[arr[i<span class="number">-1</span>]];</span><br><span class="line"><span class="keyword">else</span> nowans += f * rcnt[arr[i]];</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) lcnt[a]--, rcnt[b]--; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(k);</span><br><span class="line">len = n / <span class="built_in">sqrt</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]), arr[i] ^= arr[i<span class="number">-1</span>], bid[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) readint(q[i].l), readint(q[i].r), q[i].id = i;</span><br><span class="line">sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;懒得写了，&lt;a href=&quot;https://www.luogu.com.cn/problem/P4462。&quot;
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="异或问题" scheme="http://arintaro.com/tags/%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98/"/>
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="莫队" scheme="http://arintaro.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2016 大数</title>
    <link href="http://arintaro.com/2020/01/05/Answer/number/"/>
    <id>http://arintaro.com/2020/01/05/Answer/number/</id>
    <published>2020-01-05T13:35:58.533Z</published>
    <updated>2020-01-05T13:42:19.689Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个由$0-9$中的整数构成的字符串，每次给一个子串，询问这个子串的子串中有多少在一个给定的模数的模意义下为$0$。</p><p>$1 \leq n, m \leq 10^5$，$1 \leq mod \leq 10^9$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>难以维护的信息+可以离线，可以考虑莫队，莫队每次只要以新加入的点为端点产生的贡献即可，于是可以套路的左右两边推一下式子。</p><p>但是由于我最后忘了「由于$\gcd(10, mod) = 1$，模意义的$10$可以随意除下去」，导致最终的式子带着与$10$有关的次幂。更睿智的是我没有提前离散化，而是开了一个哈希表，这导致了我第一次交上去$\text{TLE}$了两个点，最终懒得思考如何优化，在写出数据生成器玄学地调了一下哈希模数和块长以$995ms$成功卡过。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line"><span class="keyword">return</span> s[len] = <span class="string">'\0'</span>, len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mHash_table</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">397751</span>;</span><br><span class="line"><span class="keyword">int</span> head[htmod], nxt[maxn], key[maxn], val[maxn];</span><br><span class="line"><span class="keyword">int</span> totnode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> pii <span class="title">find</span><span class="params">(<span class="keyword">int</span> nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[p]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i] == nkey) <span class="keyword">return</span> mp(val[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = find(nkey).second;</span><br><span class="line"><span class="keyword">if</span>(now != <span class="number">0</span>) &#123; val[now] += nval; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line">key[++totnode] = nkey, val[totnode] = nval;</span><br><span class="line">nxt[totnode] = head[p], head[p] = totnode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;lht, rht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, bid[maxn], mod;</span><br><span class="line"><span class="keyword">int</span> len, arr[maxn];</span><br><span class="line"><span class="keyword">char</span> str[maxn];</span><br><span class="line">lint ans[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qry</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id, l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> qry&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bid[l] ^ bid[b.l] ? l &lt; b.l : (bid[l] &amp; <span class="number">1</span> ? r &lt; b.r : r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> two_five&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn]; <span class="comment">// 结尾为特殊数字的数量</span></span><br><span class="line">lint nowans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) cnt[arr[pos]]++;</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(mod == <span class="number">2</span>) nowans += f * (cnt[<span class="number">0</span>] + cnt[<span class="number">2</span>] + cnt[<span class="number">4</span>] + cnt[<span class="number">6</span>] + cnt[<span class="number">8</span>]);</span><br><span class="line"><span class="keyword">else</span> nowans += f * (cnt[<span class="number">0</span>] + cnt[<span class="number">5</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[pos] == <span class="number">0</span> || (mod == <span class="number">2</span> &amp;&amp; (arr[pos] == <span class="number">2</span> || arr[pos] == <span class="number">4</span> || arr[pos] == <span class="number">6</span> || arr[pos] == <span class="number">8</span>))</span><br><span class="line">|| (mod == <span class="number">5</span> &amp;&amp; arr[pos] == <span class="number">5</span>)) nowans += f * (pos - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) cnt[arr[pos]]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = str[i] - <span class="string">'0'</span>;</span><br><span class="line">l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> others&#123;</span><br><span class="line"></span><br><span class="line">lint nowans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> divpow[maxn], div10;</span><br><span class="line"><span class="comment">// 在左边加 x * pow10[len] + y = 0</span></span><br><span class="line"><span class="comment">// 在右边加 y * 10 + x = 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> f, <span class="keyword">bool</span> dir)</span> </span>&#123; <span class="comment">// 0左边 1右边</span></span><br><span class="line"><span class="keyword">int</span> a = (lint)arr[pos] * divpow[pos] % mod, b = (lint)arr[pos - <span class="number">1</span>] * divpow[pos - <span class="number">1</span>] % mod;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">1</span>) lht.add(a, <span class="number">1</span>), rht.add(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(dir == <span class="number">0</span>) nowans += f * lht.find(b).first; <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">else</span> nowans += f * rht.find(a).first;</span><br><span class="line"><span class="keyword">if</span>(f == <span class="number">-1</span>) lht.add(a, <span class="number">-1</span>), rht.add(b, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">divpow[<span class="number">0</span>] = <span class="number">1</span>, div10 = qpow(<span class="number">10</span>, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) divpow[i] = (lint)divpow[i<span class="number">-1</span>] * div10 % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = ((lint)arr[i<span class="number">-1</span>] * <span class="number">10</span> + str[i] - <span class="string">'0'</span>) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].l;</span><br><span class="line">move(l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(l &lt; q[i].l) move(l++, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(l &gt; q[i].l) move(--l, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(r &lt; q[i].r) move(++r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(r &gt; q[i].r) move(r--, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">ans[q[i].id] = nowans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> t = clock();</span><br><span class="line"></span><br><span class="line">readint(mod), n = readstr(str + <span class="number">1</span>);</span><br><span class="line">readint(m);</span><br><span class="line">len = (n &gt; <span class="number">5e4</span> ? <span class="number">600</span> : <span class="built_in">sqrt</span>(n));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(q[i].l), readint(q[i].r), q[i].id = i;</span><br><span class="line">bid[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>, q+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mod == <span class="number">2</span> || mod == <span class="number">5</span>) two_five::work();</span><br><span class="line"><span class="keyword">else</span> others::work();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个由$0-9$中的整数构成的字符串，每次给一个子串，询问这个子串的子串中有多少在一个给定的模数的模意义
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="莫队" scheme="http://arintaro.com/tags/%E8%8E%AB%E9%98%9F/"/>
    
      <category term="剩余系" scheme="http://arintaro.com/tags/%E5%89%A9%E4%BD%99%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2010 弹飞绵羊</title>
    <link href="http://arintaro.com/2020/01/05/Answer/sheep/"/>
    <id>http://arintaro.com/2020/01/05/Answer/sheep/</id>
    <published>2020-01-05T10:08:20.711Z</published>
    <updated>2020-01-05T10:24:43.946Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个序列$a_i$，每次给序列中的一个位置$p$，每次跳到$p + a_p$，直到跳出整个序列为止，问需要跳多少次，要求支持$a_i$单点修改。</p><p>$1 \leq n, m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>此题正解$\text{LCT}$，这里说一下分块做法。</p><p>显然我们需要利用类似「路径压缩」的思想，来平衡修改和查询的复杂度，像并查集一样直接压到终点查询$O(1)$，修改自闭，所以考虑根号平衡。</p><p>显然的想法是对每个点只压$len$步，修改一个点时重构到它距离小于$len$的节点，然而复杂度是错的，弄个菊花图反复修改菊花中心就会自闭，似乎加一些剪枝或者懒惰标记可以令复杂度正确，但是非常麻烦。</p><p>看了题解发现是直接按序列分块，每次只要保证至少跳到下一个块即可，这样修改时就比较方便，由于规定了至少跳到下一个块，这样它的前驱节点只能跟它在同一块中，于是暴力重构这个块即可。</p><p>似乎是这种类似带修改「跳节点」问题的通用分块法，按拓扑序分块一下，确保转移能至少能转移到下一块即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> len, tot;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], bnxt[maxn], bcnt[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bl(x) ((x - 1) * len + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> br(x) ((x) == tot ? n : (x) * len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bid(x) (((x) - 1) / len + 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=br(t); i&gt;=bl(t); i--) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + arr[i];</span><br><span class="line"><span class="keyword">if</span>(j &gt; br(t)) bnxt[i] = j, bcnt[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> bnxt[i] = bnxt[j], bcnt[i] = bcnt[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">len = <span class="built_in">sqrt</span>(n), tot = <span class="built_in">ceil</span>((<span class="keyword">double</span>)n / len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) build(i);</span><br><span class="line"></span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">int</span> ins, x;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) &#123;</span><br><span class="line">readint(x), x++;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n) res += bcnt[x], x = bnxt[x];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">readint(x), x++, readint(arr[x]);</span><br><span class="line">build(bid(x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一个序列$a_i$，每次给序列中的一个位置$p$，每次跳到$p + a_p$，直到跳出整个序列为止，问需
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="分块" scheme="http://arintaro.com/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="LCT" scheme="http://arintaro.com/tags/LCT/"/>
    
      <category term="转移分块" scheme="http://arintaro.com/tags/%E8%BD%AC%E7%A7%BB%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>Luogu 3676 小清新数据结构题</title>
    <link href="http://arintaro.com/2020/01/04/Answer/free/"/>
    <id>http://arintaro.com/2020/01/04/Answer/free/</id>
    <published>2020-01-04T14:48:21.098Z</published>
    <updated>2020-01-04T15:00:38.973Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>在很久很久以前，有一棵$n$个点的树，每个点有一个点权。</p><p>现在有$m$次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。</p><p>$1 \leq n \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先想如何不换根带修改地做出答案。</p><p>一开始想了很久如何维护原权值做出来，想不出来，遂翻题解。</p><p>发现如果在数据结构上直接维护原权值，不容易计算答案，发现只有单点修改，那不妨记录每个点子树的点权和，修改一个点时只需要修改它到根链上的部分，问题转化成区间修改，区间询问平方和，显然能做。</p><p>再想如何换根，发现树中有很大一部分的答案是不变的，变的答案只有这个点到根这部分，除它自己单独计算外，发现这部分中的其他点的贡献可以通过整体减去局部后平方计算出来，由于整体和是个定值，平方后打开括号可以消除其影响，从而用之前维护的信息分别计算。</p><p>感觉这题不难，但是我还是翻了题解+调了很久，我在打开$\sum_{1 \leq i \leq n}{(a_i + x)^2}$时，把它变成了$\sum{a_i^2} + 2x\sum{a_i} + x^2$，这问题不是我第一次犯了，以后要注意。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn], dfn_val[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lson[maxn], rson[maxn], sum[maxn], ladd[maxn];</span><br><span class="line">lint sum_pow[maxn];</span><br><span class="line"><span class="keyword">int</span> root, totnode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">sum[p] = sum[lson[p]] + sum[rson[p]];</span><br><span class="line">sum_pow[p] = sum_pow[lson[p]] + sum_pow[rson[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ladd[p] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">sum_pow[lson[p]] += (lint)<span class="number">2</span> * ladd[p] * sum[lson[p]] + (lint)(mid - l + <span class="number">1</span>) * ladd[p] * ladd[p];</span><br><span class="line">sum_pow[rson[p]] += (lint)<span class="number">2</span> * ladd[p] * sum[rson[p]] + (lint)(r - mid) * ladd[p] * ladd[p];</span><br><span class="line">sum[lson[p]] += (mid - l + <span class="number">1</span>) * ladd[p], sum[rson[p]] += (r - mid) * ladd[p];</span><br><span class="line">ladd[lson[p]] += ladd[p], ladd[rson[p]] += ladd[p];</span><br><span class="line">ladd[p] = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">p = ++totnode;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; sum[p] = dfn_val[l], sum_pow[p] = (lint)sum[p] * sum[p]; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(lson[p], l, mid), build(rson[p], mid + <span class="number">1</span>, r);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">sum_pow[p] += (lint)<span class="number">2</span> * x * sum[p] + (lint)(r - l + <span class="number">1</span>) * x * x, sum[p] += (r - l + <span class="number">1</span>) * x;</span><br><span class="line">ladd[p] += x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) add(lson[p], l, mid, L, R, x);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) add(rson[p], mid + <span class="number">1</span>, r, L, R, x);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>&#123; add(root, <span class="number">1</span>, n, L, R, x); &#125;</span><br><span class="line"><span class="function">lint <span class="title">ask_sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[p];</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res += ask_sum(lson[p], l, mid, L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res += ask_sum(rson[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask_sum</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> ask_sum(root, <span class="number">1</span>, n, L, R); &#125;</span><br><span class="line"><span class="function">lint <span class="title">ask_pow</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum_pow[p];</span><br><span class="line">pushdown(p, l, r);</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res += ask_pow(lson[p], l, mid, L, R);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res += ask_pow(rson[p], mid + <span class="number">1</span>, r, L, R);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask_pow</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="keyword">return</span> ask_pow(root, <span class="number">1</span>, n, L, R); &#125;</span><br><span class="line">&#125;smt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> size[maxn], deep[maxn], dfa[maxn];</span><br><span class="line"><span class="keyword">int</span> wson[maxn], wtop[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], dfr[maxn], totdfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> color[maxn], sum[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa, <span class="keyword">int</span> nc)</span> </span>&#123;</span><br><span class="line">deep[x] = d, dfa[x] = fa, size[x] = <span class="number">1</span>, sum[x] = arr[x];</span><br><span class="line">color[x] = nc;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x, x == root ? y : nc);</span><br><span class="line">size[x] += size[y], sum[x] += sum[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn, wtop[x] = top, dfn_val[totdfn] = sum[x];</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == wson[x] || y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, y);</span><br><span class="line">&#125;</span><br><span class="line">dfr[x] = totdfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先累加不在它到根链上点的总贡献 和它和它子树内部的贡献，用总体权值-链上权值</span></span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == root) <span class="keyword">return</span> smt.ask_pow(<span class="number">1</span>, n);</span><br><span class="line">lint sumr = smt.ask_sum(dfn[root], dfn[root]), now = <span class="number">0</span>;</span><br><span class="line">lint res = smt.ask_pow(<span class="number">1</span>, n) + (deep[x] - <span class="number">1</span>) * sumr * sumr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[color[x]]) &#123;</span><br><span class="line">now += smt.ask_sum(dfn[wtop[x]], dfn[x]);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line">now += smt.ask_sum(dfn[color[x]], dfn[x]);</span><br><span class="line"></span><br><span class="line">res -= <span class="number">2</span> * sumr * now;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d = nval - arr[x];</span><br><span class="line">arr[x] = nval;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[root]) &#123;</span><br><span class="line">smt.add(dfn[wtop[x]], dfn[x], d);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line">smt.add(dfn[root], dfn[x], d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">dfs1(root, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), dfs2(root, root);</span><br><span class="line"></span><br><span class="line">smt.build(smt.root, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ins, x, y;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) readint(x), readint(y), change(x, y);</span><br><span class="line"><span class="keyword">else</span> readint(x), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ask(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;在很久很久以前，有一棵$n$个点的树，每个点有一个点权。&lt;/p&gt;
&lt;p&gt;现在有$m$次操作，每次操作是修改一
      
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
      <category term="线段树" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树链剖分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2016 美味</title>
    <link href="http://arintaro.com/2020/01/04/Answer/meal/"/>
    <id>http://arintaro.com/2020/01/04/Answer/meal/</id>
    <published>2020-01-04T12:07:07.179Z</published>
    <updated>2020-01-04T12:18:30.941Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一个序列$a_j$，每次询问给定$b_i$，$x_i$，$L, R$，要求对于$j \in[L, R]$，使$b_i \ xor\ (x_i + a_j)$最大</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>首先暴力肯定不行，不暴力又发现$x_i + a_j$对于$xor$结果的影响并不容易计算。</p><p>一开始一直考虑怎么在可持久化$Trie$上做，然后发现完全做不了，<del>（对每个$Trie$节点维护一个可持久化平衡树</del>。</p><p>题解是考虑一个类似过程，与位运算有关的问题一般要拆位考虑，对每一位考虑，判断这一位能否选与$b_i$这位不同的数字。</p><p>关键在于这个判断能否选的过程，判断是否存在一个$x_i + a_j$使得这位为$0$或$1$，与位运算不同，我一开始考虑这个东西怎么按位拆开判断，然而根本不用，对于加法和减法，最简单的约束条件就是转化成不等式，考虑使得这位$0$或这位为$1$的范围，不妨归纳地考虑，考虑之前的位的$x_i + a_j$已经选好设为$pre$。下面考虑这位$t$要选$0$的情况，其中$*$是前面的位，显然上面是下界，下面是上界。</p><center> <strong>**</strong>000000 </center><br><center> <strong>**</strong>011111 </center><p>雾，所以我们可以列出$x_i + a_j \in [pre, pre + (1 &lt;&lt; t) - 1]$这个不等式，把$x_i$移过去即消除了询问的影响，加上$[L, R]$，即转化成一个二维平面上的偏序问题，可以直接解决。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mlog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> t = x;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)((lint&amp;)t &gt;&gt; <span class="number">52</span> &amp; <span class="number">63</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxv = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[maxnode], rson[maxnode], sum[maxnode];</span><br><span class="line"><span class="keyword">int</span> root[maxn], totnode;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">p = ++totnode;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; sum[p] = sum[pre] + nval; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid) rson[p] = rson[pre], add(lson[p], lson[pre], l, mid, pos, nval);</span><br><span class="line"><span class="keyword">else</span> lson[p] = lson[pre], add(rson[p], rson[pre], mid + <span class="number">1</span>, r, pos, nval);</span><br><span class="line">sum[p] = sum[lson[p]] + sum[rson[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> sum[p] - sum[pre];</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid &amp;&amp; ask(lson[p], lson[pre], l, mid, L, R)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid &amp;&amp; ask(rson[p], rson[pre], mid + <span class="number">1</span>, r, L, R)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ask(root[R], root[L<span class="number">-1</span>], <span class="number">0</span>, maxv, max(l, <span class="number">0</span>), min(r, maxv));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(x), add(root[i], root[i<span class="number">-1</span>], <span class="number">0</span>, maxv, x, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b, L, R;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(b), readint(x), readint(L), readint(R);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 找 a + x</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=maxd; t&gt;=<span class="number">0</span>; t--) &#123;</span><br><span class="line"><span class="keyword">if</span>((b &gt;&gt; t) &amp; <span class="number">1</span>) &#123; <span class="comment">// a + x这位需要为0</span></span><br><span class="line"><span class="comment">// *****00000</span></span><br><span class="line"><span class="comment">// *****01111</span></span><br><span class="line"><span class="comment">// a + x \in [pre, pre + (1 &lt;&lt; t) - 1]</span></span><br><span class="line"><span class="keyword">bool</span> suc = ask(L, R, pre - x, pre + (<span class="number">1</span> &lt;&lt; t) - <span class="number">1</span> - x);</span><br><span class="line"><span class="keyword">if</span>(suc) ans += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line"><span class="keyword">else</span> pre += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// a + x这为需要为1</span></span><br><span class="line"><span class="comment">// ****10000</span></span><br><span class="line"><span class="comment">// ****11111</span></span><br><span class="line"><span class="keyword">bool</span> suc = ask(L, R, pre + (<span class="number">1</span> &lt;&lt; t) - x, pre + (<span class="number">1</span> &lt;&lt; (t + <span class="number">1</span>)) - <span class="number">1</span> - x);</span><br><span class="line"><span class="keyword">if</span>(suc) ans += (<span class="number">1</span> &lt;&lt; t), pre += (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给一个序列$a_j$，每次询问给定$b_i$，$x_i$，$L, R$，要求对于$j \in[L, R]$，
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="可持久化数据结构" scheme="http://arintaro.com/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="异或问题" scheme="http://arintaro.com/tags/%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2015 开店</title>
    <link href="http://arintaro.com/2020/01/04/Answer/shop/"/>
    <id>http://arintaro.com/2020/01/04/Answer/shop/</id>
    <published>2020-01-04T11:05:48.020Z</published>
    <updated>2020-01-04T11:15:25.509Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给一棵带边权和点权的树，每次询问一个点到所有点权范围为$[L, R]$的点的距离和，强制在线。</p><p>$n \leq 1.5 \times 10^5$，$m \leq 2 \times 10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>显然可以建出点分树，每次查询即可，如果可以离线就点分治就行。</p><p>重点说一下树剖的思路，这题显然是套了一个查点权范围的壳，以卡掉一些做法。所以先考虑不带点权怎么做，推一下式子发现重点是维护$\sum_{1 \leq j \leq n}{d_{\text{lca}(i, j)}}$，其中$d$表示某个节点到根的距离，从题解中学到一种做法，对每个点考虑它的贡献为「这两个点从到根的路径交集」，所以我们可以先对所有的$j$覆盖一次它到根的路径，查询时只查询问点到根就行。</p><p>然而树剖空间复杂度是错的，不少主席树的题空间两个$\log$，跑到上界大概都需要几G的空间，然而没人卡..</p><p>下面的代码是点分树的，由于我写的时候大脑短路，觉得好像要修改点权，就敲了个平衡树。。实际上不带修用$\text{vector}$即可，但是这样复杂度是一样，常数不太好。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, lint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1.5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxa;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> ch[maxnode][<span class="number">2</span>], size[maxnode], key[maxnode], val[maxnode], totnode;</span><br><span class="line"><span class="keyword">static</span> lint sum[maxnode];</span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = ch[x][c];</span><br><span class="line">ch[x][c] = ch[y][c ^ <span class="number">1</span>], ch[y][c ^ <span class="number">1</span>] = x;</span><br><span class="line">size[y] = size[x], sum[y] = sum[x];</span><br><span class="line">size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">sum[x] = sum[ch[x][<span class="number">0</span>]] + sum[ch[x][<span class="number">1</span>]] + val[x];</span><br><span class="line">x = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size[ch[ch[x][c]][c]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size[ch[ch[x][c]][c ^ <span class="number">1</span>]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(ch[x][c], c ^ <span class="number">1</span>), rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">maintain(ch[x][<span class="number">0</span>], <span class="number">0</span>), maintain(ch[x][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">maintain(x, <span class="number">0</span>), maintain(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">size[++totnode] = <span class="number">1</span>, key[totnode] = nkey, val[totnode] = sum[totnode] = nval;</span><br><span class="line"><span class="keyword">return</span> totnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; p = totnode; <span class="keyword">return</span>; &#125;</span><br><span class="line">size[p]++, sum[p] += val[totnode];</span><br><span class="line">insert(ch[p][key[totnode] &gt;= key[p]]);</span><br><span class="line">maintain(p, key[totnode] &gt;= key[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123; newnode(nkey, nval), insert(root); &#125;</span><br><span class="line"><span class="comment">// 第一维cnt，第二维sum</span></span><br><span class="line"><span class="function">pii <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(nkey &gt;= key[p]) &#123;</span><br><span class="line">pii res = getsum(ch[p][<span class="number">1</span>], nkey);</span><br><span class="line">res.first += size[ch[p][<span class="number">0</span>]] + <span class="number">1</span>, res.second += sum[ch[p][<span class="number">0</span>]] + val[p];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> getsum(ch[p][<span class="number">0</span>], nkey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pii <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">pii rt = getsum(root, R), lt = getsum(root, L - <span class="number">1</span>);</span><br><span class="line">rt.first -= lt.first, rt.second -= lt.second;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> SBT::ch[maxnode][<span class="number">2</span>], SBT::size[maxnode], SBT::key[maxnode], SBT::val[maxnode], SBT::totnode;</span><br><span class="line">lint SBT::sum[maxnode];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> rmax, nrot, ntot;</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x), size[x] += size[y];</span><br><span class="line">nmax = max(nmax, size[y]);</span><br><span class="line">&#125;</span><br><span class="line">nmax = max(nmax, ntot - size[x]);</span><br><span class="line"><span class="keyword">if</span>(nmax &lt; rmax) rmax = nmax, nrot = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totbst = <span class="number">0</span>;</span><br><span class="line">SBT bst[maxnode];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prt[maxn], pdis[maxn], bstid[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rtbst[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">prt[x].push_back(nrot), pdis[x].push_back(d), bstid[x].push_back(totbst);</span><br><span class="line">bst[totbst].insert(arr[x], d), size[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, d + ew[i], x);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cerr &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">prt[x].push_back(x), pdis[x].push_back(<span class="number">0</span>), bstid[x].push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">rtbst[x].push_back(++totbst), dfs2(y, ew[i], x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y] || size[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = size[y];</span><br><span class="line">dfs1(y, x), dfs3(nrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prt[x].size(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prt[x][i] == x) &#123; <span class="comment">// 为根</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;rtbst[x].size(); j++) res += bst[rtbst[x][j]].ask(L, R).second;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不为根</span></span><br><span class="line"><span class="keyword">int</span> rt = prt[x][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;rtbst[rt].size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(rtbst[rt][j] == bstid[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">pii now = bst[rtbst[rt][j]].ask(L, R);</span><br><span class="line">res += (lint)now.first * pdis[x][i] + now.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= arr[rt] &amp;&amp; arr[rt] &lt;= R) res += pdis[x][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(maxa);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = n;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs3(nrot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, a, b;</span><br><span class="line">lint res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(x), readint(a), readint(b);</span><br><span class="line"><span class="keyword">int</span> l = (a + res) % maxa, r = (b + res) % maxa;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) swap(l, r);</span><br><span class="line">res = ask(x, l, r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line"><span class="comment">// res = 0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给一棵带边权和点权的树，每次询问一个点到所有点权范围为$[L, R]$的点的距离和，强制在线。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="动态点分治" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2007 捉迷藏</title>
    <link href="http://arintaro.com/2020/01/04/Answer/hide/"/>
    <id>http://arintaro.com/2020/01/04/Answer/hide/</id>
    <published>2020-01-04T09:08:14.865Z</published>
    <updated>2020-01-04T09:30:54.099Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一颗树，分两类点，一类黑点一类白点，要求支持两种操作，查询当前所有黑点两两间距离的最大值，和改变一个点的颜色。</p><p>$1 \leq n \leq 2000$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>点分治做法不提了，大概是动态模拟点分治的过程，开很多个堆维护答案，代码见下面。</p><p>括号序列做法难以想到，技巧性强，代码比点分治做法短很多，但是也不是很好写，非常容易写挂。</p><p>括号序列是像$(1(2)(3))$这样的东西，这表示它遍历点$1$，然后依次遍历了$2,3$两个儿子。</p><p>首先有一个结论，对于边权为$1$的树，跑一个它的括号序，两点间的距离即为对应括号序列子段不匹配的括号数。这个显然可以用线段树维护，类似摩尔投票法？但是一般我们求距离都用$LCA$，跑的比线段树快多了，所以这个结论就比较鸡肋。</p><p>但是本题中，我们考虑如何动态维护两个黑点间的最大距离，也就是在分治结构上，必须以较低代价合并左右两个儿子的信息，就能利用线段树维护答案。</p><p>显然在一次合并信息中，我们只需要考虑跨区间的答案，不妨对一段区间设$(x, y)$，其中$x$表示它未匹配的右括号数量，$y$表示左括号的。</p><p>显然可以快速合并这两个区间，并得到新区间的答案，大概是类似$x_l + y_l - x_r + y_r$或$x_l - y_l + x_r + y_r$，对应两种$y_l$和$x_r$大小关系不同的情况，但是问题是：在分治结构上，左边和右边都各有$O(n)$个区间，暴力匹配是$O(n^2)$，拆拆式子用单调队列似乎可以做到$O(n)$？这对不修改是可以接受的，但是对于修改后合并信息完全不行，单次修改的复杂度会变成$O(n)$。</p><p>所以，要想快速合并信息，我们必然要拆开左右两边的信息，使其独立，我们就可以分别找两面$\max$，然后简单的相加从而合并信息。</p><p>问题在于合并信息时，由于$y_l$和$x_r$的大小关系，会产生不同的贡献。容易想到是否存在一种计算方式使得不合法的信息不会被统计。</p><p>简单来说，我们发现一个区间合并信息对答案的贡献只有三种，即$x + y$，$x - y$， $y - x$。可以分别求出它们在各个情况下的最大值，然后直接相加合并。正确性是由于：考虑$x_l + y_l - x_r + y_r$的情况，这代表$y_l &gt; x_r$，如果存在一个$y_l &lt; x_r$，并且这样的式子成为了我们的答案，就会对答案造成影响，但是在这种情况下$x_l - y_l + x_r + y_r$显然会比它更大，只要我们考虑了这种情况，不合法的情况就不会影响答案。</p><p>这种「虽然当前统计了不合法的方案，但是在取最优的过程中不会影响答案」的方法，降低了限制条件的要求，从而可以在线段树上高效维护。</p><p>我们可以直接对于不合法的位置，把它节点三种答案贡献都设为$-inf$，即可简单的只求黑点间的答案，注意这个$inf$可能会被多次相加相减，因此千万不要开太大，比$maxn$大即可。</p><p>这种方法的代码在我写出来后，没过样例，于是准备拍个小数据调一下，把之前的数据生成器和暴力复制过来后，一不小心把之前的代码也复制过来了，导致这份代码被覆盖，也就是说：丢了。。丢了。。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch -<span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = maxn * maxd;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> son[maxnode], bro[maxnode], fa[maxnode], val[maxnode];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s[maxnode], stop, totnode;</span><br><span class="line"><span class="keyword">int</span> root, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span>) <span class="keyword">return</span> x + y;</span><br><span class="line"><span class="keyword">if</span>(val[x] &gt; val[y]) swap(x, y); <span class="comment">// 大根堆</span></span><br><span class="line">bro[x] = son[y], fa[son[y]] = x;</span><br><span class="line">son[y] = x, fa[x] = y;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">fa[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span> || bro[x] == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> y = bro[x], p = bro[y];</span><br><span class="line">bro[x] = bro[y] = fa[y] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> merge(merge(x, y), merge(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = stop ? s[stop--] : ++totnode;</span><br><span class="line">son[p] = bro[p] = fa[p] = <span class="number">0</span>, val[p] = nval;</span><br><span class="line">root = merge(root, p), cnt++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> root ? val[root] : -inf; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top2</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> bro[p] ? max(top2(bro[p]), val[p]) : val[p]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">top2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> son[root] ? top2(son[root]) : -inf;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; s[++stop] = root, root = merge(son[root]), cnt--; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x == root) &#123; pop(); <span class="keyword">return</span>; &#125;</span><br><span class="line">s[++stop] = x, cnt--;</span><br><span class="line"><span class="keyword">int</span>&amp; p = son[fa[x]] == x ? son[fa[x]] : bro[fa[x]];</span><br><span class="line">p = bro[x], fa[p] = fa[x];</span><br><span class="line">root = merge(root, merge(son[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cnt; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">print(bro[p]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, val[p]), print(son[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"print: "</span>), print(root), <span class="built_in">putchar</span>(<span class="string">'\n'</span>); &#125;</span><br><span class="line">&#125;q[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::son[maxnode], Heap::bro[maxnode], Heap::fa[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::val[maxnode];</span><br><span class="line"><span class="keyword">int</span> Heap::s[maxnode], Heap::stop, Heap::totnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="keyword">int</span> rmax = <span class="number">0</span>, nrot = <span class="number">0</span>, ntot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> nmax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">nmax = max(nmax, size[y]);</span><br><span class="line">&#125;</span><br><span class="line">nmax = max(nmax, ntot - size[x]);</span><br><span class="line"><span class="keyword">if</span>(nmax &lt; rmax) rmax = nmax, nrot = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dark[maxn];</span><br><span class="line"><span class="keyword">int</span> totq, rt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mqid[maxn], qid[maxn], qpos[maxn], dist[maxn];</span><br><span class="line"><span class="keyword">int</span> ntpos[maxnode], mtpos[maxnode], mtlast[maxnode];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> d, <span class="keyword">int</span> mt, <span class="keyword">int</span> nt)</span> </span>&#123;</span><br><span class="line">dist[x].push_back(d), mqid[x].push_back(mt), qid[x].push_back(nt);</span><br><span class="line">qpos[x].push_back(dark[x] ? q[nt].push(d) : <span class="number">0</span>);</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa || vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, x, d + <span class="number">1</span>, mt, nt);</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明主堆</span></span><br><span class="line"><span class="keyword">int</span> mt = ++totq;</span><br><span class="line">mqid[x].push_back(mt), qid[x].push_back(mt), dist[x].push_back(<span class="number">0</span>);</span><br><span class="line">qpos[x].push_back(dark[x] ? q[mt].push(<span class="number">0</span>) : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> nt = ++totq;</span><br><span class="line">dfs2(y, x, <span class="number">1</span>, mt, nt);</span><br><span class="line">ntpos[nt] = q[mt].push(q[nt].top1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q[mt].size() &gt; <span class="number">1</span>) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(vis[y] || size[y] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = size[y];</span><br><span class="line">dfs1(y, x), dfs3(nrot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">recalc</span><span class="params">(<span class="keyword">int</span> mt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mtpos[mt]) q[rt].erase(mtpos[mt]);</span><br><span class="line"><span class="keyword">if</span>(q[mt].size() &gt; <span class="number">1</span>) mtpos[mt] = q[rt].push(q[mt].top1() + q[mt].top2());</span><br><span class="line"><span class="keyword">else</span> mtpos[mt] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dark[x]) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mqid[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> mt = mqid[x][i], nt = qid[x][i], pos = qpos[x][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mt == nt) &#123; <span class="comment">// 是中心点</span></span><br><span class="line">q[mt].erase(pos), recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(q[nt].top1() == dist[x][i]) &#123; <span class="comment">// 不是中心点</span></span><br><span class="line">q[nt].erase(pos), q[mt].erase(ntpos[nt]);</span><br><span class="line"><span class="keyword">if</span>(q[nt].size()) ntpos[nt] = q[mt].push(q[nt].top1());</span><br><span class="line">recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> q[nt].erase(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mqid[x].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> mt = mqid[x][i], nt = qid[x][i], &amp;pos = qpos[x][i], d = dist[x][i]; <span class="comment">// 注意更新pos</span></span><br><span class="line"><span class="keyword">if</span>(mt == nt) &#123;</span><br><span class="line">pos = q[mt].push(<span class="number">0</span>), recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> pre = q[nt].top1();</span><br><span class="line"><span class="keyword">if</span>(d &gt; pre) &#123;</span><br><span class="line">pos = q[nt].push(d);</span><br><span class="line"><span class="keyword">if</span>(pre != -inf) q[mt].erase(ntpos[nt]);</span><br><span class="line">ntpos[nt] = q[mt].push(d);</span><br><span class="line">recalc(mt);</span><br><span class="line">&#125; <span class="keyword">else</span> pos = q[nt].push(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dark[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line">rt = ++totq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) dark[i] = <span class="number">1</span>;</span><br><span class="line">rmax = maxn, nrot = <span class="number">0</span>, ntot = n;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs3(nrot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ins[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readstr(ins);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'G'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, q[rt].size() ? q[rt].top1() : <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> readint(x), change(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一颗树，分两类点，一类黑点一类白点，要求支持两种操作，查询当前所有黑点两两间距离的最大值，和改变一个点的
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://arintaro.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="动态点分治" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="点分治" scheme="http://arintaro.com/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    
      <category term="括号序列" scheme="http://arintaro.com/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2015 接水果</title>
    <link href="http://arintaro.com/2020/01/03/Answer/fruit/"/>
    <id>http://arintaro.com/2020/01/03/Answer/fruit/</id>
    <published>2020-01-03T01:26:59.528Z</published>
    <updated>2020-01-03T01:57:25.053Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定树上一些路径，每个路径有一些权值，构成一个集合。每次询问给出一条路径，回答之前那个集合中为其子路径的所有路径中，权值第$k$大的路径。</p><p>$n, m, q \leq 4\times10^4$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>首先需要转化，<del>看见这个数据范围，我们可以选择用手写$\text{bitset}$水过去。</del></p><p>考虑一个路径什么时候是另一个路径的子路径，正常思路是考虑一个询问，再考虑之前集合中有哪些满足的，可以跑一遍$\text{DFS}$序从而转化成序列上的问题</p><p>显然需要分类讨论，即这个路径是否在树上「转弯」了，已知$x, y$是这条询问路径的两个端点</p><p>当$\text{lca}(x, y) = y$时，需要集合路径的两个端点$u, v$都在这里面，即$dfn[y] \leq dfn[u] \leq dfn[x] \leq dfr[u] \leq dfr[y]$，$v$也同样要满足这些条件，拆下不等式可以发现每个物品有$4$个属性，为两个端点开始和结束的时间戳，外层还有个$kth$，这种问题显然没法维护，<del>整体二分套KDT的优秀做法</del>。</p><p>所以我们需要反过来考虑，考虑离线之后，对集合中的每个路径考虑它可以被哪些询问统计：</p><p>这样对于询问两端点的$\text{lca}$是其中一个的情况，可以直接想象出为「一个端点在$x$的子树中，另一个端点在「把树横过来」$y$的子树中」，第一个条件可以直接用深度较大的节点开始和结束时间戳限制，第二个条件利用补集思想转化为「不在$y \rArr x$路径上的一个节点的子树中」即可；不是的情况，可以直接转化成两个端点子树内，更加简单。</p><p>这样我们发现我们只需要考虑询问两端点的$dfn$，这样就只有两个属性了，问题即转化成「二维平面上，每次选一个矩形，往这个矩形的每个格子中多放一个权值，结束后询问一些点中第$k$大的矩形」，对于外层的$kth$，我们可以直接整体二分去掉，问题变为二维矩形加，单点询问，可以直接$\text{KDT}$解决，但是由于这根本是个离线问题，我们可以用先排序，内层再扫描线维护矩形加的形式，把一个二维问题的两个$\log$分离，从做到$O(nlog^2n)$的复杂度。</p><p>实现时仍然需要注意细节，此问题中的点对是无序的，也就是说，如果不规定顺序把什么样的节点放第一维上，什么样的放第二维上，很可能会导致「在矩形加时，你规定第一维的节点在$x$的子树中，第二维在$y$的子树中，而一个询问它第一维的节点在$y$的子树中，而第二维在$x$的子树中」，就无法统计贡献，直接的想法是在矩形加时两种顺序都加，或者是询问时两种都计算贡献，然而都会多个二倍常数。</p><p>更好的办法是利用本题的性质，本题中的两维矩形加的区间都是「相互不包含的」，这样对于一个询问点$x, y$，如果存在一种顺序使这个矩形可以覆盖到它，那么一定是较小的点对应较小区间，也就是我们可以给它强行规定一个顺序。</p><p>代码写的比较麻烦，听人说封装结构体排序很慢，所以故意规避掉了在整体二分部分的封装，所以代码变得很长，但是速度似乎没怎么提升。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">8</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, totq;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], dfr[maxn], totdfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> size[maxn], deep[maxn], dfa[maxn];</span><br><span class="line"><span class="keyword">int</span> wson[maxn], wtop[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn, size[x] = <span class="number">1</span>, deep[x] = d, dfa[x] = fa;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, d + <span class="number">1</span>, x);</span><br><span class="line">size[y] += size[x];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">dfr[x] = totdfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">wtop[x] = top;</span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x], top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == wson[x] || y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_anc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> anc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[anc]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dfa[wtop[x]] == anc) <span class="keyword">return</span> wtop[x];</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wson[anc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bint</span>&#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x) &amp; -(x))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxm], stop; <span class="comment">// 可能有很多次单点增加</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">s[++stop] = pos;</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n) c[pos] += nval, pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> nval)</span> </span>&#123; add(L, nval), add(R + <span class="number">1</span>, -nval); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pos) res += c[pos], pos -= lowbit(pos);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(stop) &#123;</span><br><span class="line"><span class="keyword">int</span> pos = s[stop--];</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n &amp;&amp; c[pos] != <span class="number">0</span>) c[pos] = <span class="number">0</span>, pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;bint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ht[maxn], toth;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">eco</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lower_bound(ht+<span class="number">1</span>, ht+toth+<span class="number">1</span>, x) - ht;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> px[maxm], py1[maxm], py2[maxm], pval[maxm], pf[maxm], totins;</span><br><span class="line"><span class="keyword">int</span> qx[maxn], qy[maxn], qaim[maxn], ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y1, <span class="keyword">int</span> y2, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1 &gt; x2 || y1 &gt; y2) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x1 &gt; y1) swap(x1, y1), swap(x2, y2);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; x1 &lt;&lt; " " &lt;&lt; x2 &lt;&lt; " " &lt;&lt; y1 &lt;&lt; " " &lt;&lt; y2 &lt;&lt; " " &lt;&lt; nval &lt;&lt; endl;</span></span><br><span class="line">px[++totins] = x1, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x2 != n) px[++totins] = x2 + <span class="number">1</span>, py1[totins] = y1, py2[totins] = y2, pval[totins] = nval, pf[totins] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cmpval(x) ((x) &gt; totins ? qx[(x) - totins] : px[(x)])</span></span><br><span class="line"><span class="keyword">return</span> cmpval(i) &lt; cmpval(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp[maxm];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1为修改，2为询问</span></span><br><span class="line"><span class="keyword">int</span> q[maxm], qc[maxm];</span><br><span class="line"><span class="keyword">int</span> lq[maxm], lqc[maxm], rq[maxm], rqc[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> suc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) <span class="keyword">if</span>(qc[i] == <span class="number">1</span>) &#123; suc = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(suc || l == r) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) <span class="keyword">if</span>(qc[i] == <span class="number">2</span>) ans[q[i]] = l;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lt = <span class="number">0</span>, rt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> lc = <span class="number">0</span>, rc = <span class="number">0</span>;</span><br><span class="line">bint.reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L; i&lt;=R; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = q[i];</span><br><span class="line"><span class="keyword">if</span>(qc[i] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(pval[k] &lt;= mid) bint.add(py1[k], py2[k], pf[k]), lq[++lt] = k, lqc[lt] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> rq[++rt] = k, rqc[rt] = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lcnt = bint.ask(qy[k]);</span><br><span class="line"><span class="keyword">if</span>(qaim[k] &gt; lcnt) qaim[k] -= lcnt, rq[++rt] = k, rqc[rt] = <span class="number">2</span>, rc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lq[++lt] = k, lqc[lt] = <span class="number">2</span>, lc = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(lc) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=lt; i++) q[i + L - <span class="number">1</span>] = lq[i], qc[i + L - <span class="number">1</span>] = lqc[i];</span><br><span class="line"><span class="keyword">if</span>(rc) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=rt; i++) q[L + lt + i - <span class="number">1</span>] = rq[i], qc[L + lt + i - <span class="number">1</span>] = rqc[i];</span><br><span class="line"><span class="keyword">if</span>(lc) solve(l, mid, L, L + lt - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(rc) solve(mid + <span class="number">1</span>, r, L + lt, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(totq);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv);</span><br><span class="line">addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(root, <span class="number">1</span>, <span class="number">0</span>), dfs2(root, root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, nval;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(x), readint(y), readint(nval), ht[i] = nval;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line"><span class="keyword">if</span>(dfn[y] &lt;= dfn[x] &amp;&amp; dfn[x] &lt;= dfr[y]) &#123; <span class="comment">// 链</span></span><br><span class="line">y = ask_anc(x, y);</span><br><span class="line">insert(dfn[x], dfr[x], <span class="number">1</span>, dfn[y] - <span class="number">1</span>, nval);</span><br><span class="line">insert(dfn[x], dfr[x], dfr[y] + <span class="number">1</span>, n, nval);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> insert(dfn[x], dfr[x], dfn[y], dfr[y], nval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ([dfn[x], dfr[x]], [dfn[y], dfr[y]])</span></span><br><span class="line"><span class="comment">// ([dfn[x], dfr[x]], [1, dfn[y] - 1]) ([dfn[x], dfr[x]], [dfn[y] + 1, n])</span></span><br><span class="line">sort(ht+<span class="number">1</span>, ht+m+<span class="number">1</span>), toth = unique(ht+<span class="number">1</span>, ht+m+<span class="number">1</span>) - (ht + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins; ) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i + <span class="number">1</span>, res = eco(pval[i]);</span><br><span class="line"><span class="keyword">while</span>(j &lt;= totins &amp;&amp; pval[j] == pval[i]) j++;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; j; i++) pval[i] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totq; i++) &#123;</span><br><span class="line">readint(qx[i]), readint(qy[i]), readint(qaim[i]);</span><br><span class="line">qx[i] = dfn[qx[i]], qy[i] = dfn[qy[i]];</span><br><span class="line"><span class="keyword">if</span>(qx[i] &gt; qy[i]) swap(qx[i], qy[i]);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; qx[i] &lt;&lt; " " &lt;&lt; qy[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins+totq; i++) temp[i] = i;</span><br><span class="line">stable_sort(temp+<span class="number">1</span>, temp+totins+totq+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totins+totq; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp[i] &gt; totins) q[i] = temp[i] - totins, qc[i] = <span class="number">2</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> q[i] = temp[i], qc[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solve(<span class="number">1</span>, toth, <span class="number">1</span>, totins + totq);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=totq; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ht[ans[i]]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定树上一些路径，每个路径有一些权值，构成一个集合。每次询问给出一条路径，回答之前那个集合中为其子路径的所有
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="整体二分" scheme="http://arintaro.com/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
      <category term="扫描线" scheme="http://arintaro.com/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2010 观光公交</title>
    <link href="http://arintaro.com/2019/12/31/Answer/bus%20copy/"/>
    <id>http://arintaro.com/2019/12/31/Answer/bus copy/</id>
    <published>2019-12-31T15:59:40.569Z</published>
    <updated>2019-12-31T15:59:40.571Z</updated>
    
    <content type="html"><![CDATA[<p>你以为我是DP,其实我是贪心啦dio<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>题意较为复杂,套的壳比较多,可见<a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">https://www.luogu.org/problem/P1315</a><br>要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。</p><p>接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(<del>事实上远远跑不到</del>); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。</p><p>我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(<del>这两个名词都是我瞎编的</del>)</p><h4><span id="算法1贪心">算法1：贪心</span></h4><p>直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。</p><p>同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。</p><h4><span id="算法2优化后的贪心">算法2：优化后的贪心</span></h4><p>发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(<del>然而并没有</del>), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。</p><h4><span id="算法3-数据结构优化贪心">算法3: 数据结构优化贪心</span></h4><p>考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], leave[maxn], arrive[maxn], w[maxn];</span><br><span class="line">lint sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(k);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) readint(w[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t, st, ed;</span><br><span class="line">readint(t), readint(st), readint(ed);</span><br><span class="line">cnt[ed]++, sum[ed] += t;</span><br><span class="line">leave[st] = max(leave[st], t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) arrive[i] = max(arrive[i<span class="number">-1</span>], leave[i<span class="number">-1</span>]) + w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> res_st = <span class="number">0</span>, res_ed = <span class="number">0</span>, res_w = <span class="number">0</span>, res_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; ) &#123;</span><br><span class="line"><span class="keyword">if</span>(w[i] == <span class="number">0</span>) &#123; i++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> now_w = min(w[i], k), now_cnt = <span class="number">0</span>;</span><br><span class="line">rint j = i;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123;</span><br><span class="line">now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]);</span><br><span class="line">&#125;</span><br><span class="line">now_cnt += cnt[j];</span><br><span class="line"><span class="keyword">if</span>(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt;</span><br><span class="line">i = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res_w == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">w[res_st] -= res_w, k -= res_w;</span><br><span class="line"><span class="keyword">for</span>(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w;</span><br><span class="line">&#125;</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你以为我是DP,其实我是贪心啦dio&lt;br&gt;
    
    </summary>
    
      <category term="NOIP" scheme="http://arintaro.com/categories/NOIP/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/NOIP/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="迭代" scheme="http://arintaro.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>APIO2015 八邻旁之桥</title>
    <link href="http://arintaro.com/2019/12/29/Answer/bridge2/"/>
    <id>http://arintaro.com/2019/12/29/Answer/bridge2/</id>
    <published>2019-12-29T12:03:36.663Z</published>
    <updated>2019-12-29T12:14:04.924Z</updated>
    
    <content type="html"><![CDATA[<p>又一道在APIO中的$k=2$的题目<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一些在坐标轴上的线段，再让你确定一个或两个点，每条线段可以选一个点，答案累加它两个端点到这个点的距离，要求答案最小。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先考虑确定一个点怎么做，发现一条线段左右端点的贡献是可以拆开的，这样就变成货仓选址了。</p><p>再考虑两个点怎么做，如果像一个点的做法，拆开两个点的贡献，这样两个端点容易选不到一个点，导致答案偏小，如果我们能划分成两个集合，一个集合内的线段只去一个点，即可按照$k=1$的做法做。</p><p>考虑其贡献函数，如果一个线段到的点在它内部，贡献为常数，即这个线段长，如果在外部，可以发现是是$|l + r - 2x|$，其中$x$是点的坐标，显然它是关于$\frac{l + r}{2}$对称的，且两侧都是单调的，那么对它来说，肯定是选去一个离它对称轴近的点，那么即可把所有线段按$l + r$排序，枚举两个集合间的划分点，前后分别动态维护中位数。</p><p>动态中位数有很多做法，离线链表，对顶堆，$\set$等做法，离线链表应该跑的是最快的，但是我最近平衡树写的比较多，写起来虽然长一点，但是可能也比其他做法写的要快。抱着这种想法，我选择了无旋$\text{Treap}$，然后成功被卡常，换成$\text{SBT}$后才水过去。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sit set<span class="meta-string">&lt;pii&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Seg&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l + r &lt; b.l + b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;seg[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[maxn][<span class="number">2</span>], val[maxn], size[maxn];</span><br><span class="line">lint sum[maxn];</span><br><span class="line"><span class="keyword">int</span> root, totnode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">size[++totnode] = <span class="number">1</span>, val[totnode] = nval, sum[totnode] = nval;</span><br><span class="line"><span class="keyword">return</span> totnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">sum[p] = sum[ch[p][<span class="number">0</span>]] + sum[ch[p][<span class="number">1</span>]] + val[p];</span><br><span class="line">size[p] = size[ch[p][<span class="number">0</span>]] + size[ch[p][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = ch[x][c];</span><br><span class="line">ch[x][c] = ch[y][c ^ <span class="number">1</span>], ch[y][c ^ <span class="number">1</span>] = x;</span><br><span class="line">sum[y] = sum[x], size[y] = size[x], pushup(x);</span><br><span class="line">x = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">bool</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size[ch[ch[x][c]][c]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size[ch[ch[x][c]][c ^ <span class="number">1</span>]] &gt; size[ch[x][c ^ <span class="number">1</span>]]) rotate(ch[x][c], c ^ <span class="number">1</span>), rotate(x, c);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">maintain(ch[x][<span class="number">0</span>], <span class="number">0</span>), maintain(ch[x][<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">maintain(x, <span class="number">0</span>), maintain(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) &#123; p = newnode(nval); <span class="keyword">return</span>; &#125;</span><br><span class="line">insert(ch[p][nval &gt;= val[p]], nval), pushup(p);</span><br><span class="line">maintain(p, nval &gt;= val[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123; insert(root, nval); &#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">merase</span><span class="params">(<span class="keyword">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[p][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">res = val[p], p = ch[p][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = merase(ch[p][<span class="number">0</span>]);</span><br><span class="line">pushup(p);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(val[p] == nval) &#123;</span><br><span class="line"><span class="keyword">if</span>(ch[p][<span class="number">0</span>] == <span class="number">0</span> || ch[p][<span class="number">1</span>] == <span class="number">0</span>) p = ch[p][<span class="number">0</span>] + ch[p][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> val[p] = merase(ch[p][<span class="number">1</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> erase(ch[p][nval &gt;= val[p]], nval);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123; erase(root, nval); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; pos, lint&amp; now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(size[ch[p][<span class="number">0</span>]] == k) &#123; pos = p, now += sum[ch[p][<span class="number">0</span>]]; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(k &gt; size[ch[p][<span class="number">0</span>]]) now += sum[ch[p][<span class="number">0</span>]] + val[p], ask_rank(ch[p][<span class="number">1</span>], k - size[ch[p][<span class="number">0</span>]] - <span class="number">1</span>, pos, now);</span><br><span class="line"><span class="keyword">else</span> ask_rank(ch[p][<span class="number">0</span>], k, pos, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p, lsize = (size[root] + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>, rsize = size[root] - lsize - <span class="number">1</span>;</span><br><span class="line">lint lsum = <span class="number">0</span>, rsum = <span class="number">0</span>;</span><br><span class="line">ask_rank(root, lsize, p, lsum), rsum = sum[root] - lsum - val[p];</span><br><span class="line"><span class="keyword">return</span> (lint)lsize * val[p] - lsum + rsum - (lint)rsize * val[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;lt, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(k), readint(n);</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>], b[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readstr(a), readint(x), readstr(b), readint(y);</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) ans += <span class="built_in">abs</span>(y - x);</span><br><span class="line"><span class="keyword">else</span> seg[++tot].l = min(x, y), seg[tot].r = max(x, y), ans++;</span><br><span class="line">&#125;</span><br><span class="line">n = tot, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) arr[++tot] = seg[i].l, arr[++tot] = seg[i].r;</span><br><span class="line"><span class="keyword">int</span> pos = (tot + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">nth_element(arr+<span class="number">1</span>, arr+pos, arr+tot+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=tot; i++) ans += <span class="built_in">abs</span>(arr[i] - arr[pos]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lint res = <span class="number">1e18</span>;</span><br><span class="line">sort(seg+<span class="number">1</span>, seg+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) rt.insert(seg[i].l), rt.insert(seg[i].r);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">rt.erase(seg[i].l), rt.erase(seg[i].r);</span><br><span class="line">lt.insert(seg[i].l), lt.insert(seg[i].r);</span><br><span class="line">res = min(res, lt.ask() + rt.ask());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res + ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又一道在APIO中的$k=2$的题目&lt;br&gt;
    
    </summary>
    
      <category term="APIO" scheme="http://arintaro.com/categories/APIO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/APIO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="货仓选址" scheme="http://arintaro.com/tags/%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80/"/>
    
      <category term="单调性" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E6%80%A7/"/>
    
      <category term="动态中位数" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2006 书架</title>
    <link href="http://arintaro.com/2019/12/28/Answer/book/"/>
    <id>http://arintaro.com/2019/12/28/Answer/book/</id>
    <published>2019-12-28T06:47:05.784Z</published>
    <updated>2019-12-28T06:57:25.636Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>懒得写了，写个平衡树，要求支持以下操作<br><a href="https://www.luogu.com.cn/problem/P2596" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2596</a></p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>本题涉及到”移动幅度不大的”区间操作，即$\text{insert}$中只有$-1, 1$，因此可以直接用树状数组水过，倍增即可单$\log$查排名。</p><p>平衡树怎么写呢，要用$\text{Splay}$ 或者是无旋$\text{Treap}$，常数都比较大。</p><p>前者无法高效单次操作分裂出序列中前$k$个数字，必须先查一次第$k$个数的节点编号，然后把它旋转上来。而后者无法高效的已知某个节点编号，分裂出在它前面的节点。当然，如果各多实现几个函数，也是可以做到的，比如在一棵$\text{Splay}$上跑无旋$\text{Treap}$的$\text{Split}$，但是写起来比较麻烦。</p><p>我写了后者，维护父指针，即可实现一个辅助函数，给节点指针查排名，再用$\text{Split}$分裂出节点。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isch(x) ((x) != <span class="meta-string">'\n'</span> &amp;&amp; (x) != <span class="meta-string">'\r'</span> &amp;&amp; (x) != <span class="meta-string">' '</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readstr</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>; <span class="keyword">char</span> ch = getc();</span><br><span class="line"><span class="keyword">while</span>(!isch(ch)) ch = getc();</span><br><span class="line"><span class="keyword">for</span>(; isch(ch); ch = getc()) s[len++] = ch;</span><br><span class="line">s[len] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> lson[maxnode], rson[maxnode], dfa[maxnode];</span><br><span class="line"><span class="keyword">int</span> rnd[maxnode], id[maxnode], size[maxnode];</span><br><span class="line"><span class="keyword">int</span> pos[maxnode];</span><br><span class="line"><span class="keyword">int</span> root, totnode;</span><br><span class="line"></span><br><span class="line">Treap() &#123; rnd[<span class="number">0</span>] = rand(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">size[p] = size[lson[p]] + size[rson[p]] + <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>) p = a + b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rnd[a] &gt; rnd[b]) p = a, merge(rson[p], rson[a], b, p);</span><br><span class="line"><span class="keyword">else</span> p = b, merge(lson[p], a, lson[b], p);</span><br><span class="line">dfa[p] = fa, pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; merge(p, a, b, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span> fa, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span> fb, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) a = b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k &gt; size[lson[p]]) a = p, dfa[p] = fa, split_rank(rson[p], rson[a], p, b, fb, k - size[lson[p]] - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> b = p, dfa[p] = fb, split_rank(lson[p], a, fa, lson[b], p, k);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split_rank</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b, <span class="keyword">int</span> k)</span> </span>&#123; split_rank(p, a, <span class="number">0</span>, b, <span class="number">0</span>, k); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">p = ++totnode;</span><br><span class="line">id[p] = arr[mid], size[p] = <span class="number">1</span>, pos[arr[mid]] = p, dfa[p] = fa;</span><br><span class="line">rnd[p] = rnd[fa] - (rand() &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span>));</span><br><span class="line">build(lson[p], l, mid<span class="number">-1</span>, p), build(rson[p], mid+<span class="number">1</span>, r, p);</span><br><span class="line">pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">print(lson[p], p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, id[p]);</span><br><span class="line">print(rson[p], p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; print(root, <span class="number">0</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrank</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = size[lson[p]];</span><br><span class="line"><span class="keyword">while</span>(dfa[p] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(rson[dfa[p]] == p) res += size[lson[dfa[p]]] + <span class="number">1</span>; <span class="comment">// 注意这里要+1</span></span><br><span class="line">p = dfa[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move_top</span><span class="params">(<span class="keyword">int</span> nid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = getrank(pos[nid]), lt, mid, rt;</span><br><span class="line">split_rank(root, lt, <span class="number">0</span>, rt, <span class="number">0</span>, k), split_rank(rt, mid, <span class="number">0</span>, rt, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">merge(lt, mid, lt, <span class="number">0</span>), merge(root, lt, rt, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move_bot</span><span class="params">(<span class="keyword">int</span> nid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = getrank(pos[nid]), lt, mid, rt;</span><br><span class="line">split_rank(root, lt, <span class="number">0</span>, rt, <span class="number">0</span>, k), split_rank(rt, mid, <span class="number">0</span>, rt, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">merge(root, lt, rt, <span class="number">0</span>), merge(root, root, mid, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> nid, <span class="keyword">int</span> det)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(det == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> k = getrank(pos[nid]), lt, mid, t, rt;</span><br><span class="line">split_rank(root, lt, <span class="number">0</span>, rt, <span class="number">0</span>, k), split_rank(rt, mid, <span class="number">0</span>, rt, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(det &gt; <span class="number">0</span>) &#123;</span><br><span class="line">split_rank(rt, t, <span class="number">0</span>, rt, <span class="number">0</span>, det);</span><br><span class="line">merge(lt, lt, t, <span class="number">0</span>), merge(rt, mid, rt, <span class="number">0</span>);</span><br><span class="line">merge(root, lt, rt, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">split_rank(lt, lt, <span class="number">0</span>, t, <span class="number">0</span>, size[lt] + det);</span><br><span class="line">merge(lt, lt, mid, <span class="number">0</span>), merge(rt, t, rt, <span class="number">0</span>);</span><br><span class="line">merge(root, lt, rt, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> nid)</span> </span>&#123; <span class="keyword">return</span> getrank(pos[nid]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getid</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lt, mid, rt;</span><br><span class="line">split_rank(root, lt, rt, k<span class="number">-1</span>), split_rank(rt, mid, rt, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> res = id[mid];</span><br><span class="line">merge(lt, lt, mid), merge(root, lt, rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;bst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand(<span class="number">42</span>);</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">bst.build(bst.root, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return 0;</span></span><br><span class="line"><span class="keyword">char</span> ins[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> x, d;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readstr(ins), readint(x);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; ins &lt;&lt; " " &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'T'</span>) bst.move_top(x);</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'B'</span>) bst.move_bot(x);</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'I'</span>) readint(d), bst.insert(x, d);</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'A'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bst.ask(x));</span><br><span class="line"><span class="keyword">if</span>(ins[<span class="number">0</span>] == <span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bst.getid(x));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bst.print();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;懒得写了，写个平衡树，要求支持以下操作&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="平衡树" scheme="http://arintaro.com/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="树状数组" scheme="http://arintaro.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2016 游戏</title>
    <link href="http://arintaro.com/2019/12/28/Answer/game/"/>
    <id>http://arintaro.com/2019/12/28/Answer/game/</id>
    <published>2019-12-28T04:20:40.997Z</published>
    <updated>2019-12-28T04:34:02.331Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵带点权和边权的树，两种操作，边权给定，点权初始为$\text{inf}$</p><ol><li>给定树上一条路径，路径上每个点的点权与$a \times dis + b$，取$\text{min}$，其中$\text{dis}$为该点与起点的距离</li><li>给定一条路径，查询其中的最小点权。</li></ol><p>$1 \leq n \leq 10^5$，$1 \leq m \leq 10^5$，值域为$\text{long long}$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这种与等差数列取$\text{min}$或$\text{max}$的操作显然可以用李超线段树维护，放在树上就套个树链剖分而已，推下式子显然可以转换成只与到根节点的距离有关，剩下到起点的距离放在常数项上即可，这样一条重链上的横坐标仍然是递增的，可以直接维护。</p><p>之前写的模版题只有单点查询，这题要求支持区间查询，所以我们需要格外维护一个标记，表示这个区间以及所有子区间中在区间中能取到的最小值，显然有递推式</p><p>$$<br>minval_p = \min(f_p(l), f_p(r), minval_{lson}, minval_{rson})<br>$$</p><p>查询时如果查询区间完全覆盖了当前区间，直接返回标记即可，未完全覆盖就再让子节点返回的答案与当前节点上的函数在定义域上两个端点的值取较小的返回即可。</p><p>另外本题$10^5$跑三个$\log$，有些不稳，但是李超线段树常数非常小，两个$\log$实际上是没法跑满的。</p><p>由于本题只维护链上信息，我们可以对每条重链单独开一棵线段树，减少无用信息的合并和递归次数，只开一棵线段树，合并两条重链的信息显然是毫无意义的。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxnode = <span class="number">3</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> lint inf = <span class="number">1e18</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totdfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfa[maxn], size[maxn], deep[maxn], root = <span class="number">1</span>;</span><br><span class="line">lint dist[maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], wson[maxn], wtop[maxn];</span><br><span class="line"><span class="keyword">int</span> sid[maxn];</span><br><span class="line"></span><br><span class="line">lint dis[maxnode];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>&#123;</span></span><br><span class="line">lint k, b;</span><br><span class="line">func() &#123; k = <span class="number">0</span>, b = inf; &#125;</span><br><span class="line">func(lint kk, lint bb): k(kk), b(bb) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> k * dis[x] + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SMT</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lson[maxnode], rson[maxnode], totnode;</span><br><span class="line"><span class="keyword">static</span> func f[maxnode];</span><br><span class="line"><span class="keyword">static</span> lint minval[maxnode];</span><br><span class="line"><span class="keyword">int</span> root, sl, sr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> func&amp; g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) p = ++totnode, minval[p] = inf;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line"><span class="keyword">bool</span> lt = g(l) &lt; f[p](l), mt = g(mid) &lt; f[p](mid), rt = g(r) &lt; f[p](r);</span><br><span class="line"><span class="keyword">if</span>(lt &amp;&amp; rt) f[p] = g;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!lt &amp;&amp; !rt) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mt) &#123; <span class="comment">// 下放f</span></span><br><span class="line"><span class="keyword">if</span>(lt) insert(rson[p], mid+<span class="number">1</span>, r, L, R, f[p]);</span><br><span class="line"><span class="keyword">else</span> insert(lson[p], l, mid, L, R, f[p]);</span><br><span class="line">f[p] = g;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(lt) insert(lson[p], l, mid, L, R, g);</span><br><span class="line"><span class="keyword">else</span> insert(rson[p], mid+<span class="number">1</span>, r, L, R, g);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) insert(lson[p], l, mid, L, R, g);</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) insert(rson[p], mid+<span class="number">1</span>, r, L, R, g);</span><br><span class="line">&#125;</span><br><span class="line">minval[p] = min(min(f[p](l), f[p](r)), min(minval[lson[p]], minval[rson[p]]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">const</span> func&amp; g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &gt; R) swap(L, R);</span><br><span class="line">insert(root, sl, sr, L, R, g);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> inf;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> minval[p];</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; lint res = inf;</span><br><span class="line"><span class="keyword">if</span>(L &lt;= mid) res = min(res, ask(lson[p], l, mid, L, R));</span><br><span class="line"><span class="keyword">if</span>(R &gt; mid) res = min(res, ask(rson[p], mid+<span class="number">1</span>, r, L, R));</span><br><span class="line"><span class="keyword">return</span> min(res, min(f[p](max(L, l)), f[p](min(R, r))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L &gt; R) swap(L, R);</span><br><span class="line"><span class="keyword">return</span> ask(root, sl, sr, L, R);</span><br><span class="line">&#125;</span><br><span class="line">&#125;smt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SMT::lson[maxnode], SMT::rson[maxnode], SMT::totnode;</span><br><span class="line">func SMT::f[maxnode];</span><br><span class="line">lint SMT::minval[maxnode];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totsmt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x]) <span class="keyword">continue</span>;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>, dist[y] = dist[x] + ew[i], dfa[y] = x;</span><br><span class="line">dfs1(y);</span><br><span class="line">size[x] += size[y];</span><br><span class="line"><span class="keyword">if</span>(size[y] &gt; size[wson[x]]) wson[x] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> nid)</span> </span>&#123;</span><br><span class="line">dfn[x] = ++totdfn, wtop[x] = top;</span><br><span class="line">dis[totdfn] = dist[x], sid[x] = nid;</span><br><span class="line"><span class="keyword">if</span>(smt[nid].sl == <span class="number">0</span>) smt[nid].sl = totdfn;</span><br><span class="line">smt[nid].sr = totdfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(wson[x]) dfs2(wson[x], top, nid);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == dfa[x] || y == wson[x]) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, y, ++totsmt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[y]) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> deep[x] &lt; deep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert_lian</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> anc, lint k, lint b)</span> </span>&#123;</span><br><span class="line">func g = func(k, b);</span><br><span class="line"><span class="keyword">while</span>(deep[wtop[x]] &gt;= deep[anc]) &#123;</span><br><span class="line">smt[sid[x]].insert(dfn[x], dfn[wtop[x]], g);</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deep[x] &gt;= deep[anc]) smt[sid[x]].insert(dfn[x], dfn[anc], g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed, lint k, lint b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nlca = lca(st, ed);</span><br><span class="line">insert_lian(st, nlca, -k, k * dist[st] + b);</span><br><span class="line">insert_lian(ed, nlca, k, b + k * dist[st] - <span class="number">2</span> * k * dist[nlca]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">lint res = inf;</span><br><span class="line"><span class="keyword">while</span>(wtop[x] != wtop[y]) &#123;</span><br><span class="line"><span class="keyword">if</span>(deep[wtop[x]] &lt; deep[wtop[y]]) swap(x, y);</span><br><span class="line">res = min(res, smt[sid[x]].ask(dfn[x], dfn[wtop[x]]));</span><br><span class="line">x = dfa[wtop[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min(res, smt[sid[x]].ask(dfn[x], dfn[y]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SMT::minval[<span class="number">0</span>] = inf;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">deep[root] = <span class="number">1</span>;</span><br><span class="line">dfs1(root), dfs2(root, root, ++totsmt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ins, st, ed, a, b;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(ins), readint(st), readint(ed);</span><br><span class="line"><span class="comment">// cerr &lt;&lt; ins &lt;&lt; " " &lt;&lt; st &lt;&lt; " " &lt;&lt; ed &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(ins == <span class="number">1</span>) readint(a), readint(b), insert(st, ed, a, b);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">lint res = ask(st, ed);</span><br><span class="line"><span class="keyword">if</span>(res == inf) <span class="built_in">puts</span>(<span class="string">"123456789123456789"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给定一棵带点权和边权的树，两种操作，边权给定，点权初始为$\text{inf}$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="各省省选" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树链剖分" scheme="http://arintaro.com/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="李超线段树" scheme="http://arintaro.com/tags/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="标记永久化" scheme="http://arintaro.com/tags/%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ARC089E GraphXY</title>
    <link href="http://arintaro.com/2019/12/25/Answer/xy/"/>
    <id>http://arintaro.com/2019/12/25/Answer/xy/</id>
    <published>2019-12-25T06:44:23.273Z</published>
    <updated>2019-12-25T06:59:08.341Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>构造一张有向图,并给出 $st, ed$</p><p>每条边的权值是一个确定的整数,或者 $X$,或者 $Y$</p><p>$d, x, y$ 表示当 $X = x, Y = y$ 时 $st$ 到 $ed$ 的最短路长度</p><p>给出 $d$ 数组,构造出这个有向图</p><p>$n \leq 300$ , $x, y \leq 10$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑先求出把$X, Y$的影响排除在外的最短路，以此方便构造，发现至多会走$100$个$X$或$Y$，所以我们可以在状态上记录当前走了几个$X$，$Y$，定义$f_{i, j}$为走了$i$个$X$和$j$个$Y$的最短路。</p><p>像这种已知答案构建问题的构造，可以考虑已知问题如何求出答案，即有$dist_{x, y} = \min(i \times x + j \times y + f_{i, j})$，考虑移项，<br>$$dist_{x, y} \leq i \times x + j \times y + f_{i, j}$$<br>$$dist_{x, y} - i \times x - j \times y \leq + f_{i, j}$$<br>$$f_{i, j} = \max(dist_{x, y} - i \times x - j \times y)$$</p><p>这里的不等号只作「符号」上的转换，以便我们确定移项后是$\min$还是$\max$，由于等号在原式一定取到，所以并不是真正的放缩，以此可以求出$f$数组，显然可以构造只有$X$和只有$Y$的两条链，使走一定数量的$X,Y$的路径唯一，在连接点处放计算出的$f$即可。</p><p>注意这样不一定成立，解可能不存在，因为由$d$求出$f$的时候，我们这样的推导并不能保证由$f$还能计算出一样的$d$，即我们计算出的$f$是$d$的一个必要条件。所以我们还要判断由$f$是否还能计算出一样的$d$，按照公式计算即可，我代码里写了最短路，实际上不必要。</p><p>至于为什么这样构造出的$f$不满足就一定不存在满足题意的图，我感性理解一下就是对于一个$d$来说，它的$f$按照上述计算方法是唯一的，唯一的$f$构造出来的图都不满足，那么一定也不存在其他满足题意的图。实际上不太严谨，我也没看到其他题解有详细论证的，希望有人会可以告诉我。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxa = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">204</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dist[x][y] = min&#123;i * x + j * y + f[i][j]&#125;</span></span><br><span class="line"><span class="comment">// dist[x][y] - i * x - j * y &lt;= f[i][j]</span></span><br><span class="line"><span class="comment">// f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">202</span>, m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> A, B;</span><br><span class="line"><span class="keyword">int</span> dist[maxa][maxa], f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> now[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(edge, <span class="number">-1</span>, <span class="keyword">sizeof</span>(edge));</span><br><span class="line">readint(A), readint(B);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=A; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=B; j++) readint(dist[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=A; x++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>; y&lt;=B; y++) &#123;</span><br><span class="line">f[i][j] = max(f[i][j], dist[x][y] - i * x - j * y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i个x, j个y的最短路</span></span><br><span class="line">edge[i + <span class="number">1</span>][<span class="number">202</span> - j] = f[i][j];</span><br><span class="line"><span class="keyword">if</span>(edge[i + <span class="number">1</span>][<span class="number">202</span> - j] != <span class="number">-1</span>) cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dist[x][y] = min&#123;i * x + j * y + f[i][j]&#125;</span></span><br><span class="line"><span class="comment">// dist[x][y] - i * x - j * y &lt;= f[i][j]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] = max&#123;dist[x][y] - i * x - j * y&#125;</span></span><br><span class="line"><span class="comment">// f[i][j] &gt;= dist[x][y] - i * x - j * y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>; a&lt;=A; a++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">1</span>; b&lt;=B; b++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) edge[i][i+<span class="number">1</span>] = a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">102</span>; i&lt;=<span class="number">201</span>; i++) edge[i][i+<span class="number">1</span>] = b;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), <span class="built_in">memset</span>(now, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(now));</span><br><span class="line">now[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(!vis[i] &amp;&amp; now[i] &lt; now[x]) x = i;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>; y&lt;=n; y++)</span><br><span class="line"><span class="keyword">if</span>(edge[x][y] != <span class="number">-1</span> &amp;&amp; now[y] &gt; now[x] + edge[x][y]) now[y] = now[x] + edge[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now[n] != dist[a][b]) &#123; <span class="built_in">puts</span>(<span class="string">"Impossible"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Possible"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, n, cnt + <span class="number">200</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d %d X\n"</span>, i, i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">102</span>; i&lt;=<span class="number">201</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d %d Y\n"</span>, i, i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i + <span class="number">1</span>, <span class="number">202</span> - j, f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, <span class="number">1</span>, <span class="number">202</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;构造一张有向图,并给出 $st, ed$&lt;/p&gt;
&lt;p&gt;每条边的权值是一个确定的整数,或者 $X$,或者 $
      
    
    </summary>
    
      <category term="atcoder" scheme="http://arintaro.com/categories/atcoder/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/atcoder/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="构造" scheme="http://arintaro.com/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="思维" scheme="http://arintaro.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>CF566E Restoring Map</title>
    <link href="http://arintaro.com/2019/12/25/Answer/map/"/>
    <id>http://arintaro.com/2019/12/25/Answer/map/</id>
    <published>2019-12-25T03:34:37.002Z</published>
    <updated>2019-12-25T04:58:43.837Z</updated>
    
    <content type="html"><![CDATA[<p>神奇的题目<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给出一棵树，定义一个点的邻居集合为距离不超过$2$的点的集合</p><p>乱序给出每个点的邻居集合，构造出原树，即不知道$n$个集合中每个集合对应哪个点</p><p>$n \leq 1000$，保证有解，多解任意输出</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>由于不知道哪个集合对应哪个点，信息难以利用。</p><p>考虑取交集，发现当有一条$4$个点构成的链时，对两头的点集取交集，集合中的点一定为中间的两个点，直接连边即可。</p><p>这样即可求出树中所有非叶节点之间的连边，并确定至少两个非叶节点，之后考虑非叶节点连在哪里即可。</p><p>同时需要注意这里推导的前提条件，可能图中只有一个非叶节点即不存在一条由$4$个点构成的链，容易发现即为菊花图，需要特判。</p><p>考虑菊花图的情况，容易发现所有点集都是一样的，即所有点都是等价的，随便选一个作根即可。</p><p>接着考虑，我们仍不知道集合与点的对应关系，需要继续利用集合信息，考虑叶子节点的特殊性质，叶子节点跳到它的父亲，离它距离小于等于$2$的点肯定不会减少，又因为它的父亲是非叶节点，可知点的数量会增多，如果再从它的父亲跳到其他非叶节点，结合性质发现至少比在它的父亲时不会减少，综合以上讨论，可以发现一个叶子节点对应的点集是包含它的集合元素最少的那个。如果有多个，可以发现其都是等价的，是挂在同一个节点上的叶子节点，不会影响答案。</p><p>接着考虑，对于一个叶子节点，跳到它的父亲相当于花费了$1$的距离，那么离父亲距离为$1$的节点也肯定都在离叶子节点距离为$2$的点集中，注意我们这里处理离父亲节点距离为$1$的节点是依靠上面所有非叶节点之间的连边，所以集合中要无视掉其余叶子节点，于是我们得到了一个必要条件。</p><p>无视掉其他叶子节点后，如果存在一个非叶节点距离父亲为$1$，且不连接任何其余任何非叶节点，那么只依靠上述条件这个点与父亲节点都会判定成立。结合样例发现，这种情况只存在于有且仅有两个非叶节点的时候，且这两个点是等价的，其余叶子节点的点集只有两种，我们把点集一样的叶子节点分在同一边即可。</p><p>讨论完上述情况后，可以发现满足条件的点是唯一的，变成充要条件，我们可以直接利用这个条件判断谁是父亲，解决问题。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码比较丑</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; s[maxn], edge[maxn];</span><br><span class="line"><span class="keyword">int</span> bsize[maxn];</span><br><span class="line"><span class="keyword">bool</span> nleaf[maxn], vis[maxn];</span><br><span class="line"><span class="keyword">int</span> sid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">readint(t);</span><br><span class="line"><span class="keyword">while</span>(t--) readint(x), s[i][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; now;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) bsize[i] = s[i].count();</span><br><span class="line">bsize[<span class="number">0</span>] = maxn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">now = s[i] &amp; s[j];</span><br><span class="line"><span class="keyword">if</span>(now.count() != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> x = now._Find_first(), y = now._Find_next(x); <span class="comment">// 这里也可以暴力查找，这个过程只会执行O(n)次</span></span><br><span class="line">edge[x][y] = edge[y][x] = <span class="number">1</span>, nleaf[x] = nleaf[y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">edge[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) <span class="keyword">if</span>(edge[i][j]) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j), cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"1 %d\n"</span>, i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(nleaf[i]) r1 ? r2 = i : r1 = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">if</span>(nleaf[x]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="keyword">if</span>(s[j][x] &amp;&amp; bsize[j] &lt; bsize[pos]) pos = j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(flag &amp;&amp; s[pos] == now) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s[pos][j] || j == r1 || j == r2) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, r1, j);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, r2, j); </span><br><span class="line">&#125;</span><br><span class="line">flag++, now = s[pos];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="keyword">if</span>(!nleaf[j] &amp;&amp; s[pos][j]) s[pos][j] = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>; y&lt;=n; y++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!nleaf[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(s[pos] == edge[y]) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神奇的题目&lt;br&gt;
    
    </summary>
    
      <category term="codeforces" scheme="http://arintaro.com/categories/codeforces/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="构造" scheme="http://arintaro.com/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="具体方案" scheme="http://arintaro.com/tags/%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>OI知识点</title>
    <link href="http://arintaro.com/2019/12/24/Detail/OI%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://arintaro.com/2019/12/24/Detail/OI知识点/</id>
    <published>2019-12-24T13:33:28.385Z</published>
    <updated>2019-12-24T13:39:07.864Z</updated>
    
    <content type="html"><![CDATA[<p>好多呀..</p><a id="more"></a><p>@card{</p><blockquote><p>引用自：<a href="https://www.luogu.com.cn/blog/SSerxhs/oi-zhi-shi-dian-zong-jie" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/SSerxhs/oi-zhi-shi-dian-zong-jie</a></p></blockquote><p>}</p><h2><span id="一-基本算法">一、基本算法</span></h2><h2><span id="二-库函数及语言">二、库函数及语言</span></h2><h2><span id="三-数学">三、数学</span></h2><h2><span id="四-数据结构">四、数据结构</span></h2><h2><span id="五-动态规划">五、动态规划</span></h2><h2><span id="六-图论">六、图论</span></h2><h2><span id="七-字符串">七、字符串</span></h2><h2><span id="八-计算几何">八、计算几何</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好多呀..&lt;/p&gt;
    
    </summary>
    
      <category term="细节" scheme="http://arintaro.com/categories/%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="方法论" scheme="http://arintaro.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CF993E Nikita and Order Statistics</title>
    <link href="http://arintaro.com/2019/12/10/Answer/nikita/"/>
    <id>http://arintaro.com/2019/12/10/Answer/nikita/</id>
    <published>2019-12-10T00:28:55.830Z</published>
    <updated>2019-12-10T00:40:23.650Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="description">Description:</span></h2><p>@card{</p><p>给你一个数组 $a_{1 \sim n}$，对于 $k = 0 \sim n$，求出有多少个数组上的区间满足：区间内恰好有 $k$ 个数比 $x$ 小。$x$ 为一个给定的数。</p><p>$n \le 2 \times 10^5$。值域没有意义。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>一个套壳的卷积题，需要先进行问题转化，由于$x$给定，问题转化为一个$01$数组上有多少个区间和为$k$，容易想到求前缀和，问题变为有多少对数差为$k$，由于此数组单调递增，对值域考虑发现前缀和较大的位置一定在后面，于是可以统计每个值的出现次数$cnt$，对一个$k$考虑每个$i$，即可得到答案为$ans_k = \sum{cnt_i \times cnt_{i-k}, k \leq i \leq n}$。</p><p>由于需要对每个$k$进行上述计算，朴素会$\text{TLE}$，容易发现是卷积形式，不妨定义负下标和超过$n$的下标上的值均为$0$，即可去掉和式后的限制条件，由于卷积形式需要两指标变量和为一个定值，于是需要把一个$i$的符号变为负数，一般我们反转数组来进行这个变换，于是反转数组再$\text{fft}$即可。</p><p>注意一个边界情况，对$0$计算时会产生$cnt_i \times cnt_i$，这样无法保证前后顺序，正确的计算式应该是$cnt_i \times (cnt_i - 1) / 2$，需要特判。</p><p>另外，本题答案值域可能至$n^2$，刚好超过$\text{int}$，如果选用$\text{ntt}$，需要选两模数多次进行，或者选一个$\text{long long}$范围内的模数，并且需要写快速乘，效率不如用$\text{fft}$</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">cp() &#123;&#125;</span><br><span class="line">cp(<span class="keyword">double</span> xx, <span class="keyword">double</span> yy): x(xx), y(yy) &#123;&#125;</span><br><span class="line"><span class="keyword">inline</span> cp <span class="keyword">operator</span> + (<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(x + b.x, y + b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> cp <span class="keyword">operator</span> - (<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(x - b.x, y - b.y); &#125;</span><br><span class="line"><span class="keyword">inline</span> cp <span class="keyword">operator</span> * (<span class="keyword">const</span> cp&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cp(x * b.x - y * b.y, x * b.y + y * b.x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, t = <span class="number">1</span>, tc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], cnt[maxn], br[maxn];</span><br><span class="line">cp a[maxn], b[maxn];</span><br><span class="line">lint ans_zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp arr[], <span class="keyword">int</span> f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(i &lt; br[i]) swap(arr[i], arr[br[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>; cp w = cp(<span class="built_in">cos</span>(pi / mid), f * <span class="built_in">sin</span>(pi / mid));</span><br><span class="line"><span class="keyword">for</span>(cp *now=arr; now!=arr+n; now+=len) &#123;</span><br><span class="line">cp k = cp(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mid; i++) &#123;</span><br><span class="line">cp x = k * now[i + mid];</span><br><span class="line">now[i + mid] = now[i] - x;</span><br><span class="line">now[i] = now[i] + x;</span><br><span class="line">k = k * w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]);</span><br><span class="line">arr[i] = (arr[i] &lt; x) + arr[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) cnt[arr[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) ans_zero += (lint)cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) a[i].x = cnt[i], b[n-i].x = cnt[i];</span><br><span class="line"><span class="keyword">while</span>(t &lt; <span class="number">2</span> * n + <span class="number">2</span>) t &lt;&lt;= <span class="number">1</span>, tc++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) br[i] = (br[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (tc - <span class="number">1</span>));</span><br><span class="line">fft(a, <span class="number">1</span>, t), fft(b, <span class="number">1</span>, t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) a[i] = a[i] * b[i];</span><br><span class="line">fft(a, <span class="number">-1</span>, t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans_zero);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, (lint)(a[n+i].x / t + <span class="number">0.5</span>));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;description&quot;&gt;Description:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;给你一个数组 $a_{1 \sim n}$，对于 $k = 0 \sim n$，求出有多少个数组上的区间满足
      
    
    </summary>
    
      <category term="codeforces" scheme="http://arintaro.com/categories/codeforces/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/codeforces/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="fft" scheme="http://arintaro.com/tags/fft/"/>
    
      <category term="卷积" scheme="http://arintaro.com/tags/%E5%8D%B7%E7%A7%AF/"/>
    
  </entry>
  
  <entry>
    <title>bsgs</title>
    <link href="http://arintaro.com/2019/12/01/Template/%E6%95%B0%E5%AD%A6/%E6%95%B0%E8%AE%BA/bsgs/"/>
    <id>http://arintaro.com/2019/12/01/Template/数学/数论/bsgs/</id>
    <published>2019-12-01T14:02:11.781Z</published>
    <updated>2019-12-01T14:03:14.277Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h2><span id="一-代码">一、代码</span></h2><p>@card{</p><p>注意判断无解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://loj.ac/problem/10214</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, b, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mHash_table</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">5e6</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[htmod], nxt[maxn], key[maxn], val[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="function">pii <span class="title">find</span><span class="params">(<span class="keyword">int</span> nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[p]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i] == nkey) <span class="keyword">return</span> mp(val[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mp(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line">pii now = find(nkey);</span><br><span class="line"><span class="keyword">if</span>(now.first != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(now.first &lt; nval) val[now.second] = nval; <span class="comment">// 需要保证较大的j优先</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line">s[++tot] = p, key[tot] = nkey, val[tot] = nval;</span><br><span class="line">nxt[tot] = head[p], head[p] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(tot) head[s[tot--]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a^&#123;i * t&#125; == b * a^j (mod p)</span></span><br><span class="line"><span class="comment">// t = ceil(sqrt(p))</span></span><br><span class="line"><span class="comment">// 只有gcd(a, p) = 1才能有这种操作，否则膜p意义下无a的逆元，无法进行除法操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">a %= p, b %= p;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ht.clear();</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), lt = <span class="number">1</span>, rt = b, k = qpow(a, t, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;t; j++) &#123;</span><br><span class="line">ht.insert(rt, j);</span><br><span class="line">rt = (lint)rt * a % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i * t &lt; p + t; i++) &#123;</span><br><span class="line">lt = (lint)lt * k % p;</span><br><span class="line"><span class="keyword">int</span> j = ht.find(lt).first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j != <span class="number">-1</span>) <span class="keyword">return</span> i * t - j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, k;</span><br><span class="line">readint(T), readint(k);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">readint(a), readint(b), readint(p);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>) res = qpow(a, b, p);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">2</span>) &#123;</span><br><span class="line">a %= p;</span><br><span class="line">res = a != <span class="number">0</span> ? (lint)b * qpow(a, p - <span class="number">2</span>, p) % p : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">3</span>) res = bsgs(a, b, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"Orz, I cannot find x!"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h2&gt;&lt;span id=&quot;一-代码&quot;&gt;一、代码&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;注意判断无解&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="数论" scheme="http://arintaro.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="不定方程" scheme="http://arintaro.com/tags/%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多项式开根</title>
    <link href="http://arintaro.com/2019/12/01/Template/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%BC%80%E6%A0%B9/"/>
    <id>http://arintaro.com/2019/12/01/Template/数学/多项式/多项式开根/</id>
    <published>2019-12-01T12:36:27.192Z</published>
    <updated>2019-12-01T12:37:49.177Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h2><span id="一-代码">一、代码</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.com.cn/record/28011827</span></span><br><span class="line"><span class="comment">// with O2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g = <span class="number">3</span>, ginv, div2;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> br[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(i &lt; br[i]) swap(arr[i], arr[br[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>, w = qpow(g, (mod - <span class="number">1</span>) / len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *now=arr; now!=arr+n; now+=len) &#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mid; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = (lint)k * now[i + mid] % mod;</span><br><span class="line">now[i + mid] = (now[i] - x) % mod;</span><br><span class="line">now[i] = (now[i] + x) % mod;</span><br><span class="line">k = (lint)k * w % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp_inv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> res[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>, tc = <span class="number">0</span>, *temp = temp_inv;</span><br><span class="line"><span class="keyword">while</span>(t &lt; <span class="number">2</span> * n) t &lt;&lt;= <span class="number">1</span>, tc++;</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * t * <span class="number">2</span>), <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * t * <span class="number">2</span>);</span><br><span class="line">res[<span class="number">0</span>] = qpow(arr[<span class="number">0</span>], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">2</span>, nc=<span class="number">1</span>; now&lt;=t; now&lt;&lt;=<span class="number">1</span>, nc++) &#123;</span><br><span class="line"><span class="keyword">int</span> len = now &lt;&lt; <span class="number">1</span>, len_inv = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) br[i] = (br[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; nc);</span><br><span class="line"><span class="built_in">memcpy</span>(temp, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * now);</span><br><span class="line">ntt(res, g, len), ntt(temp, g, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) res[i] = res[i] * (<span class="number">2</span> - (lint)res[i] * temp[i] % mod) % mod;</span><br><span class="line">ntt(res, ginv, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;now; i++) res[i] = (lint)res[i] * len_inv % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=now; i&lt;len; i++) res[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> now_inv[maxn], temp_sqrt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsqrt</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> res[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>, tc = <span class="number">0</span>, *temp = temp_sqrt;</span><br><span class="line"><span class="keyword">while</span>(t &lt; <span class="number">2</span> * n) t &lt;&lt;= <span class="number">1</span>, tc++;</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * t * <span class="number">2</span>), <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * t * <span class="number">2</span>);</span><br><span class="line">res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">2</span>, nc=<span class="number">1</span>; now&lt;=t; now&lt;&lt;=<span class="number">1</span>, nc++) &#123;</span><br><span class="line"><span class="keyword">int</span> len = now &lt;&lt; <span class="number">1</span>, len_inv = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line">getinv(res, now &gt;&gt; <span class="number">1</span>, now_inv);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) br[i] = (br[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; nc);</span><br><span class="line"><span class="built_in">memcpy</span>(temp, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * now);</span><br><span class="line">ntt(temp, g, len), ntt(now_inv, g, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) now_inv[i] = (lint)temp[i] * now_inv[i] % mod;</span><br><span class="line">ntt(now_inv, ginv, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;now; i++) res[i] = div2 * ((lint)now_inv[i] * len_inv % mod + res[i]) % mod;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) readint(arr[i]);</span><br><span class="line">ginv = qpow(g, mod - <span class="number">2</span>), div2 = qpow(<span class="number">2</span>, mod - <span class="number">2</span>);</span><br><span class="line">getsqrt(arr, n, ans);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i] &lt; <span class="number">0</span> ? ans[i] + mod : ans[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h2&gt;&lt;span id=&quot;一-代码&quot;&gt;一、代码&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="倍增" scheme="http://arintaro.com/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="多项式" scheme="http://arintaro.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="ntt" scheme="http://arintaro.com/tags/ntt/"/>
    
  </entry>
  
  <entry>
    <title>多项式求逆</title>
    <link href="http://arintaro.com/2019/12/01/Template/%E6%95%B0%E5%AD%A6/%E5%A4%9A%E9%A1%B9%E5%BC%8F/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/"/>
    <id>http://arintaro.com/2019/12/01/Template/数学/多项式/多项式求逆/</id>
    <published>2019-12-01T11:03:11.925Z</published>
    <updated>2019-12-01T11:05:10.613Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h2><span id="一-代码">一、代码</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.com.cn/problem/P4238</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1, *p2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1&lt;&lt;21, stdin)), p1 == p2 ? EOF : *p1++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getc(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getc()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getc()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> g = <span class="number">3</span>, ginv;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], br[maxn];</span><br><span class="line"><span class="keyword">int</span> res[maxn], temp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> g, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span>(i &lt; br[i]) swap(arr[i], arr[br[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>, w = qpow(g, (mod - <span class="number">1</span>) / len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *now=arr; now!=arr+n; now+=len) &#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mid; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = (lint)k * now[i + mid] % mod;</span><br><span class="line">now[i + mid] = (now[i] - x) % mod;</span><br><span class="line">now[i] = (now[i] + x) % mod;</span><br><span class="line">k = (lint)k * w % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果多次调用需要加上数组清空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">res[<span class="number">0</span>] = qpow(arr[<span class="number">0</span>], mod - <span class="number">2</span>); </span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>, tc = <span class="number">0</span>; <span class="comment">// t表示已经求好的长度</span></span><br><span class="line"><span class="keyword">while</span>(t &lt; n) &#123; </span><br><span class="line">t &lt;&lt;= <span class="number">1</span>, tc++;</span><br><span class="line"><span class="keyword">int</span> len = t &lt;&lt; <span class="number">1</span>, len_inv = qpow(len, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) br[i] = (br[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; tc);</span><br><span class="line"><span class="built_in">memcpy</span>(temp, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * t); <span class="comment">// 注意这里乘的原函数长度是t，那么需要其二倍的空间len用来乘法</span></span><br><span class="line">ntt(res, g, len), ntt(temp, g, len); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) res[i] = (lint)res[i] * (<span class="number">2</span> - (lint)res[i] * temp[i] % mod) % mod;</span><br><span class="line">ntt(res, ginv, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) res[i] = (lint)res[i] * len_inv % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=t; i&lt;len; i++) res[i] = <span class="number">0</span>; <span class="comment">// 别忘了清空</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) readint(arr[i]);</span><br><span class="line">ginv = qpow(<span class="number">3</span>, mod - <span class="number">2</span>);</span><br><span class="line">getinv(arr, n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i] &lt; <span class="number">0</span> ? res[i] + mod : res[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h2&gt;&lt;span id=&quot;一-代码&quot;&gt;一、代码&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="倍增" scheme="http://arintaro.com/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="多项式" scheme="http://arintaro.com/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="ntt" scheme="http://arintaro.com/tags/ntt/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P3768 简单的数学题</title>
    <link href="http://arintaro.com/2019/11/24/Answer/easy/"/>
    <id>http://arintaro.com/2019/11/24/Answer/easy/</id>
    <published>2019-11-24T13:52:52.321Z</published>
    <updated>2019-11-24T22:38:13.680Z</updated>
    
    <content type="html"><![CDATA[<p>然而并不简单<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定$n$与$p$，求<br>$$<br>\sum_{1 \leq i \leq n}{\sum_{1 \leq j \leq n}{i \times j \times \gcd(i, j)}}\ \text{mod}\ p<br>$$</p><p>$1 \leq n \leq 10^{10}$，保证$p$为质数。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先套路的变一波形</p><p>$$<br>\sum_{d}{(d \times \sum_{i, j}{i \times j \times [\gcd(i, j) = d])}}<br>$$<br>$$<br>\sum_{d}{(d^3 \times \sum_{1 \leq i, j \leq \lfloor\frac{n}{d}\rfloor}{i \times j \times [\gcd(i, j) = 1]})}<br>$$<br>显然中间变成了我们熟悉的前$n$对互质数的乘积，$[\gcd(i, j) = 1]$可以反演。</p><p>$$<br>\sum_{d}{(d^3 \times \sum_{1 \leq i, j \leq \lfloor\frac{n}{d}\rfloor}{(i \times j \times \sum_{p | i, p | j}{\mu(p)}}))}<br>$$</p><p>再次交换中间式子和求和顺序，加之$[p\ |\ \gcd(i, j)] = [p\ |\ i] \times [p\ |\ j]$</p><p>$$<br>\sum_{d}{(d^3 \times \sum_{p}{\mu(p) \sum_{i, j}{(i \times j \times [p\ |\ i] \times [p\ |\ j])}})}<br>$$</p><p>利用分配律，设$h(n) = \sum_{i=1}^{n}{i}$</p><p>$$<br>\sum_{1\leq d \leq n}{(d^3 \times \sum_{1 \leq p \leq \lfloor \frac{n}{d} \rfloor }{\mu(p) \times p^2 \times (h(\lfloor \frac{n}{pd} \rceil })^2)}<br>$$</p><p>然后我第一次写推到这里就没推了，这里显然已经可以做到线性，但是数据范围线性不够，所以我写了一个玄学的数列分块套数列分块再套一个杜教筛，实测可以跑到$10^8$，然而还是跑不了$10^9$与线性同样是$60pts$。</p><p>看完题解后发现可以从第一步直接用$\phi$进行反演，这无疑与套路不太一样，所以我接着尝试交换求和顺序，化简上个式子。</p><p>要把什么交换出来呢？按常规的把$\mu(p)$也不可以，降不了复杂度，因为这即便交换出来，两层的上下界还是一个范围内的整数。通常降复杂度需要先行外层枚举「约束性较强的条件」，以利于内部的计算，其不一定是一个变量，也有可能是一个代数式。</p><p>在本题中，我们枚举的「较强条件」即为$t = p \times d$，在外层枚举它后，内层可以只考虑其约数，约数下的限制条件显然是有利于进一步反演的。</p><p>枚举$t$后，交换求和顺序，内层只需枚举$p, d$中的一个，另一个可以直接算出。<br>$$<br>\sum_{1 \leq t \leq n}{((h(\lfloor \frac{n}{t} \rfloor))^2 \times t^2 \sum_{p|t}{(\mu(p) \times \frac{t}{p})}}<br>$$</p><p>注意到有结论$\phi <em> 1 = \text{id}$，两边同时卷一个$\mu$，即得到$\phi = \text{id} </em> \mu$，上式化为<br>$$<br>\sum_{1 \leq t \leq n}{((h(\lfloor \frac{n}{t} \rfloor))^2 \times t^2 \times \phi(t))}<br>$$</p><p>于是数论分块套杜教筛即可在低于线性的复杂度求解。</p><p>本题也可以一开始就用$\phi = \text{id} * \mu$反演$\gcd$，推导会更加容易。</p><p>另外补一个结论$\sum_{i=1}^{n}i^3=(\sum_{i=1}^{n}i)^2$</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxprimes = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod, pren, div2, div6;</span><br><span class="line">lint n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; b; b&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (lint)res * a % mod;</span><br><span class="line">a = (lint)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mHash_table</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">5e6</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], nxt[maxn], val[maxn], tot;</span><br><span class="line">lint key[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(lint nkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[p]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(key[i] == nkey) <span class="keyword">return</span> val[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(lint nkey, <span class="keyword">int</span> nval)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(find(nkey) != inf) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> p = nkey % htmod;</span><br><span class="line">key[++tot] = nkey, val[tot] = nval;</span><br><span class="line">nxt[tot] = head[p], head[p] = tot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="keyword">int</span> minfac[maxn], primes[maxprimes], totprimes = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(minfac[i] == <span class="number">0</span>) minfac[i] = i, phi[i] = i - <span class="number">1</span>, primes[++totprimes] = i;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>, maxp=min(n/i, minfac[i]); j&lt;=totprimes &amp;&amp; primes[j]&lt;=maxp; j++) &#123;</span><br><span class="line">minfac[i * primes[j]] = primes[j];</span><br><span class="line"><span class="keyword">if</span>(primes[j] == minfac[i]) phi[i * primes[j]] = phi[i] * primes[j];</span><br><span class="line"><span class="keyword">else</span> phi[i * primes[j]] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) phi[i] = (phi[i<span class="number">-1</span>] + (lint)phi[i] * i % mod * i % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calc1(n) ((lint)(n) * ((n) + 1) % mod * div2 % mod)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc3</span><span class="params">(lint n)</span> </span>&#123;</span><br><span class="line">n %= mod;</span><br><span class="line"><span class="keyword">return</span> calc1(n) * calc1(n) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc2</span><span class="params">(lint n)</span> </span>&#123;</span><br><span class="line">n %= mod;</span><br><span class="line"><span class="keyword">return</span> n * (n + <span class="number">1</span>) % mod * (<span class="number">2</span> * n + <span class="number">1</span>) % mod * div6 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask_sum</span><span class="params">(lint n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= pren) <span class="keyword">return</span> phi[n];</span><br><span class="line"><span class="keyword">int</span> res = ht.find(n);</span><br><span class="line"><span class="keyword">if</span>(res != inf) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">else</span> res = calc3(n);</span><br><span class="line"><span class="keyword">for</span>(lint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">lint d = n / i, j = min(n, n / d);</span><br><span class="line">res = (res - (lint)(calc2(j) - calc2(i<span class="number">-1</span>)) * ask_sum(d) % mod) % mod;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">res = res &lt; <span class="number">0</span> ? res + mod : res;</span><br><span class="line">ht.insert(n, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(lint n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(lint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">lint d = n / i, j = min(n, n / d);</span><br><span class="line"><span class="keyword">int</span> t = d % mod;</span><br><span class="line">res = (res + (lint)(ask_sum(j) - ask_sum(i<span class="number">-1</span>)) * calc1(t) % mod * calc1(t) % mod) % mod;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res &lt; <span class="number">0</span> ? res + mod : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(mod), readint(n);</span><br><span class="line">pren = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3</span>), div2 = qpow(<span class="number">2</span>, mod - <span class="number">2</span>), div6 = qpow(<span class="number">6</span>, mod - <span class="number">2</span>);</span><br><span class="line">prework(pren);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;然而并不简单&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="快速求和" scheme="http://arintaro.com/tags/%E5%BF%AB%E9%80%9F%E6%B1%82%E5%92%8C/"/>
    
  </entry>
  
</feed>
