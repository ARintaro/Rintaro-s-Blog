<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2019-10-31T02:19:54.936Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>USACO12FEB 附近的牛 Nearby Cows</title>
    <link href="http://arintaro.com/2019/10/31/Answer/color/"/>
    <id>http://arintaro.com/2019/10/31/Answer/color/</id>
    <published>2019-10-31T02:03:25.740Z</published>
    <updated>2019-10-31T02:19:54.936Z</updated>
    
    <content type="html"><![CDATA[<p>强行与牛有关<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>有一棵点数为$n$的树，树边有边权，你要在这棵树中选择$k$个点，将其染成黑色，并将其他的$n-k$个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益，问收益最大值。</p><p>$1&lt;=n&lt;=2000$，$0&lt;=k&lt;=n$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>先迅速地打出暴力，枚举选哪些，然后每个节点作根暴力计算答案，手玩了一下没发现有什么贪心性质。</p><p>由于是树上的路径之和，考虑类似树上差分的想法，即有很多个点对，每次都会把它们之间的路径覆盖一次，求每个边的边权乘以覆盖次数的和，对每条边计算覆盖次数即可。</p><p>此题中的覆盖一条边的覆盖次数显然是子树中的某色点数量乘子树外的某色点数量，由于色点数量给定，一旦我们知道了一端的数量，就能通过整体减去局部的方法计算出另外一端。</p><p>所以可以先确定自下而上的计算顺序，状态定义为某个子树中选$k$个黑点所有边产生的最大贡献，类似费用提前计算，之后直接跑树上背包即可，注意应用上下界剪枝优化到$O(n^2)$</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw;</span><br><span class="line">nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计路径贡献 -&gt; 树上差分，考虑一条边的贡献 (费用提前计算)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体减局部为另外，正难则反</span></span><br><span class="line"><span class="comment">// 以x为根的子树，k个黑点，所有边的最大贡献</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">lint dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line"><span class="keyword">for</span>(rint j=min(m, size[x] + size[y]); j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint k=max(<span class="number">0</span>, j-size[x]); k&lt;=j &amp;&amp; k&lt;=size[y]; k++) &#123;</span><br><span class="line">dp[x][j] = max(dp[x][j], dp[x][j-k] + dp[y][k] + (lint)k * (m - k) * ew[i] +</span><br><span class="line">((lint)size[y] - k) * (n - size[y] - (m - k)) * (lint)ew[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">size[x] += size[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[root][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强行与牛有关&lt;br&gt;
    
    </summary>
    
      <category term="USACO" scheme="http://arintaro.com/categories/USACO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/USACO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>USACO12FEB 附近的牛 Nearby Cows</title>
    <link href="http://arintaro.com/2019/10/31/Answer/cow1/"/>
    <id>http://arintaro.com/2019/10/31/Answer/cow1/</id>
    <published>2019-10-31T00:26:43.109Z</published>
    <updated>2019-10-31T01:22:21.943Z</updated>
    
    <content type="html"><![CDATA[<p>强行与牛有关<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>树上每个点有一个点权，求每个点距离不超过$k$的点权。<br>其中$1&lt;=k&lt;=20$, $1&lt;=n&lt;=10^5$</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>注意要求全部点的答案，并且$k$较小，所以很可能是个换根DP。</p><p>又注意到对于任意一种转移顺序，某个点$x$的$dp[x][k]$，不可能转移到$y$的$dp[x][k+1]$，所以可以直接在状态内记录当前点范围为$k$的答案。规定计算顺序自下而上，先确定一个根，计算子树内的信息，之后再自上而下的根据父节点的答案算这个节点的答案即可。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">20</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn][maxk], res[maxn][maxk];</span><br><span class="line"><span class="comment">// 从x出发不超过k</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(y, x);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=m; k++) sum[x][k] += sum[y][k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">res[y][<span class="number">0</span>] = sum[y][<span class="number">0</span>];</span><br><span class="line">res[y][<span class="number">1</span>] = sum[y][<span class="number">1</span>] + sum[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">2</span>; k&lt;=m; k++) &#123;</span><br><span class="line">res[y][k] = res[x][k<span class="number">-1</span>] - sum[y][k<span class="number">-2</span>] + sum[y][k];</span><br><span class="line">&#125;</span><br><span class="line">dfs2(y, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(x), readint(y);</span><br><span class="line">addedge(x, y), addedge(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(sum[i][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=m; k++) sum[i][k] = sum[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">dfs1(root, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;=m; k++) res[root][k] = sum[root][k];</span><br><span class="line">dfs2(root, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i][m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强行与牛有关&lt;br&gt;
    
    </summary>
    
      <category term="USACO" scheme="http://arintaro.com/categories/USACO/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/USACO/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="换根法" scheme="http://arintaro.com/tags/%E6%8D%A2%E6%A0%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HNOI2003 消防局的设立</title>
    <link href="http://arintaro.com/2019/10/30/Answer/fire/"/>
    <id>http://arintaro.com/2019/10/30/Answer/fire/</id>
    <published>2019-10-30T08:24:46.725Z</published>
    <updated>2019-10-30T09:44:29.080Z</updated>
    
    <content type="html"><![CDATA[<p>少数几道贪心扩展性超过DP的题目<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>从树上选出最少的点，每个点可以覆盖与它距离不超过2的点，求最少需要选出多少点。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>贪心做法扩展性强，且容易理解，但是这里不讲。<br>本问题有很多前置形态，比如”每条边连接的两点必须任选一个”, 只需要记录每个点选不选就行了，但是此题影响的距离是2，这启发我们需要在DP状态上记录更多的信息便于转移。</p><p>树上问题一般要先确定计算顺序是自上而下还是自下而上，这里选择自上而下显然不容易设计出状态，所以选择每次从子树向上转移的自下而上。</p><p>确定计算顺序后，容易想到状态是”某范围中的点都被管辖所需要的最少点数”，按常规考虑是一个点子树中的点都被管辖，但是手玩几组数据发现，这样设计状态，一个点是可以从它的孙子甚至曾孙转移来的，这样设计状态难以转移，如果暴力追溯转移，时间上显然会爆炸。不容易优化转移，考虑重新设计状态，又想到附加儿子或孙子选不选的小范围状压维度，进一步考虑，我们事实上不关心子树中选了什么点，而是想通过知道这些点选没选而得知它向上覆盖的范围，所以我们规定状态为”某个点向上/向下覆盖了多少层选的最少点数”, 考虑一个节点$x$，它向下两层的节点必须在它这里被覆盖，否则按照我们的计算顺序，它以后都没机会被覆盖了，所以状态中记录的向上向下的最大层数为2。</p><p>接着考虑如何转移，$dp[x][0]$为它的孙子被完全覆盖, 1为儿子都被覆盖, 2为自己被覆盖, 3为父亲被覆盖, 4为祖父为覆盖。</p><p>下设$y$为$x$的儿子，显然有<br>$$<br>dp[x][0] = \sum{dp[y][1]}<br>$$<br>与<br>$$<br>dp[x][1] = \sum{dp[y][2]}<br>$$</p><p>先暂缓一下，这样转移可能会遗漏某些情况，这样转移状态的严谨定义就变成”刚好覆盖到某层的最少点数”，但是会不会有时往上多覆盖了反而用了更少的点？考虑一个边界情况，按照此定义，对于一个叶子节点$x$，$dp[x][2]$显然无法成立，需要设成inf，这显然会影响后续的转移，所以不妨直接将状态定义为”至少覆盖到这层”的最小点数，也可以理解为对状态求后缀min。按此定义，我们可以先按照上述的递推式计算，当$x$的所有状态计算完毕后，再扫一遍取后缀min。</p><p>当覆盖到$x$下面时，子树是分叉的，所有点都需要被覆盖，因此需要求和。但当覆盖到$x$时或以上，变成了只有一支，所以我们只需要覆盖一次，其余子树选最小能覆盖的即可。所以有：<br>$$<br>dp[x][2] = \min(dp[y][3] + \sum_{s \not = y}{dp[s][2]})<br>$$<br>为了程序实现方便，上述方程可以改写为<br>$$<br>dp[x][2] = dp[x][1] + \min(dp[y][3] - dp[y][2])<br>$$<br>当能覆盖$x$上一层时，需要某个子节点向上覆盖两层，需要注意这个覆盖对于其他子树也会成立，因此有<br>$$<br>dp[x][3] = \min(dp[y][4] + \sum_{s \not = y}{dp[s][1]})<br>$$<br>当$x$向上覆盖两层，显然$x$一定是被选上的，所以有<br>$$<br>dp[x][4] = \sum{dp[y][0]} + 1<br>$$<br>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 影响后续计算的放状态里</span></span><br><span class="line"><span class="comment">// 树形问题计算顺序自下而上，自上而下</span></span><br><span class="line"><span class="comment">// 自下而上</span></span><br><span class="line"><span class="comment">// dp[x][0]表示x一层以下都被覆盖最少代价</span></span><br><span class="line"><span class="comment">// dp[x][1] x以下都被覆盖</span></span><br><span class="line"><span class="comment">// dp[x][2] x被覆盖</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[x][2] = dp[x][1] + min&#123;- dp[y][2] + dp[y][3]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">dp[x][<span class="number">2</span>] = dp[x][<span class="number">3</span>] = maxn;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(y, x);</span><br><span class="line">dp[x][<span class="number">4</span>] += dp[y][<span class="number">0</span>];</span><br><span class="line"><span class="comment">// x一层以下都被覆盖</span></span><br><span class="line">dp[x][<span class="number">0</span>] += dp[y][<span class="number">1</span>];</span><br><span class="line"><span class="comment">// x以下被覆盖</span></span><br><span class="line">dp[x][<span class="number">1</span>] += dp[y][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// x被覆盖</span></span><br><span class="line">dp[x][<span class="number">2</span>] = min(dp[x][<span class="number">2</span>], dp[y][<span class="number">3</span>] - dp[y][<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// x上一层被覆盖</span></span><br><span class="line">dp[x][<span class="number">3</span>] = min(dp[x][<span class="number">3</span>], dp[y][<span class="number">4</span>] - dp[y][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">dp[x][<span class="number">4</span>]++, dp[x][<span class="number">2</span>] += dp[x][<span class="number">1</span>], dp[x][<span class="number">3</span>] += dp[x][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">3</span>; k&gt;=<span class="number">0</span>; k--) dp[x][k] = min(dp[x][k], dp[x][k+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">2</span>, y; x&lt;=n; x++) &#123;</span><br><span class="line">readint(y);</span><br><span class="line">addedge(x, y), addedge(y, x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[root][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;少数几道贪心扩展性超过DP的题目&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="后效性的处理" scheme="http://arintaro.com/tags/%E5%90%8E%E6%95%88%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://arintaro.com/2019/10/28/Template/%E5%AD%97%E7%AC%A6%E4%B8%B2/ac/"/>
    <id>http://arintaro.com/2019/10/28/Template/字符串/ac/</id>
    <published>2019-10-28T14:07:45.546Z</published>
    <updated>2019-10-28T22:38:49.434Z</updated>
    
    <content type="html"><![CDATA[<p>大概可以用来AC, 本文主要是记录性质, 大概会看不懂。<br><a id="more"></a> </p><h2><span id="一-概念">一、概念</span></h2><p>@card{</p><p>AC自动机是基于Trie建立的, Trie上的一个节点到根节点的路径会确定唯一的一个字符串,表示的是插入Trie的某个字符串的前缀。</p><p>解决多模式串匹配问题时, 先把所有的模式串插入Trie中, 再进行建树。</p><p>AC自动机对于Trie上的每个节点构造fail指针, 其指向<strong>Trie上与这个节点的后缀匹配的最长真前缀</strong>的节点, 朴素的计算方法类似KMP或者是递推, 如果父节点的fail不能继续匹配自身, 就跳fail到次长, 如果找不到就连在根节点上, 时间复杂度显然不优, 优化后建出Trie图, 同时修改Trie上边的定义, 为<strong>当前节点加上这个字符后的后缀Trie上能匹配的最长前缀</strong>, 由于没有”真”, 这对原Trie上的边也是适用的。然后我们就可以递推地以深度作为状态去计算这两种指针, 当遍历到一个节点时, 遍历字符集, 当原Trie上有这条边时, 我们需要计算它的fail, 显然是$pv[fail[x]][c]$, 即与当前节点后缀匹配的最长真前缀再加上转移的字符的后缀在Trie上能匹配的最长前缀(大概用形式化的语言说出来就没有这么绕了), 感性的理解一下就是尝试给fail再加个字符去匹配, 需要对自身跳fail去找是因为fail需要是<strong>真</strong>前缀。</p><p>多模式串匹配时, 按序遍历主串, 每次当前节点跳Trie图上的边即可, 即对每个主串的前缀, 用它的后缀去找Trie上能匹配的最长前缀, 找到这个最长前缀后, 从它一直跳fail跳到根节点, 就能找到Trie上所有能与这个后缀匹配的前缀了。</p><p>注意每个节点有且仅有一条fail边, 那么其实所有fail边与点构成一棵树, 一个节点往上跳fail的过程其实就遍历它到根节点的路径, 基于这个性质, 我们可以在fail树上跑一些树形数据结构来维护一些东西。如维护出现次数树上差分等。</p><p>}</p><h2><span id="二-实现">二、实现</span></h2><h2><span id="三-代码">三、代码</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概可以用来AC, 本文主要是记录性质, 大概会看不懂。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="字符串" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="树上问题" scheme="http://arintaro.com/tags/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
      <category term="字符串" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>小型人类智慧题/脑筋急转弯汇总</title>
    <link href="http://arintaro.com/2019/10/27/Answer/brain/"/>
    <id>http://arintaro.com/2019/10/27/Answer/brain/</id>
    <published>2019-10-27T13:24:46.584Z</published>
    <updated>2019-10-27T13:37:28.570Z</updated>
    
    <content type="html"><![CDATA[<p>自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。<br><a id="more"></a></p><h2><span id="t1-盛最多水的容器">T1: 盛最多水的容器</span></h2><p>@card{</p><p>site: <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>给定一个数组, 要求$O(n)$求出最大的$|i - j| \times \min(arr[i], arr[j])$。</p><p>考虑枚举一个端点, 用$O(1)$的时间求出另一端的最优决策, 发现很难维护, 没有决策单调性, 按照$arr[j]$的大小分组用斜率优化+数据结构维护复杂度势必要多个$log$。</p><p>考虑重排序, 发现无论按下标排序or按值排序$abs$与$min$都很难维护。</p><p>正解是左右两端指针往中间扫, 即不确定”主指针”, 而是每次考虑移动任意一个指针去掉不可能的答案。这里每次只要把值较小的指针往中间移动即可, 正确性显然, 考虑任意一个端点在当前指针区间$[l, r]$外的的决策已经被更新进答案, 不妨设$arr[l]$较小, 则移动$l$其实就是去掉了所有左端点为$l$, 右端点在$(l, r]$的决策, 这其中的决策显然没有$[l, r]$好, 所以就推到了指针区间$[l+1, r]$所有区间外的决策已经被正确更新, 由数学归纳法知这么做不会遗漏答案。</p><p>}</p><h2><span id="solution">Solution:</span></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己想出来是不可能的, 这辈子都不可能的, 抄题解就像回家一样。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="人类智慧" scheme="http://arintaro.com/tags/%E4%BA%BA%E7%B1%BB%E6%99%BA%E6%85%A7/"/>
    
  </entry>
  
  <entry>
    <title>小工具合集</title>
    <link href="http://arintaro.com/2019/10/27/Template/%E5%B0%8F%E5%B7%A5%E5%85%B7/small-tool/"/>
    <id>http://arintaro.com/2019/10/27/Template/小工具/small-tool/</id>
    <published>2019-10-27T10:21:08.341Z</published>
    <updated>2019-10-27T10:35:40.796Z</updated>
    
    <content type="html"><![CDATA[<p>比较有用, 但比较简短懒得单独开一页的技巧。<br><a id="more"></a></p><h4><span id="1二进制子集枚举">1.二进制子集枚举</span></h4><p>@card{<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S = <span class="number">22</span>; <span class="comment">// 全集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=S; i; i=(i<span class="number">-1</span>)&amp;S) &#123;</span><br><span class="line">    <span class="comment">// 此时i即为S的子集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举$n$位二进制数, 再依次枚举它的子集, 复杂度为$O(3^n)$<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较有用, 但比较简短懒得单独开一页的技巧。&lt;br&gt;
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="工具" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="语言" scheme="http://arintaro.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="奇淫技巧" scheme="http://arintaro.com/tags/%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Luogu 买菜</title>
    <link href="http://arintaro.com/2019/10/27/Answer/vegetable/"/>
    <id>http://arintaro.com/2019/10/27/Answer/vegetable/</id>
    <published>2019-10-27T02:00:24.681Z</published>
    <updated>2019-10-27T02:26:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>模拟赛里的题, 没有题面(<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个字符串 𝑆 和一个字符串集合 𝑇，询问 𝑆 中最短的包含 𝑇 的子串。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>如果我们能够在不会T掉的时间内处理出所有字符串的出现位置, 这个问题就可以直接变成选区间问题, 从而应用双指针或其他算法解决。但我考场一想, 这个玩意不是$O(n^2)$级的么, 根本不可能。然而事实上远远不到这个级别, 考虑按长度分组, 去重后每个长度显然至多会有$O(n)$级的匹配数, 由于总长度给定, 不同长度的数量至多有$O(\sqrt{n})$种, 所以是$O(n\sqrt{n})$的。</p><h4><span id="算法1-字符串hash-双指针">算法1: 字符串hash + 双指针</span></h4><p>基于上述复杂度证明, 我们可以采用子串hash与hash表直接得到一个$O(n\sqrt{m} + m)$的多模式串匹配算法, 其中$m$为模式串总长度。具体做法是去重后按长度分组, 扫描前把这个长度的字符串的hash值插入hash表, 然后匹配即可。所以问题转化为:</p><blockquote><p>在长为m的直线上有n种区间, 求直线覆盖所有n种区间的最短线段</p></blockquote><p>做法有很多, 我的做法是开两个vector记录区间起点与终点：如果左指针扫到了一个起点, 那么对应种类的计数直接减一(其中可能会有当前右指针尚未扫到这个区间的终点, 导致计数器变成负数的情况, 不过不要紧); 如果右指针扫到了一个终点, 计数器直接加一, 如果计数器当前为负数, 就相当于”还上了之前欠的债”。每个区间被选上的条件是它自己的出现计数器大于等于$1$。对每个左指针让右指针一直往右扫, 直到当前选上了全部的区间。</p><h4><span id="算法2-ac自动机后缀平衡树-二叉堆">算法2: AC自动机/后缀平衡树 + 二叉堆</span></h4><p>我还不会, 待更。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eco(c) ((int)(c) - 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ull base = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> htmod = <span class="number">5000087</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mhash_set</span>&#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> maxnode = htmod + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxnode], nxt[<span class="number">2</span> * maxn], id[<span class="number">2</span> * maxn], totnode;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">2</span> * maxn], stop;</span><br><span class="line">ull val[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">totnode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(stop) head[s[stop--]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ull x, <span class="keyword">int</span> nid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = x % htmod;</span><br><span class="line">s[++stop] = pos;</span><br><span class="line">val[++totnode] = x, id[totnode] = nid;</span><br><span class="line">nxt[totnode] = head[pos], head[pos] = totnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(ull x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pos = x % htmod;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[pos]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(val[i] == x) <span class="keyword">return</span> id[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">calc_hash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">ull res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=len; i++) res = res * base + eco(s[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ull prehash[maxn], basepow[maxn];</span><br><span class="line"><span class="keyword">char</span> s1[maxn], temp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一维编号， 第二维1表示开始，-1表示结束</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">str</span>&#123;</span></span><br><span class="line">ull x; <span class="keyword">int</span> len;</span><br><span class="line">str() &#123;&#125;</span><br><span class="line">str(ull xx, <span class="keyword">int</span> ll): x(xx), len(ll) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> str&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;s2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">calc_hash</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> prehash[R] - prehash[L - <span class="number">1</span>] * basepow[R - L + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=m; i++) &#123;</span><br><span class="line">ull res = calc_hash(i, i + len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> nid = ht.find(res);</span><br><span class="line"><span class="keyword">if</span>(nid != <span class="number">0</span>) &#123;</span><br><span class="line">st[i].push_back(nid), ed[i + len - <span class="number">1</span>].push_back(nid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; st[maxn], ed[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt_color[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans_len, ans_l, ans_r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre = (cnt_color[c] &gt;= <span class="number">1</span>);</span><br><span class="line">cnt_color[c] += x;</span><br><span class="line">cnt += (cnt_color[c] &gt;= <span class="number">1</span>) - pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ans_len = m;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= m &amp;&amp; cnt &lt; n) &#123;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;ed[j].size(); k++) update(ed[j][k], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j &gt; m) <span class="keyword">return</span>;</span><br><span class="line"> <span class="keyword">if</span>(j - i + <span class="number">1</span> &lt; ans_len) &#123;</span><br><span class="line">ans_len = j - i + <span class="number">1</span>, ans_l = i, ans_r = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">0</span>; k&lt;st[i].size(); k++) update(st[i][k], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">basepow[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s1+<span class="number">1</span>), m = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">basepow[i] = basepow[i<span class="number">-1</span>] * base;</span><br><span class="line">prehash[i] = prehash[i<span class="number">-1</span>] * base + eco(s1[i]);</span><br><span class="line">&#125;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, temp+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(temp + <span class="number">1</span>); ull res = calc_hash(temp, len);</span><br><span class="line"><span class="keyword">if</span>(!ht.find(res)) &#123;</span><br><span class="line">s2[++tot] = str(res, len), ht.insert(res, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = tot;</span><br><span class="line">sort(s2+<span class="number">1</span>, s2+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> l = i, r = i;</span><br><span class="line"><span class="keyword">while</span>(r &lt;= n &amp;&amp; s2[r].len == s2[l].len) r++;</span><br><span class="line">i = --r;</span><br><span class="line">ht.clear();</span><br><span class="line"><span class="keyword">for</span>(rint j=l; j&lt;=r; j++) ht.insert(s2[j].x, j);</span><br><span class="line">match(s2[l].len);</span><br><span class="line">&#125;</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(rint i=ans_l; i&lt;=ans_r; i++) <span class="built_in">putchar</span>(s1[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模拟赛里的题, 没有题面(&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字符串" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="字符串匹配" scheme="http://arintaro.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="双指针" scheme="http://arintaro.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1121 环状最大两段子段和</title>
    <link href="http://arintaro.com/2019/10/24/Answer/sum/"/>
    <id>http://arintaro.com/2019/10/24/Answer/sum/</id>
    <published>2019-10-24T13:24:25.109Z</published>
    <updated>2019-10-24T14:09:04.321Z</updated>
    
    <content type="html"><![CDATA[<p>大概特判才是主要难点(<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个环状序列, 可以选其中两段连续不相交的子段, 求它们的最大和</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于这种”两段”问题的处理, 一般有两种方法：第一种是枚举切点, 用前后两段的”一段”的最优去组合答案；第二种是在DP状态内记录当前选了几段, 从而进行转移。</p><h4><span id="算法1-枚举切点-正难则反">算法1: 枚举切点, 正难则反</span></h4><p>考虑序列上怎么做, 显然可以枚举切点用前后两段的最大子段和组合答案。顺着想到可以破环成链跑类似的算法, 然而可能前后两段的长度加起来超过$n$, 从而使答案变大, 这里可以用数据结构维护不同长度的答案(eg. 可持久化平衡树), 然而无论怎么样, 复杂度都会多个$log$。</p><p>考虑在序列上跑完遗落了什么情况, 显然是前后两段接到一起和中间的一段组成答案, 发现这其实在序列上体现为三段, 这三段又分出来了两段, 最优解中这两段之和显然是最小的, 那么用总和减去”序列上最小两段子段和”, 一定能覆盖这种情况。</p><p>然而到这里还远没有结束, 考虑边界情况, 第一种情况只要我们枚举的”两个数之间的断点”在序列中间, 前后两段加起来至少会有两个数字, 因此是没有问题的。但是第二种情况, 我们求出的”序列上最小两段子段和”的长度$len &gt; n-2$的话, 求出来的解就是没有意义的, 由于特判范围较小, 考虑进行讨论。当$len = n$时, 显然序列中必然全是负数, 否则我们在一个正数两边切点就能得到更小的解; 当$len = n-1$时, 我们用来更新答案的值必然是序列中最大的正数, 如果存在另外一个正数, 那么第一种情况一定会比第二种情况求出的答案优秀, 不影响答案, 如果不存在另外一个正数, 那么序列中有且仅有一个正数, 我们显然可以直接得到答案。</p><p>综上, 当序列中正数只有$0$个或$1$个时, 答案为序列中的最大值加次小值, 否则可以应用我们上述的算法, 正确求出答案。</p><h4><span id="算法2-动态规划-一次断开-一次强制连接">算法2: 动态规划, 一次断开, 一次强制连接</span></h4><p>考虑序列上怎么做, 显然我们可以在状态内记录当前选了几个, 以及上个选没选(其实记录上个选没选可以理解为一种小范围的状态压缩去解决一定的后效性)来转移。如果破环成链势必又面临维护麻烦的长度限制的问题, 所以考虑强制连接。</p><p>强制连接后前后两个视为一段, 在中间找第三段即可, 即求出不强制连接时的两段答案, 和强制连接后的三段答案就可覆盖所有情况。</p><p>这种方法常数不太好, 但是不用考虑麻烦的边界情况, 是考场比较优秀的算法。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = -inf, sum, max1 = -inf, max2 = -inf;</span><br><span class="line"><span class="keyword">int</span> presum[maxn], sufsum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) presum[i] = max(presum[i<span class="number">-1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line"><span class="keyword">for</span>(rint i=n; i&gt;=<span class="number">1</span>; i--) sufsum[i] = max(sufsum[i+<span class="number">1</span>], <span class="number">0</span>) + arr[i];</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) presum[i] = max(presum[i<span class="number">-1</span>], presum[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) sufsum[i] = max(sufsum[i+<span class="number">1</span>], sufsum[i]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(arr[i]), sum += arr[i];</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt;= <span class="number">0</span>) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt;= max1) max2 = max1, max1 = arr[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; max2) max2 = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">ans = max1 + max2;</span><br><span class="line"><span class="keyword">if</span>(cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">calc();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) ans = max(ans, presum[i] + sufsum[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) arr[i] = -arr[i];</span><br><span class="line">calc();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) ans = max(ans, sum + presum[i] + sufsum[i+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概特判才是主要难点(&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="经典模型" scheme="http://arintaro.com/tags/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="正难则反" scheme="http://arintaro.com/tags/%E6%AD%A3%E9%9A%BE%E5%88%99%E5%8F%8D/"/>
    
      <category term="两段处理" scheme="http://arintaro.com/tags/%E4%B8%A4%E6%AE%B5%E5%A4%84%E7%90%86/"/>
    
      <category term="环形处理" scheme="http://arintaro.com/tags/%E7%8E%AF%E5%BD%A2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1654 OSU!</title>
    <link href="http://arintaro.com/2019/10/24/Answer/osu/"/>
    <id>http://arintaro.com/2019/10/24/Answer/osu/</id>
    <published>2019-10-24T05:40:42.504Z</published>
    <updated>2019-10-30T08:28:01.841Z</updated>
    
    <content type="html"><![CDATA[<p>感觉期望还是比较冷门的考察方向<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一个$n$个位置, 每个位置有$p_i$的概率为$1$, 否则为0, 每一段极大连续的$1$会产生长度的三次方的分数, 求分数的期望值</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>考虑逐个把1加入计算贡献, 不妨假设前$i-1$个位置的得分期望已经正确求出,。当该位为0时, 显然答案直接累加$i-1$的即可；当该位为1时, 会增大所有”后缀连续1”的贡献, 而对其他贡献没有影响: 对于一个长度在这之前已经为$x$的后缀1段, 增大的贡献显然为$(x + 1)^3 - x^3 = 3x^2 + 3x + 1$, 对于所有这样的串考虑显然只需要代入期望值即可, 所以需要分别维护后缀长度平方的期望和后缀长度的期望。 </p><p>注意后缀长度平方的期望不能直接由后缀长度的期望直接平方得到, 因为它自身显然是不独立的, 不能直接用期望的乘法性质, 乘法要求两个随机变量相互独立。则有:</p><p>$$E(A^3_n) = p_i (E(A^3_n-1) + 3E(B^2_n-1) + 3E(B_n-1) + 1) + (1 - p_i) E(A^3_n-1)$$<br>$$E(B^2_n) = p_i (E(B^2_n-1) + 2E(B_n-1) + 1) + (1 - p_i) \times 0$$<br>$$E(B_n) = p_i(E(B_n-1) + 1) + (1 - p_i) \times 0$$</p><p>Luogu上的题解也有很多从另外的角度思考了, 复习的时候可以看一下：<a href="https://www.luogu.org/problemnew/solution/P1654" target="_blank" rel="noopener">https://www.luogu.org/problemnew/solution/P1654</a><br>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ldob long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ldob EA3[maxn], EB1[maxn], EB2[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%Lf"</span>, &amp;p[i]);</span><br><span class="line">EB1[i] = p[i] * (EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * <span class="number">0</span>;</span><br><span class="line">EB2[i] = p[i] * (EB2[i<span class="number">-1</span>] + <span class="number">2</span> * EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * <span class="number">0</span>;</span><br><span class="line">EA3[i] = p[i] * (EA3[i<span class="number">-1</span>] + <span class="number">3</span> * EB2[i<span class="number">-1</span>] + <span class="number">3</span> * EB1[i<span class="number">-1</span>] + <span class="number">1</span>) + (<span class="number">1</span> - p[i]) * EA3[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1Lf\n"</span>, EA3[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉期望还是比较冷门的考察方向&lt;br&gt;
    
    </summary>
    
      <category term="Luogu" scheme="http://arintaro.com/categories/Luogu/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/Luogu/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="递推" scheme="http://arintaro.com/tags/%E9%80%92%E6%8E%A8/"/>
    
      <category term="期望" scheme="http://arintaro.com/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2013 花匠</title>
    <link href="http://arintaro.com/2019/10/23/Contest/NOIP%202013/flower/"/>
    <id>http://arintaro.com/2019/10/23/Contest/NOIP 2013/flower/</id>
    <published>2019-10-23T11:53:29.869Z</published>
    <updated>2019-10-24T05:42:26.448Z</updated>
    
    <content type="html"><![CDATA[<p>与黄题斗智斗勇<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>求一个整数序列的最长波峰序列, 详见<a href="https://www.luogu.org/problem/P1970" target="_blank" rel="noopener">https://www.luogu.org/problem/P1970</a></p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>这个题思路没什么难的, 主要是实现细节与边界处理。</p><p>做法显然是划分出每个单调递增单调递减的子段, 选上峰点和开头结尾即可。</p><p>问题在于其中会有<strong>相等</strong>的数字, 对于一个区间内的很好处理, 相等是不影响当前区间的单调性的。然而我们在设初值时, 会设为$a[1], a[2]$的关系, 我一开始没有考虑$a[1]$, $a[i]$相等了该怎么办。另外, 当$n=1$和$n = 2 and a[1] == a[2]$时, “选上开头结尾”是无法做到的, 需要特判。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> + (arr[<span class="number">2</span>] != arr[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] == arr[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">-1</span>) x = (arr[i] &gt; arr[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((arr[i] &gt; arr[i<span class="number">-1</span>]) != x) ans++, x ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;与黄题斗智斗勇&lt;br&gt;
    
    </summary>
    
      <category term="比赛" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="NOIP2013" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2013/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2013/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="边界处理" scheme="http://arintaro.com/tags/%E8%BE%B9%E7%95%8C%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2010 观光公交</title>
    <link href="http://arintaro.com/2019/10/23/Contest/NOIP%202010/bus/"/>
    <id>http://arintaro.com/2019/10/23/Contest/NOIP 2010/bus/</id>
    <published>2019-10-23T09:33:02.040Z</published>
    <updated>2019-10-23T10:48:35.241Z</updated>
    
    <content type="html"><![CDATA[<p>你以为我是DP,其实我是贪心啦dio<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>题意较为复杂,套的壳比较多,可见<a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">https://www.luogu.org/problem/P1315</a><br>要点: 公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>对于这种外面壳比较多的题,一定要先抽象其限制条件与需要去最优化的目标。由于每个乘客的旅行时间开始计算的点的是”乘客到达出发地点的时间”, 而不是”上车时间”, 所以每个乘客对总时间的影响只会体现在”公交车到达目标的时间”, 而跟到达起点的时间无关, 所以我们可以直接把费用体现它的终点去计算。而它的”出发地点与时间”, 体现为对”出发地点”的”最早出发时间”的限制条件。</p><p>接着考虑怎么做, 是个最优化问题,第一眼看上去像个DP, 然而DP的话, “剩余的加速器”与”现在公交车的地点”是两个显然必须要记录的信息, 然而即使转移是$O(1)$的, 这两个信息也足以让我们TLE。联系图论的话, 可以跑费用流, 然而如果跑到上界显然会TLE掉(<del>事实上远远跑不到</del>); 用二分答案的话, 二分除的答案$旅行时间总和$又显然对$check$毫无帮助, 所以考虑贪心。</p><p>我们显然不能按开车的顺序去贪心, 无法在有效的时间内判断这次贪心对后面的影响, 又设计不出”可以反悔的贪心”。所以我们考虑”迭代式的贪心”, 即先求出一组可行解, 不断尝试去优化它, 直到收敛到最优解。(<del>这两个名词都是我瞎编的</del>)</p><h4><span id="算法1贪心">算法1：贪心</span></h4><p>直观的想法肯定是对于一个加速器, 让它能够加速的人越多越好, 那么怎么去计算”一个加速器放在某个位置能加速多少人?”, 显然是从使用位置开始到第一个”车等人”的位置,所有结束位置在这段区间的人的时间都会减小1, 而对这之后的位置毫无影响。进一步考虑, 这些区间之间的关系要么是一个包含一个, 要么是不相交。考虑从$i$出发延展的区间, 从$i+1$出发也显然会到它的终点, 显然我们在$i$上用比$i+1$上用要好。所以, 在每个区间内部肯定是在起点用最好, 在区间之间用不用又毫无影响, 所以我们每次找一个加速时间最长的起点用肯定是最好的。</p><p>同时需要注意一些细节, 比如第二个限制条件$D_i$不能为负数, 每次用完中间有车和人同时到达, 要分裂区间, 不再赘述。直接按照上述思路模拟即可写出$O(kn)$的算法, 网上大部分题解也是这么做的。</p><h4><span id="算法2优化后的贪心">算法2：优化后的贪心</span></h4><p>发现$n = 10^3$, $k = 10^5$, 直接考虑每个怎么用肯定会TLE(<del>然而并没有</del>), 考虑每次用一个加速器, 如果这个区间”没有被分裂”, 肯定下次最优的还是它, 所以我们可以直接用到它分裂为止, 显然就是这段区间中人等车的最短时间。由于每次用完至少会有一个点变为$人等车$, 而我们只有$n$个点, 故上述过程至多执行$O(n)$, 所以总复杂度$O(n^2)$, 可以通过。</p><h4><span id="算法3-数据结构优化贪心">算法3: 数据结构优化贪心</span></h4><p>考虑$n = 10^5$时怎么做, 我们可以直接用一个堆维护这些区间的人数, 而每次不用遍历这些区间去找最大值, 然而问题在于如何去”分裂区间”, 我们可以在预处理这些区间后, 记录这些区间所有”最小值”的位置, 下次这个区间被选到时, 这些最小值必然同时变为0, 这些最小值的位置切分这个区间, 把这些区间的人数入堆即可。问题在于如何维护新区间最小值的位置, 我们可以发现, 对于任意时刻的一个区间, 它内部的所有数字必然经历的相同的”区间修改”, 也就是说, 只要知道区间的左右端点, 它内部的最小值位置一定是不变的, 即查位置这件事情根本就是个静态问题, 随便用个数据结构可以直接解决, 不同与只维护一个点的建树$O(n)$, 这样最坏建树是$O(nlogn)$的, 单次查询显然是这次删除的点数乘个$logn$, 根据上面的均摊分析, 显然总复杂度是$O(nlogn)$的, 至于具体的最小值可以直接在每个区间上记录一下至今减少了多少, 加上原数组即可求出。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], leave[maxn], arrive[maxn], w[maxn];</span><br><span class="line">lint sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n), readint(m), readint(k);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) readint(w[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t, st, ed;</span><br><span class="line">readint(t), readint(st), readint(ed);</span><br><span class="line">cnt[ed]++, sum[ed] += t;</span><br><span class="line">leave[st] = max(leave[st], t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; i++) arrive[i] = max(arrive[i<span class="number">-1</span>], leave[i<span class="number">-1</span>]) + w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> res_st = <span class="number">0</span>, res_ed = <span class="number">0</span>, res_w = <span class="number">0</span>, res_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">2</span>; i&lt;=n; ) &#123;</span><br><span class="line"><span class="keyword">if</span>(w[i] == <span class="number">0</span>) &#123; i++; <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> now_w = min(w[i], k), now_cnt = <span class="number">0</span>;</span><br><span class="line">rint j = i;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= n &amp;&amp; arrive[j] &gt; leave[j]; j++) &#123;</span><br><span class="line">now_cnt += cnt[j], now_w = min(now_w, arrive[j] - leave[j]);</span><br><span class="line">&#125;</span><br><span class="line">now_cnt += cnt[j];</span><br><span class="line"><span class="keyword">if</span>(now_cnt &gt; res_cnt) res_st = i, res_ed = j, res_w = now_w, res_cnt = now_cnt;</span><br><span class="line">i = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res_w == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">w[res_st] -= res_w, k -= res_w;</span><br><span class="line"><span class="keyword">for</span>(rint i=res_st; i&lt;=res_ed; i++) arrive[i] -= res_w;</span><br><span class="line">&#125;</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) ans += (lint)cnt[i] * arrive[i] - sum[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你以为我是DP,其实我是贪心啦dio&lt;br&gt;
    
    </summary>
    
      <category term="比赛" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="NOIP2009" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2009/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2009/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="迭代" scheme="http://arintaro.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2009 道路游戏</title>
    <link href="http://arintaro.com/2019/10/23/Contest/NOIP%202009/road/"/>
    <id>http://arintaro.com/2019/10/23/Contest/NOIP 2009/road/</id>
    <published>2019-10-23T02:52:08.757Z</published>
    <updated>2019-10-23T08:53:33.965Z</updated>
    
    <content type="html"><![CDATA[<p>千万不要以为普及组都是水题<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>题意较为复杂,套的壳比较多,可见<a href="https://www.luogu.org/problem/P1070" target="_blank" rel="noopener">https://www.luogu.org/problem/P1070</a><br>要点: 在任意时间必须有且仅有一个机器人,可以赔钱</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>分析一下思路,发现有明显的时间顺序,又是一个最优化问题,可以确定是动态规划。<br>费用比较奇怪,题面描述是个边权,不过我们显然可以下放到到点上,比如$1 -&gt; 2 -&gt; 3$,从1走两次到3,累加了两段路上金币,可以发现从$i$走$p$次就是累加$[i, i + x - 1]$的金币。手玩一下可以发现只要对费用矩阵斜着求前缀和即可。<br>由于是环形问题,为了方便最好把行上的编号重编至$[0, n-1]$。如果沿用$[1, n]$, 需要在每次”可能越界前”,先把编号-1取模再+1映射回来。</p><h4><span id="算法1暴力dp">算法1：暴力DP</span></h4><p>题里没什么影响决策的限制条件,记录时间即可,转移显然需要枚举出发点和走多远,稍微算下复杂度$O(nmp)$。期望得分90pts, <del>实际得分100pts</del></p><h4><span id="算法2转移优化dp">算法2：转移优化DP</span></h4><p>由于给了较多的部分分,我们可以相信这与正解已经相差不远,所以先考虑转移优化,而不是状态优化。</p><p>这种求前缀和的分段转移模型,一般写出”我从哪里来”形式的方程,显然我们有: </p><p>$$dp[i] = min{dp[j] + sum[x][i] - sum[(x - (i - j)) mod n][j] - val[(x - (i - j) + 1) mod n] }   ( i - p &lt;= j &lt;= i - 1) $$</p><p>注意一个细节, 序列上的”前缀和”求$[l, r]$的和时需要用$sum[r] - sum[l - 1]$,在方程中体现的是”出发点事实上是$x + 1$”。另外具体实现时,由于涉及到模意义下的减法,尽量加模数后再取模防止负数。</p><p>决策变量两维, 发现$n^2$可以接受, 考虑先枚举一维, 涉及$x$的量较多, 考虑先确定$x$, 略去$mod n$后</p><p>$$dp[i] = min{dp[j] - sum[x - (i - j)][j] - val[x - (i - j) + 1] }  + sum[x][i] ( i - p &lt;= j &lt;= i - 1)$$</p><p>可以发现与常规的优化DP不同, 一个决策$j$的价值可能与$x, i$有关,使得我们无法高效的维护决策集合,如果我们能使得$j$的价值与$x, i$无关,就可以用单调队列或平衡树等数据结构直接维护价值,每次直接转移,而不需要在得到$x, i$后对决策集合中的每个决策重新计算价值。</p><p>把确定的变量$x, i$整理到一起后, 发现内层价值数组中的下标只与$x - i$有关, 而在$mod n$意义下$x - i$的值显然至多只有$n$种,从多重背包在剩余系下的优化转移得到启发,我们可以按其在剩余系的模数分类,开$n$个不同的决策集合,这样对于决策$j$来讲关于$x - i$的部分即可化为定值。限制条件中上界下界单调递增, 显然可以用单调队列把转移的时间摊到$O(1)$</p><p>从实际含义上讲,这对应了在费用矩阵上不同的”斜列”转移(即我们斜着求前缀和的$n$个不同序列), 每次内层$x$增加时, 对应在不同斜列上的移动。</p><p>此题启发我们可以对决策集合进行”分类”, 从而消除状态变量对一个决策价值的影响。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eco(x) ((x) % n == 0 ? n : (x) % n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"><span class="keyword">int</span> id[maxn][maxn], w[maxn][maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn], ql[maxn], qr[maxn];</span><br><span class="line">pii mq[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0xc0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">readint(n), readint(m), readint(p);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">readint(w[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(c[i]);</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">w[i][j] += w[eco(i<span class="number">-1</span>)][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i, y = <span class="number">1</span>;</span><br><span class="line">ql[i] = <span class="number">1</span>, qr[i] = <span class="number">1</span>;</span><br><span class="line">mq[i][<span class="number">1</span>] = mp(-c[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(y &lt;= m) &#123;</span><br><span class="line">id[x][y] = i;</span><br><span class="line">x = eco(x + <span class="number">1</span>), y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint t=<span class="number">1</span>; t&lt;=m; t++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid];</span><br><span class="line">pii (&amp;q)[maxn] = mq[qid];</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; t - q[l].second &gt; p) l++;</span><br><span class="line">dp[t] = max(dp[t], w[x][t] + q[l].first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint x=<span class="number">1</span>; x&lt;=n; x++) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;qid = id[x][t], &amp;l = ql[qid], &amp;r = qr[qid];</span><br><span class="line">pii (&amp;q)[maxn] = mq[qid];</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r &amp;&amp; q[r].first &lt; dp[t] - w[x][t] - c[eco(x+<span class="number">1</span>)]) r--;</span><br><span class="line">q[++r] = mp(dp[t] - w[x][t] - c[eco(x+<span class="number">1</span>)], t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;千万不要以为普及组都是水题&lt;br&gt;
    
    </summary>
    
      <category term="比赛" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="NOIP2009" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2009/"/>
    
      <category term="题解" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2009/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="动态规划" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="环形处理" scheme="http://arintaro.com/tags/%E7%8E%AF%E5%BD%A2%E5%A4%84%E7%90%86/"/>
    
      <category term="动态规划的转移优化" scheme="http://arintaro.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%BD%AC%E7%A7%BB%E4%BC%98%E5%8C%96/"/>
    
      <category term="单调队列" scheme="http://arintaro.com/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>算法学习资料汇总</title>
    <link href="http://arintaro.com/2019/10/01/Essay/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://arintaro.com/2019/10/01/Essay/算法学习资料汇总/</id>
    <published>2019-10-01T05:19:49.561Z</published>
    <updated>2019-10-30T12:47:14.349Z</updated>
    
    <content type="html"><![CDATA[<p>主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog<br>由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有</p><a id="more"></a><h2><span id="一-数学">一、数学</span></h2><p>@card{</p><ol><li><h6><span id="线性基">线性基</span></h6><p> <a href="https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br> <a href="https://blog.csdn.net/a_forever_dream/article/details/83654397" target="_blank" rel="noopener">https://blog.csdn.net/a_forever_dream/article/details/83654397</a></p></li><li><h6><span id="博弈论">博弈论</span></h6><p> <a href="https://www.cnblogs.com/Wolfycz/p/8430991.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wolfycz/p/8430991.html</a><br> 2007国家集训队论文：王晓珂《解析一类组合游戏》<br> 2009国家集训队论文：贾志豪《组合游戏略述——浅谈SG游戏的若干拓展及变形》</p></li><li><h6><span id="奇异的数列">奇异的数列</span></h6><ul><li>斐波那契数列：<a href="https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、" target="_blank" rel="noopener">https://www.luogu.org/blog/Loveti/fei-bo-nei-qie-shuo-lie、</a><br>  $f[n+m]=f[m−1]∗f[n]+f[m]∗f[n+1]$</li></ul></li><li><h6><span id="初等数论">初等数论</span></h6><ul><li><a href="https://sshwy.tk/2019/01/52170/" target="_blank" rel="noopener">https://sshwy.tk/2019/01/52170/</a></li></ul></li><li><h6><span id="康托展开">康托展开</span></h6><ul><li><a href="https://www.luogu.org/blog/abc123-yummy/huoxingren" target="_blank" rel="noopener">https://www.luogu.org/blog/abc123-yummy/huoxingren</a></li><li>其实是规定了一种新的进制<br>}</li></ul></li></ol><h2><span id="二-图论">二、图论</span></h2><p>@card{</p><ol><li><h6><span id="负环与差分约束">负环与差分约束</span></h6><p> 求最大值:初始化inf, 跑最短路、求最小值:初始化-inf, 跑最长路<br> SPFA的三种优化: 大于队头从队尾入队、每次队列变化时检查队头队尾距离swap、卡时2e7</p></li><li><h6><span id="双联通分量">双联通分量</span></h6><p> <a href="https://linkfqy.github.io/posts/BCC_and_Tarjan/" target="_blank" rel="noopener">https://linkfqy.github.io/posts/BCC_and_Tarjan/</a><br> 求点双联通分量，根节点在搜索树上需要有两个子树才能被判定为割点</p></li></ol><p>}</p><h2><span id="三-字符串">三、字符串</span></h2><p>@card{</p><ol><li><h6><span id="ac自动机">AC自动机</span></h6><p><a href="https://ouuan.github.io/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://ouuan.github.io/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a><br><a href="https://oi-wiki.org/string/ac-automaton/" target="_blank" rel="noopener">https://oi-wiki.org/string/ac-automaton/</a></p></li><li></li></ol><p>}</p><h2><span id="四-数据结构">四、数据结构</span></h2><p>@card{</p><ol><li><h6><span id="莫队">莫队</span></h6> <a href="https://www.cnblogs.com/WAMonster/p/10118934.html" target="_blank" rel="noopener">https://www.cnblogs.com/WAMonster/p/10118934.html</a><br> 《算法竞赛中的分块思想》 杭州学军中学 ⾕晟</li></ol><p>}</p><h2><span id="五-动态规划">五、动态规划</span></h2><p>@card {</p><ol><li><h6><span id="悬线法">悬线法</span></h6><p> 2003国家集训队论文《浅谈用极大化思想解决最大子矩形问题》王知昆</p></li><li><h6><span id="树形背包的优化">树形背包的优化</span></h6><p> <a href="https://ouuan.github.io/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://ouuan.github.io/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/</a></p></li></ol><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要选录了一些集训队论文、大神课件，和我认为讲的不错的blog&lt;br&gt;由于我之前在学《算法竞赛进阶指南》，这本书上有的算法大概没有&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>基础数学总结</title>
    <link href="http://arintaro.com/2019/09/25/Algorithm/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://arintaro.com/2019/09/25/Algorithm/基础数学总结/</id>
    <published>2019-09-25T07:56:33.502Z</published>
    <updated>2019-10-01T06:52:50.957Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2><span id="一-数论">一、数论</span></h2><p>@card{</p><h4><span id="一-质数与因子相关">(一) 质数与因子相关</span></h4><h6><span id="1对于一个足够大的整数n不超过n的质数大约有fracnlnn个">1.对于一个足够大的整数N，不超过N的质数大约有$\frac{N}{ln(n)}$个</span></h6><h6><span id="2一个数至少有一个小于sqrtn的因子至多存在一个超过sqrtn的因子因此不少算法可以只跑到sqrtn">2.一个数至少有一个小于$\sqrt{n}$的因子，至多存在一个超过$\sqrt{n}$的因子，因此不少算法可以只跑到$\sqrt{n}​$</span></h6><h6><span id="3埃筛">3.埃筛</span></h6><pre><code>(1) 每个数从$x^2​$开始筛即可(2) 用$\sqrt{r}$内的数就可以对$[l, r]$进行区间筛</code></pre><h6><span id="4线筛">4.线筛</span></h6><pre><code>(1) 通过“积累最小质因子”的方法，去除合数</code></pre><h6><span id="5质因数分解">5.质因数分解</span></h6><pre><code>(1) 不少题可以通过算术基本定理找出想法(2) 试除法最后需要特判剩下来个大于$\sqrt{n}$的质数的情况(3) 有时候也可以反过来统计，不考虑它有什么因子，而是考虑“每个因子有多少个”，阶乘快速分解和倍数法基于此思想</code></pre><p>}</p><p>@card{</p><h4><span id="二-同余-取模相关">(二) 同余、取模相关</span></h4><h6><span id="1不少模非质数的题目需要对模数分解成质因子最后用crtexctr合并答案">1.不少模非质数的题目，需要对模数分解成质因子，最后用CRT/EXCTR合并答案</span></h6><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;&lt;span id=&quot;一-数论&quot;&gt;一、数论&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;一-质数与因子相关&quot;&gt;(一) 质数与因子相关&lt;/span&gt;&lt;/h4&gt;&lt;h6&gt;&lt;span id=&quot;1对于一个足够大的整
      
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基础数论</title>
    <link href="http://arintaro.com/2019/09/23/Template/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/base/"/>
    <id>http://arintaro.com/2019/09/23/Template/基础算法/base/</id>
    <published>2019-09-23T13:41:18.234Z</published>
    <updated>2019-10-28T14:06:53.665Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h4><span id="1归并排序求逆序对">1.归并排序求逆序对</span></h4><p>@card{</p><ul><li><p>$Test Site:$ <a href="https://www.acwing.com/problem/content/109/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/109/</a></p></li><li><p>$Code:$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 9 1 0 5 4</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lint ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn], temp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">msort(l, mid), msort(mid+<span class="number">1</span>, r); <span class="comment">// 在后面还小</span></span><br><span class="line"><span class="keyword">for</span>(rint i=l, j=mid+<span class="number">1</span>, p=l; p&lt;=r; p++) &#123; <span class="comment">// 一定要讨论选完的情况</span></span><br><span class="line"><span class="keyword">if</span>(j &gt; r || i &lt;= mid &amp;&amp; arr[i] &lt;= arr[j]) temp[p] = arr[i++];</span><br><span class="line"><span class="keyword">else</span> temp[p] = arr[j++], ans += mid - i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=l; i&lt;=r; i++) arr[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">msort(<span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h4&gt;&lt;span id=&quot;1归并排序求逆序对&quot;&gt;1.归并排序求逆序对&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$Test Site:$ &lt;a href=&quot;https://www.acwing.com/pro
      
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://arintaro.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>基础数论</title>
    <link href="http://arintaro.com/2019/09/23/Template/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"/>
    <id>http://arintaro.com/2019/09/23/Template/数论/基础数论/</id>
    <published>2019-09-23T11:05:47.314Z</published>
    <updated>2019-09-23T11:12:04.557Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h4><span id="1判断素数">1.判断素数</span></h4><p>@card{</p><ul><li><p>$Test Site:$ <a href="https://www.luogu.org/problem/P3383" target="_blank" rel="noopener">https://www.luogu.org/problem/P3383</a> </p></li><li><p>$Code:$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readint(x) scanf(<span class="meta-string">"%d"</span>,&amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read3(x,y,z) scanf(<span class="meta-string">"%d %d %d"</span>,&amp;(x),&amp;(y),&amp;(z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> putint(x) printf(<span class="meta-string">"%d "</span>,(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">2</span>||x==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>||x==<span class="number">1</span>||(x%<span class="number">6</span>!=<span class="number">1</span>&amp;&amp;x%<span class="number">6</span>!=<span class="number">5</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">5</span>; i&lt;=t; i+=<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>||x%(i+<span class="number">2</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x , n;</span><br><span class="line">readint(x) , readint(n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">readint(x);</span><br><span class="line"><span class="built_in">puts</span>(isp(x) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h4&gt;&lt;span id=&quot;1判断素数&quot;&gt;1.判断素数&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$Test Site:$ &lt;a href=&quot;https://www.luogu.org/problem/P338
      
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="数学" scheme="http://arintaro.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://arintaro.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>小型冷门知识点汇总</title>
    <link href="http://arintaro.com/2019/04/28/Algorithm/%E5%B0%8F%E5%9E%8B%E5%86%B7%E9%97%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <id>http://arintaro.com/2019/04/28/Algorithm/小型冷门知识点汇总/</id>
    <published>2019-04-28T06:06:16.512Z</published>
    <updated>2019-05-05T03:33:51.723Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="图论">图论</span></h2><ol><li><h6><span id="johnson-算法-原始对偶算法">Johnson 算法 /原始对偶算法</span></h6><ul><li>$site:$ <a href="https://zhuanlan.zhihu.com/p/48523094" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48523094</a>、<a href="https://www.cnblogs.com/tkandi/p/10532774.html" target="_blank" rel="noopener">https://www.cnblogs.com/tkandi/p/10532774.html</a></li><li>用途：用下界$O(NM)$的时间跑一遍$SPFA$消除图内所有负权边，用以之后跑$DJ$的全源最短路径或者跑费用流。适用于需要多次求最短路的问题，有时候甚至可以带来级</li></ul></li><li><p>##</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;图论&quot;&gt;图论&lt;/span&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h6&gt;&lt;span id=&quot;johnson-算法-原始对偶算法&quot;&gt;Johnson 算法 /原始对偶算法&lt;/span&gt;&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;$site:$ &lt;a href=&quot;https://zh
      
    
    </summary>
    
    
      <category term="然而并没有什么卵用" scheme="http://arintaro.com/tags/%E7%84%B6%E8%80%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>EX数据结构</title>
    <link href="http://arintaro.com/2019/04/28/Template/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ex/"/>
    <id>http://arintaro.com/2019/04/28/Template/数据结构/ex/</id>
    <published>2019-04-28T02:46:22.952Z</published>
    <updated>2019-10-28T14:07:02.441Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的EX，并不是指很厉害的数据结构，是指”额外的”。<br>简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。</p><a id="more"></a><ol><li><h4><span id="ex堆-配对堆">EX堆-配对堆</span></h4><p>@card{</p><p>请不要对我抱有会写斐波那契堆的期望。</p><ul><li>$test\ site: $&lt; <a href="https://lydsy.com/JudgeOnline/problem.php?id=3040&gt;" target="_blank" rel="noopener">https://lydsy.com/JudgeOnline/problem.php?id=3040&gt;</a> </li><li>$task:$ 实现配对堆完成最短路，每次$push$输入节点编号，$top$返回最短点的节点编号，注意空间要求$O(n)$，也就是说您要实现一个内存池。</li><li>$note: $维护这种多重编号映射，一定要列表需要维护的东西</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">10000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line">lint dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_sp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(lint) * (n+<span class="number">1</span>));</span><br><span class="line">dist[s] = <span class="number">0</span>, q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dist[y] &gt; dist[x] + ew[i]) &#123;</span><br><span class="line">dist[y] = dist[x] + ew[i];</span><br><span class="line">q.update(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, nu, nv, nw;</span><br><span class="line">lint x = <span class="number">0</span>, y = <span class="number">0</span>, a, b;</span><br><span class="line">lint rxa, rxc, rya, ryc, rp;</span><br><span class="line">readint(n), readint(m), s = <span class="number">1</span>;</span><br><span class="line">readint(T), readint(rxa), readint(rxc), readint(rya), readint(ryc), readint(rp);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"> x=(x*rxa+rxc)%rp;</span><br><span class="line"> y=(y*rya+ryc)%rp;</span><br><span class="line"> a=min(x%n+<span class="number">1</span>,y%n+<span class="number">1</span>);</span><br><span class="line"> b=max(y%n+<span class="number">1</span>,y%n+<span class="number">1</span>);</span><br><span class="line"> addedge(a, b, <span class="number">1e8</span> - <span class="number">100</span> * a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw);</span><br><span class="line">&#125;</span><br><span class="line">calc_sp();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dist[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>2.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓的EX，并不是指很厉害的数据结构，是指”额外的”。&lt;br&gt;简而言之，就是我们平时用的数据结构写法麻烦的加强版，可以优化常数或降一些复杂度，但不是必须的。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://arintaro.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="然而并没有什么卵用" scheme="http://arintaro.com/tags/%E7%84%B6%E8%80%8C%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8/"/>
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="新科技" scheme="http://arintaro.com/tags/%E6%96%B0%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>基础图论模板</title>
    <link href="http://arintaro.com/2019/04/27/Template/%E5%9B%BE%E8%AE%BA/%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%AE%BA/"/>
    <id>http://arintaro.com/2019/04/27/Template/图论/基础图论/</id>
    <published>2019-04-27T13:23:23.969Z</published>
    <updated>2019-05-08T08:04:19.163Z</updated>
    
    <content type="html"><![CDATA[<p>需要$3min$内实现任意一个 <a id="more"></a></p><ol><li><h4><span id="负环的判定">负环的判定</span></h4><p>@card{</p><ul><li>$test\ site: $<a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3385</a> </li><li>$task: $ 600ms以内判定负环，请注意，有多组数据，要求实现clear函数（包括邻接表 </li><li>$tips: $ 对于$O(NM)$能跑过去复杂度正确的，建议写$BFS_SPFA + SLF_SWAP$，复杂度不对的写$DFS$</li><li>$extra:?$?”同时记录节点入队次数”、”卡时”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">#define rint register int</span><br><span class="line">#define lint long long</span><br><span class="line">#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)</span><br><span class="line">template&lt;typename tint&gt;</span><br><span class="line">inline void readint(tint&amp; x) &#123;</span><br><span class="line">    int f = 1; char ch = getchar(); x = 0;</span><br><span class="line">    for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1;</span><br><span class="line">    for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000 + 10;</span><br><span class="line">const int maxm = 6000 + 10;</span><br><span class="line">int n, m, start = 1;</span><br><span class="line"></span><br><span class="line">int head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line">int totedge = 0;</span><br><span class="line">inline void addedge(int nu, int nv, int nw) &#123;</span><br><span class="line">    ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">    head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Queue&#123;</span><br><span class="line">    int arr[maxn];</span><br><span class="line">    int l, r, size;</span><br><span class="line">    inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125;</span><br><span class="line">    inline void push(int x) &#123;</span><br><span class="line">        if(r == size) r = 0;</span><br><span class="line">        arr[++r] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    inline int pop() &#123;</span><br><span class="line">        if(l == size) &#123;l = 1; return arr[size]; &#125;</span><br><span class="line">        return arr[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool empty() &#123; return l == r + 1; &#125;</span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line">void clear() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    readint(T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int nu, nv, nw;</span><br><span class="line">        readint(n), readint(m);</span><br><span class="line">        clear();</span><br><span class="line">        for(rint i=1; i&lt;=m; i++) &#123;</span><br><span class="line">            readint(nu), readint(nv), readint(nw);</span><br><span class="line">            addedge(nu, nv, nw);</span><br><span class="line">            if(nw &gt;= 0) addedge(nv, nu, nw);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(check() ? &quot;YE5&quot; : &quot;N0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><h4><span id="邻接表的删除操作">邻接表的删除操作</span></h4><p>card{</p><p>可以维护一个删除标记，但是这么做在有些算法里会导致复杂度(空间or时间)退化，具体测试可以去写即时删除的配对堆。</p><p>显然我们可以再维护一个$pre$域，像普通链表一样删除，但是过于麻烦，我们可以直接把这条边的数据与表头交换，然后让表头指向下一个，但是这么做会导致边序号乱序，需要注意成对变换等对边序号有要求的信息。</p><p>}</p></li><li><h4><span id="spfa求最长路">SPFA求最长路</span></h4><p>card{</p><ul><li>我们经常写$DJ$，也经常写最短路，但是最长路+$SPFA$我第一次写的时候却挂了。。</li><li>$test\ stie: $  <a href="https://www.acwing.com/activity/content/code/content/34854/" target="_blank" rel="noopener">https://www.acwing.com/activity/content/code/content/34854/</a></li><li>$task:$ 实现循环队列，初始化$dist[1] = 0$，求最长路</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair(x, y)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * (maxn + maxn);</span><br><span class="line"><span class="keyword">int</span> n, max_val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> q[maxn];</span><br><span class="line"><span class="keyword">int</span> l, r, size;</span><br><span class="line"></span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_sp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">   nu += <span class="number">1</span>, nv += <span class="number">2</span>; <span class="comment">// 节点编号[1, 50002]</span></span><br><span class="line">addedge(nu, nv, nw);</span><br><span class="line">max_val = max(max_val, max(nu, nv));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=max_val<span class="number">-1</span>; i++) addedge(i, i+<span class="number">1</span>, <span class="number">0</span>), addedge(i+<span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">calc_sp();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[max_val] - dist[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><h4><span id="无向图的割边">无向图的割边</span></h4><p>card{</p><ul><li><p>$test\ site: $<a href="https://www.acwing.com/problem/content/365/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/365/</a></p></li><li><p>$task: $实现判断割边，处理出搜索树的$deep$，$fa$数组，并在割边的子节点上标记$val[y] = 1$</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">int</span> n, m, root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">    ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> deep[maxn], val[maxn], fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++tot;</span><br><span class="line">    <span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == ind) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y]) &#123;</span><br><span class="line">            deep[y] = deep[x] + <span class="number">1</span>, fa[y] = x, dfs(y, i ^ <span class="number">1</span>);</span><br><span class="line">            low[x] = min(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y] &gt; dfn[x]) val[y] = <span class="number">1</span>, ans++;</span><br><span class="line">        &#125;<span class="keyword">else</span> low[x] = min(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = tot = <span class="number">0</span>, totedge = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(val, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mem[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">while</span>(deep[x] &gt; deep[y]) &#123;</span><br><span class="line">        mem[++s] = x, x = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x != y) &#123;</span><br><span class="line">        mem[++s] = x, mem[++s] = y;</span><br><span class="line">        x = fa[x], y = fa[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=s; i++) &#123;</span><br><span class="line">        res += val[mem[i]], val[mem[i]] = <span class="number">0</span>;</span><br><span class="line">        fa[mem[i]] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nu, nv;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ++T);</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            readint(nu), readint(nv);</span><br><span class="line">            addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        readint(m);</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            readint(nu), readint(nv);</span><br><span class="line">            ask(nu, nv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>$Solution:$ 注意父节点来的边不能更新，具体用成对变换实现，割点不用记录，都能更新，但是要注意，按照常规割点定义，根节点必须有俩儿子“大于等于”，才能判断是，割边则是“大于”。</p><p>}</p></li></ul><ol start="5"><li><h4><span id="无向图的v-dcc缩点-二分图判定">无向图的$v-dcc$缩点 + 二分图判定</span></h4><p>@card{</p><ul><li>$test\ site:​$ <a href="https://www.acwing.com/problem/content/367/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/367/</a></li><li>$task:$ 划分出图中的每个$vdcc$，并判定其是否是二分图（是否存在奇环），是的话将其每个节点的$suc$值设为$1$，并实现多组数据的清空函数</li><li>$note:$ 现用现标记，解决割点重叠问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e6</span> + <span class="number">4</span> * maxn;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn], nxt[maxm], ev[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = y, nxt[totedge] = head[x], head[x] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123;</span><br><span class="line"><span class="keyword">while</span>(m--) readint(nu), readint(nv), edge[nu][nv] = edge[nv][nu] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(rint j=i+<span class="number">1</span>; j&lt;=n; j++) &#123; <span class="comment">// 虽然在完全图上用邻接表十分弱智,但可以降低常数</span></span><br><span class="line"><span class="keyword">if</span>(!edge[i][j]) addedge(i, j), addedge(j, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) ans += (suc[i] == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li><li><h4><span id="欧拉回路的具体方案">欧拉回路的具体方案</span></h4><ul><li>$test\ site:$ <a href="https://www.acwing.com/problem/content/368/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/368/</a></li><li>$task:$ 寻找一个从$1$出发，遍历所有边两次的具体方案，保证有解。</li><li>$tips:$ 注意入栈方法的实际含义。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], nxt[maxm], totedge = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, nxt[totedge] = head[nu], head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxm], tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxm], top = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">while</span>(m--) readint(nu), readint(nv), addedge(nu, nv), addedge(nv, nu);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=tot; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>7.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要$3min$内实现任意一个
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>基础数据结构</title>
    <link href="http://arintaro.com/2019/04/27/Template/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/base/"/>
    <id>http://arintaro.com/2019/04/27/Template/数据结构/base/</id>
    <published>2019-04-27T12:44:23.105Z</published>
    <updated>2019-10-28T14:06:59.668Z</updated>
    
    <content type="html"><![CDATA[<p>虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。<a id="more"></a> </p><ol><li><h4><span id="循环队列">循环队列</span></h4><p>@card{</p><ul><li>$test \ site:$<a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3385</a></li><li>$task:$实现一个循环队列，要求有$empty \ \ push\  init(O(1))\ \  pop\ \  front $ </li><li>$note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.org/problemnew/show/P3385</span></span><br><span class="line"><span class="comment">// task: 实现一个循环队列，要求有empty push init(O(1)) pop front </span></span><br><span class="line"><span class="comment">// note: 一般用于需要多次清空队列且已知"队列里同时存在的最多元素数量"，</span></span><br><span class="line"><span class="comment">//  比起STL的queue，手写的可以O(1)清空。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">6000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt_path[maxn], dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">totedge = <span class="number">0</span>;</span><br><span class="line">q.init();</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(cnt_path, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">q.push(start), dist[start] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.pop();</span><br><span class="line">inq[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dist[x] + ew[i] &lt; dist[y]) &#123;</span><br><span class="line">dist[y] = dist[x] + ew[i];</span><br><span class="line">cnt_path[y] = cnt_path[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt_path[y] &gt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!inq[y]) q.push(y), inq[y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">readint(T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw);</span><br><span class="line"><span class="keyword">if</span>(nw &gt;= <span class="number">0</span>) addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(check() ? <span class="string">"YE5"</span> : <span class="string">"N0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$Solution:$ 懒得写了，自己看代码吧</li></ul></li></ol><p>}</p><p>2.#### 整数hash表<br>@card{</p><ul><li>$Test Site:<a href="https://www.luogu.org/problem/CF670C" target="_blank" rel="noopener">https://www.luogu.org/problem/CF670C</a></li><li>$Code:$<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;lint, lint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(x, y) make_pair((x), (y))</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200000</span> * <span class="number">3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">599899</span>;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, totid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mhash</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> head[maxn], nxt[maxn], eco[maxn], tot;</span><br><span class="line"><span class="keyword">int</span> pre[maxn], suf[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu = x % mod + <span class="number">1</span>; <span class="comment">//别忘了+1</span></span><br><span class="line"><span class="keyword">for</span>(rint i=head[nu]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(pre[i] == x) <span class="keyword">return</span> suf[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu = x % mod + <span class="number">1</span>;</span><br><span class="line">nxt[++tot] = head[nu], head[nu] = tot, pre[tot] = x, suf[tot] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ry[maxn], dz[maxn], dy[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> ansid = <span class="number">1</span>, ansy = <span class="number">-1</span>, ansz = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">readint(n);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">readint(ry[i]);</span><br><span class="line"><span class="keyword">int</span> t = ht.find(ry[i]);</span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">0</span>) t = ++totid, ht.insert(ry[i], t);</span><br><span class="line">cnt[t]++;</span><br><span class="line">&#125;</span><br><span class="line">readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) readint(dy[i]), dy[i] = ht.find(dy[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) readint(dz[i]), dz[i] = ht.find(dz[i]);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[dy[i]] &gt; ansy || (cnt[dy[i]] == ansy &amp;&amp; cnt[dz[i]] &gt; ansz)) ansid = i, ansy = cnt[dy[i]], ansz = cnt[dz[i]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ansid);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>}<br>3.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://arintaro.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
