<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2019-04-27T12:59:16.061Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>����ͼ��ģ��</title>
    <link href="http://arintaro.com/2019/04/27/Template/%E5%9F%BA%E7%A1%80%E5%9B%BE%E8%AE%BA/%E8%B4%9F%E7%8E%AF/"/>
    <id>http://arintaro.com/2019/04/27/Template/基础图论/负环/</id>
    <published>2019-04-27T12:55:06.214Z</published>
    <updated>2019-04-27T12:59:16.061Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h4><span id="ж">�������ж�</span></h4><p>@card{</p><ul><li>$test\ site: $<a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3385</a> </li><li>$task: $ 600ms�����ж���������ע�⣬�ж������ݣ�Ҫ��ʵ��clear�����������ڽӱ� </li><li>$tips: $ ѭ��������ʵ�ֺá� </li><li>$extra:?$?”ͬʱ��¼�ڵ���Ӵ���”��”��ʱ”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">#define rint register int</span><br><span class="line">#define lint long long</span><br><span class="line">#define isnum(x) (&apos;0&apos; &lt;= (x) &amp;&amp; (x) &lt;= &apos;9&apos;)</span><br><span class="line">template&lt;typename tint&gt;</span><br><span class="line">inline void readint(tint&amp; x) &#123;</span><br><span class="line">    int f = 1; char ch = getchar(); x = 0;</span><br><span class="line">    for(; !isnum(ch); ch = getchar()) if(ch == &apos;-&apos;) f = -1;</span><br><span class="line">    for(; isnum(ch); ch = getchar()) x = x * 10 + ch - &apos;0&apos;;</span><br><span class="line">    x *= f;</span><br><span class="line">&#125;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 2000 + 10;</span><br><span class="line">const int maxm = 6000 + 10;</span><br><span class="line">int n, m, start = 1;</span><br><span class="line"></span><br><span class="line">int head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line">int totedge = 0;</span><br><span class="line">inline void addedge(int nu, int nv, int nw) &#123;</span><br><span class="line">    ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">    head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Queue&#123;</span><br><span class="line">    int arr[maxn];</span><br><span class="line">    int l, r, size;</span><br><span class="line">    inline void init() &#123; l = 1, r = 0, size = maxn - 10; &#125;</span><br><span class="line">    inline void push(int x) &#123;</span><br><span class="line">        if(r == size) r = 0;</span><br><span class="line">        arr[++r] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    inline int pop() &#123;</span><br><span class="line">        if(l == size) &#123;l = 1; return arr[size]; &#125;</span><br><span class="line">        return arr[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    inline bool empty() &#123; return l == r + 1; &#125;</span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line">void clear() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool check() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    readint(T);</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        int nu, nv, nw;</span><br><span class="line">        readint(n), readint(m);</span><br><span class="line">        clear();</span><br><span class="line">        for(rint i=1; i&lt;=m; i++) &#123;</span><br><span class="line">            readint(nu), readint(nv), readint(nw);</span><br><span class="line">            addedge(nu, nv, nw);</span><br><span class="line">            if(nw &gt;= 0) addedge(nv, nu, nw);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(check() ? &quot;YE5&quot; : &quot;N0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p></li></ol><p>2.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h4&gt;&lt;span id=&quot;ж&quot;&gt;�������ж�&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$test\ site: $&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3385&quot; ta
      
    
    </summary>
    
      <category term="ģ��" scheme="http://arintaro.com/categories/g%EF%BF%BD%EF%BF%BD/"/>
    
    
      <category term="ͼ��" scheme="http://arintaro.com/tags/%CD%BC%EF%BF%BD%EF%BF%BD/"/>
    
  </entry>
  
  <entry>
    <title>基础数据结构</title>
    <link href="http://arintaro.com/2019/04/27/Template/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://arintaro.com/2019/04/27/Template/基础数据结构/基础数据结构/</id>
    <published>2019-04-27T12:44:23.105Z</published>
    <updated>2019-04-27T12:52:05.730Z</updated>
    
    <content type="html"><![CDATA[<p>虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。<a id="more"></a></p><ol><li><h4><span id="循环队列">循环队列</span></h4><p>@card{</p><ul><li>$test \ site:$<a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3385</a></li><li>$task:$实现一个循环队列，要求有$empty \ \ push\  init(O(1))\ \  pop\ \  front $ </li><li>$note:$一般用于需要多次清空队列且已知”队列里同时存在的最多元素数量”（例如二分答案+BFS），比起STL的queue，手写的可以O(1)清空。 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.org/problemnew/show/P3385</span></span><br><span class="line"><span class="comment">// task: 实现一个循环队列，要求有empty push init(O(1)) pop front </span></span><br><span class="line"><span class="comment">// note: 一般用于需要多次清空队列且已知"队列里同时存在的最多元素数量"，</span></span><br><span class="line"><span class="comment">//  比起STL的queue，手写的可以O(1)清空。 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">6000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line"></span><br><span class="line">&#125;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt_path[maxn], dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">totedge = <span class="number">0</span>;</span><br><span class="line">q.init();</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(cnt_path, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">q.push(start), dist[start] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.pop();</span><br><span class="line">inq[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dist[x] + ew[i] &lt; dist[y]) &#123;</span><br><span class="line">dist[y] = dist[x] + ew[i];</span><br><span class="line">cnt_path[y] = cnt_path[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt_path[y] &gt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!inq[y]) q.push(y), inq[y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">readint(T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line">clear();</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw);</span><br><span class="line"><span class="keyword">if</span>(nw &gt;= <span class="number">0</span>) addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(check() ? <span class="string">"YE5"</span> : <span class="string">"N0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$Solution:$ 懒得写了，自己看代码吧</li></ul><p>}</p></li></ol><p>2.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然STL有，但是为了防毒瘤出题人与$O(1)$的清空，还是需要在$2min$内实现任意一个，出错可就丢人了。
    
    </summary>
    
      <category term="模板" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构" scheme="http://arintaro.com/categories/%E6%A8%A1%E6%9D%BF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://arintaro.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://arintaro.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Indigo</title>
    <link href="http://arintaro.com/2019/04/27/test/"/>
    <id>http://arintaro.com/2019/04/27/test/</id>
    <published>2019-04-27T11:09:36.091Z</published>
    <updated>2019-04-27T11:09:47.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//placekitten.com/1000/500" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><h2 id="Blockquote"><a href="#Blockquote" class="headerlink" title="Blockquote"></a>Blockquote</h2><blockquote><p>当<code>blockquote</code>、<code>img</code>、<code>pre</code>、<code>figure</code>为第一级内容时，在<code>page</code>布局中拥有<code>card</code>阴影，所有标题居中展示。</p></blockquote><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>@card{</p><p>目前的想法是预定义一系列内容模块，通过像输入 Markdown 标记一样来简单调用。好在 Markdown 没有把所有便于输入的符号占用，最终我定义了<code>@moduleName{  ...  }</code>这种标记格式。如果你使用过<code>Asp.Net MVC</code>，一定会很熟悉这种用法，没错，就是<code>razor</code>。</p><p><code>page</code>布局中的<code>title</code>和<code>subtitle</code>对应 Markdown 中的<code>title</code>和<code>description</code>。</p><p>基本的内容容器还是<code>card</code>，你可以这样使用<code>card</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line">在`<span class="selector-tag">page</span>`页中，建议把内容都放到`<span class="selector-tag">card</span>`中。</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>标记与内容之间必须空一行隔开。</strong>至于为何要这样，看到最后就明白了。</p><p>}</p><h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><p>@column-2{</p><p>@card{</p><h3 id="左"><a href="#左" class="headerlink" title="左"></a>左</h3><p>与<code>card</code>标记类似，分栏的标记是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">column</span>-<span class="keyword">2</span>&#123;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line"># 左</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line"># 右</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了移动端观感，当屏幕宽度小于 480 时，<code>column</code>将换行显示。</p></blockquote><p>}</p><p>@card{</p><h3 id="右"><a href="#右" class="headerlink" title="右"></a>右</h3><p><code>column</code>中的每一列具有等宽、等高的特点，最多支持三栏：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">column</span>-<span class="keyword">3</span>&#123;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line">左</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line">中</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">card</span>&#123;</span><br><span class="line"></span><br><span class="line">右</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>}</p><h2 id="Three-columns"><a href="#Three-columns" class="headerlink" title="Three columns"></a>Three columns</h2><p>@column-3{</p><p>@card{</p><p>话式片平九业影查类办细开被支，置军争里老5备才才目板。 且数置百容机，规的空界往，十陕志入。料解格清收权厂值动且习，识生能化路速年边，类儿2带杏性热求已。</p><p>}</p><p>@card{</p><p>话式片平九业影查类办细开被支，置军争里老5备才才目板。 且数置百容机，规的空界往，十陕志入。料解格清收权厂值动且习，识生能化路速年边，类儿2带杏性热求已。</p><p>}</p><p>@card{</p><p>话式片平九业影查类办细开被支，置军争里老5备才才目板。 且数置百容机，规的空界往，十陕志入。料解格清收权厂值动且习，识生能化路速年边，类儿2带杏性热求已。</p><p>}</p><p>}</p><h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><p>@card{</p><p>在<code>timeline</code>模块中，你的 5 号标题<code>#####</code>和六号标题<code>######</code>将被“征用”，用作时间线上的标记点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">timeline</span>&#123;</span><br><span class="line"></span><br><span class="line">##### 2016</span><br><span class="line"></span><br><span class="line">@<span class="keyword">item</span>&#123;</span><br><span class="line">###### 11月6日</span><br><span class="line"></span><br><span class="line">为 <span class="selector-tag">Card</span> <span class="selector-tag">theme</span> 添加 <span class="selector-tag">page</span> <span class="selector-tag">layout</span>。</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@item</code>中多行内容可以换行输入，目前不允许隔行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">timeline</span>&#123;</span><br><span class="line"></span><br><span class="line">##### 2016</span><br><span class="line"></span><br><span class="line">@<span class="keyword">item</span>&#123;</span><br><span class="line">###### 11月6日</span><br><span class="line"></span><br><span class="line">第一行 </span><br><span class="line">第二行 <span class="comment">/* ok */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">item</span>&#123;</span><br><span class="line">###### 11月6日</span><br><span class="line"></span><br><span class="line">第一行</span><br><span class="line"></span><br><span class="line">第二行 <span class="comment">/* error */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>@timeline{</p><h5 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h5><p>@item{</p><h6 id="11月6日"><a href="#11月6日" class="headerlink" title="11月6日"></a>11月6日</h6><p>为 Card theme 添加 page layout。<br>加快绿化空间好看</p><p>}</p><p>@item{</p><h6 id="10月31日"><a href="#10月31日" class="headerlink" title="10月31日"></a>10月31日</h6><p>本地化多说。</p><p>}</p><p>@item{</p><h6 id="10月24日"><a href="#10月24日" class="headerlink" title="10月24日"></a>10月24日</h6><p>为 Indigo 主题创建 Card 分支。</p><p>}</p><h5 id="2015"><a href="#2015" class="headerlink" title="2015"></a>2015</h5><p>@item{</p><h6 id="2月24日"><a href="#2月24日" class="headerlink" title="2月24日"></a>2月24日</h6><p>发布 Indigo 主题到 hexo.io。</p><p>}</p><p>@item{</p><h6 id="1月22日"><a href="#1月22日" class="headerlink" title="1月22日"></a>1月22日</h6><p>创建 Indigo 主题。</p><p>}</p><p>}</p><h2 id="CodeBlock"><a href="#CodeBlock" class="headerlink" title="CodeBlock"></a>CodeBlock</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义内容块实现</span></span><br><span class="line">page.content.replace(<span class="regexp">/&lt;p&gt;&#125;&lt;\/p&gt;/g</span>, <span class="string">'&lt;/div&gt;'</span>)</span><br><span class="line">.replace(<span class="regexp">/&lt;p&gt;@([\w-]+)&#123;&lt;\/p&gt;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'&lt;div class="'</span>+ $<span class="number">1</span> +<span class="string">'"&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>@card{</p><p>这里可以解释，为什么标记之间必须要隔一行了。</p><p>当你在 Markdown 中隔行输入时，会形成新的段落，而如果一个段落中的内容仅仅是我们约定的标记，就可以用很容易的用正则匹配到替换为对应的<code>模块容器</code>。</p><p>}</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>@card{</p><p>为了解决 Hexo 自定义页面<code>slug</code>为空不能很好的使用多说评论这个问题，现在已经给每个自定义页面自动生成了<code>hexo-page-path</code>这种格式的<code>slug</code>。<br>本来准备用<code>date</code>做格式的最后一节，测试中发现 page 中的<code>date</code>值为修改时间，是动态的。<br>综合考虑使用了路径<code>path</code>。</p><p>以后可以根据需要添加更多模块支持。</p><p>打赏和评论默认开启，可根据需要在 Markdown 头部定义是否关闭。</p><p>}</p>]]></content>
    
    <summary type="html">
    
      用户自定义页面功能演示
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LNOI2019 &amp; 多省联考 游记</title>
    <link href="http://arintaro.com/2019/04/27/Essay/LNOI2019%20&amp;%20%E5%A4%9A%E7%9C%81%E8%81%94%E8%80%83%20%E6%B8%B8%E8%AE%B0/"/>
    <id>http://arintaro.com/2019/04/27/Essay/LNOI2019 &amp; 多省联考 游记/</id>
    <published>2019-04-27T09:01:25.797Z</published>
    <updated>2019-04-27T13:03:09.425Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="day1">Day1:</span></h2><p>待更，鸽了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;day1&quot;&gt;Day1:&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;待更，鸽了&lt;/p&gt;

      
    
    </summary>
    
      <category term="文章" scheme="http://arintaro.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="无病呻吟" scheme="http://arintaro.com/tags/%E6%97%A0%E7%97%85%E5%91%BB%E5%90%9F/"/>
    
  </entry>
  
  <entry>
    <title>综合技巧与实践</title>
    <link href="http://arintaro.com/2019/04/27/Detail/%E7%BB%BC%E5%90%88%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://arintaro.com/2019/04/27/Detail/综合技巧与实践/</id>
    <published>2019-04-27T09:01:25.547Z</published>
    <updated>2019-04-27T12:43:17.568Z</updated>
    
    <content type="html"><![CDATA[<p>根据贪心策略，我们把这些东西背一背肯定是是不亏的。 <a id="more"></a></p><h2><span id="一-stl相关">一、STL相关</span></h2><p>@card{</p><h4><span id="1algorithm">1.algorithm</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.l</span>ower_bound &amp; upper_bound <span class="comment">//我就算饿死，死外面，也不会自己写一个二分查找的</span></span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>,val) - arr; <span class="comment">//在有序数组[1,n]中查第一个 &gt;=val的数</span></span><br><span class="line"><span class="comment">// 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater</span></span><br><span class="line"><span class="number">2.u</span>nique <span class="comment">//常用于离散化</span></span><br><span class="line">       n = unique(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>) - (arr+<span class="number">1</span>); <span class="comment">//去重，新元素存在[1,n]</span></span><br><span class="line">   <span class="number">3.</span>inplace_merge merge <span class="comment">// 常用于CDQ分治中，不要cdq里套sort了！！</span></span><br><span class="line">       <span class="comment">// 数组 arr分为有序的两部分 [1,mid] [mid+1,n]</span></span><br><span class="line">       inplace_merge(arr+<span class="number">1</span>,arr+mid+<span class="number">1</span>,arr+n+<span class="number">1</span>);</span><br><span class="line">merge(first1,last1,first2,last2,result,compare);</span><br><span class="line"><span class="number">4.</span>nth_element <span class="comment">//数组中O(n)找第k大，前k个数一定都在[1，k]</span></span><br><span class="line">       nth_element(arr+<span class="number">1</span>,arr+k,arr+n+<span class="number">1</span>);</span><br><span class="line"><span class="number">5.</span>sort stable_sort <span class="comment">// 后一个可以稳定排序</span></span><br><span class="line">   <span class="number">6.</span>reverse <span class="comment">// 跟sort传参一样，序列反转</span></span><br></pre></td></tr></table></figure><h4><span id="2vector">2.vector</span></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">vector</span>的clear不会释放空间，需要释放空间的话，需要:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(a); <span class="comment">// 但是几乎比clear慢一倍</span></span><br></pre></td></tr></table></figure><p>}</p><h2><span id="二-noi-linux相关">二、NOI Linux相关</span></h2><p>@card{</p><p>​    1.Emacs相关（M为Alt键，C为Ctrl键</p><pre><code>- M+x输入命令 C+x+k关闭当前窗口- Options-Use CUA Keys (转换复制粘贴快捷键)- Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题）- Options-Set Default Font - Ubuntu Mono 20-30（变更字体- C-x-2 水平切分当前Buffer, C-x-3 左右切分- 命令 Find-file后， ~/.emacs 可以直接打开配置文件<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-linum-mode</span> <span class="literal">t</span>) <span class="comment">;;line num 显示行号</span></span><br><span class="line">(<span class="name">setq</span> c-basic-offset <span class="number">3</span>) <span class="comment">;; 变更缩进</span></span><br><span class="line">(<span class="name">setq</span> default-tab-width <span class="number">3</span>) </span><br><span class="line"></span><br><span class="line">(<span class="name">electric-pair-mode</span> <span class="literal">t</span>) <span class="comment">;;electric pair 括号补全</span></span><br><span class="line">(<span class="name">electric-layout-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">electric-indent-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq-default</span> cursor-type 'bar) <span class="comment">;;光标竖线</span></span><br><span class="line">(<span class="name">show-paren-mode</span> <span class="literal">t</span>) <span class="comment">;;show paren 括号配对</span></span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> [f4] 'shell) <span class="comment">;;摁F4进入shell</span></span><br><span class="line">(<span class="name">defun</span> compile-file()(<span class="name">interactive</span>)</span><br><span class="line">(<span class="name">compile</span>(<span class="name">format</span> <span class="string">"g++ -o '%s' '%s' -lm -Wall -g"</span></span><br><span class="line">(<span class="name">file-name-sans-extension</span>(<span class="name">buffer-name</span>))(<span class="name">buffer-name</span>))))</span><br><span class="line">(<span class="name">global-set-key</span> [f5] 'compile-file) <span class="comment">;;摁F5编译</span></span><br><span class="line">(<span class="name">global-set-key</span> [f6] 'gdb) <span class="comment">;;摁F6进入gdb调试</span></span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-s"</span>) 'save-buffer) <span class="comment">;; Ctrl+s变为保存</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-a"</span>) 'mark-the-whole-buffer) <span class="comment">;; Ctrl+s变为保存</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"RET"</span>) 'newline-and-indent) <span class="comment">;;回车自动缩进</span></span><br></pre></td></tr></table></figure></code></pre><p>}</p><h2><span id="四-对拍相关">四、对拍相关</span></h2><p>@card{</p><p>​    #### 1.程序运行时间  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> t = clock();</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><pre><code>#### 2.diff命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -b -B test.out ans.out</span><br></pre></td></tr></table></figure></code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据贪心策略，我们把这些东西背一背肯定是是不亏的。
    
    </summary>
    
      <category term="细节" scheme="http://arintaro.com/categories/%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="语言" scheme="http://arintaro.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL" scheme="http://arintaro.com/tags/STL/"/>
    
      <category term="Linux" scheme="http://arintaro.com/tags/Linux/"/>
    
      <category term="Emacs" scheme="http://arintaro.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>常见代码实现细节</title>
    <link href="http://arintaro.com/2019/04/27/Detail/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://arintaro.com/2019/04/27/Detail/常见代码实现细节/</id>
    <published>2019-04-27T09:01:25.528Z</published>
    <updated>2019-04-27T12:38:16.711Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录的问题，全是我调过的问题orz。 &lt;!– more – &gt;</p><p>@card{</p><blockquote><p>我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码</p></blockquote><p>}</p><h2><span id="一-变量溢出问题">一、变量溢出问题</span></h2><p>@card{</p><ol><li>乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘</li><li>int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint</li><li>INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long，</li><li>unsigned类型：值域$[0,2^{8<em>size}-1]$溢出后对$2^{8</em>size}$取模。</li><li>signed类型: 值$[-2^{8<em>size-1},2^{8</em>size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。</li><li>long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数</li></ol><p>}</p><h2><span id="二-运算问题"><strong>二、运算问题</strong></span></h2><p>@card{</p><ol><li>有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数</li><li>要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除</li><li>做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值，</li><li>维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf</li><li>注意非负整数与“正整数”的区别，值域里可能会有0</li><li>有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。</li></ol><p>}</p><h2><span id="三-语言问题"><strong>三、语言问题</strong></span></h2><p>@card{</p><ol><li>有时需要注意\n \r的问题，建议写手动读入的时候直接特判掉</li><li>宏定义千万别忘了括号，调一辈子，一般来说”有分割”的东西，不用加括号</li><li>lint 输入输出 %lld，ldob输入输出 %Lf</li><li>数组作为形参会退化成指针，不能再用sizeof求大小</li><li>题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0</li><li>程序中常量默认是INT型，设定 long long a = 10000 <em> 9999 </em> 9998 等一定要注意常量爆INT的问题</li><li>使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉</li><li>写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等</li><li>维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义</li><li>计算某些东西时，如果计算后需要移动指针，注意别先移动指针了（Acwing 294, 倍增LCA等）</li><li>写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧</li><li>维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。</li></ol><p>}</p><h2><span id="四-数学相关"><strong>四、数学相关</strong></span></h2><p>@card{</p><ol><li><p>BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Z == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//Luogu P2485 [SDOI2011]计算器</span></span><br><span class="line"><span class="keyword">if</span>(Y % P == <span class="number">0</span>) <span class="keyword">return</span> Z%P == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">i*len - ht[Yk] &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况</p></li><li>exgcd求出的d，如果要算最小非负解，一定把模数取决定值，才能用我们惯用的写法</li><li>如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的</li><li>计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\ ||\ m&lt;0\ ||\ n&lt;0$时0种方案</li><li>试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于</li></ol><p>} </p><h2><span id="五-数据结构相关">五、数据结构相关</span></h2><p>@card{</p><ol><li>维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1]</li><li>分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错</li><li>分块题开数组不要开混了</li><li>在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数”</li><li>常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2</li><li>静态线段树空间直接开4<em>n防越界，动态开点的范围为 $[mlog_2m, 2</em>n-1]$</li><li>翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放</li><li>下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响</li><li>pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去</li><li>将操作重新排序后，注意是删除操作优先，还是增加操作优先</li><li>邻接表 i=nxt[i], 千万别写成 i=nxt[x]</li><li>如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。</li><li>有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。</li><li>有时需要特判“不存在”、”没找到“的情况</li><li>写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空<strong>相关</strong>指针，大部分情况数据清不清无所谓。</li><li>值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域。</li></ol><p>}</p><h4><span id="六-图论相关">六、图论相关</span></h4><p>@card{</p><ol><li>如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。</li><li>邻接矩阵注意初值是0还是inf</li><li>在有负权边时，树的直径不能通过两次DFS求。</li><li>无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。</li><li>带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。</li><li>在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。</li></ol><p>}</p><h4><span id="七-动态规划相关">七、动态规划相关</span></h4><p>@card{</p><ol><li>要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \forall j \ \ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。</li><li>状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$</li><li></li></ol><p>}</p><h4><span id="八-杂项">八、杂项</span></h4><p>@card{</p><ol><li>题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;=</li><li>一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1</li><li>在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。</li></ol><p>}</p><h4><span id="九-奇异的语言细节">九、奇异的语言细节</span></h4><p>@card{</p><ol><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参中的表达式一定会被计算，但是C++标准并没有规定参数的求值顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(++x,x); <span class="comment">// 输出 1 1</span></span><br><span class="line">test(++x,x<span class="number">-1</span>); <span class="comment">// 输出1 -1</span></span><br></pre></td></tr></table></figure></li><li></li></ol><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里记录的问题，全是我调过的问题orz。 &amp;lt;!– more – &amp;gt;&lt;/p&gt;
&lt;p&gt;@card{&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们写代码的目标是”一遍成”，不清醒时不写代码，没想好时不写代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="细节" scheme="http://arintaro.com/categories/%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="方法论" scheme="http://arintaro.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>OI中的常见解题思路与技巧（更新中）</title>
    <link href="http://arintaro.com/2019/04/27/Detail/OI%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <id>http://arintaro.com/2019/04/27/Detail/OI中的常见解题思路与技巧/</id>
    <published>2019-04-27T09:01:25.509Z</published>
    <updated>2019-04-27T12:30:07.233Z</updated>
    
    <content type="html"><![CDATA[<p>也许很有用，也许没什么卵用。<a id="more"></a></p><h2><span id="一-最优化问题">一、最优化问题</span></h2><p>@card{</p><ol><li><h6><span id="二分答案答案具有单调性外层花费log-ans的时间转化为判定性问题">二分答案：答案具有“单调性”，外层花费$log\ ans$的时间转化为判定性问题</span></h6><ul><li>答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的</li><li>二分出的答案一般对check的进行有所帮助</li></ul></li><li><h6><span id="动态规划一定要有最优子结构性质">动态规划：一定要有最优子结构性质</span></h6></li><li><h6><span id="贪心一般作为正解中的一个步骤出现用于去掉某些限制条件">贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件。</span></h6><ul><li>可以小范围搜索+多重限制贪心乱搞，说不定就骗到了100pts呢，考试的时候要<del>勇于乱搞，敢于乱搞</del></li><li>一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质。</li><li>出题人是傻的，数据是水的，贪心+暴力是能过的，是能$Au$的。</li></ul></li></ol><p>}</p><h2><span id="二-计数问题">二、计数问题</span></h2><p>@card{</p><p>}</p><h2><span id="三-数据结构题">三、数据结构题</span></h2><p>@card{</p><p>}</p><h2><span id="四-数学题">四、数学题</span></h2><p>@card{</p><ol><li><h6><span id="求和题核心思想交换求和顺序">求和题：核心思想：[交换求和顺序]</span></h6></li></ol><p>   }</p><h2><span id="五-图论问题">五、图论问题</span></h2><p>@card{</p><p>}</p><h2><span id="六-搜索优化策略">六、搜索优化策略</span></h2><p>@card{</p><p>}</p><h2><span id="七-动态规划优化策略">七、动态规划优化策略</span></h2><p>@card{</p><ol><li><h6><span id="费用提前延后计算没有关于某个维度的限制条件这个维度纯粹用来计算费用考虑是否可以提前计算">费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算</span></h6></li></ol><p>}</p><h2><span id="七-常见有用思想与技巧-性质">七、常见有用思想与技巧、性质</span></h2><p>@card{</p><ol><li><h6><span id="正难则反广泛应用于各种问题">正难则反：广泛应用于各种问题</span></h6><ul><li>答案不容易求、不容易划分，利用全集减去补集从而求出答案</li><li>字典序最小的方案：结合性质5，倒序处理</li></ul></li><li><h6><span id="单调性一阶导数不一定是常规意义上的函数也可能是自己实现的复杂函数">单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数</span></h6></li><li><h6><span id="凹凸性二阶导数凸壳优化">凹凸性（二阶导数）：凸壳优化</span></h6></li><li><h6><span id="对称性优化枚举顺序-减少计算量">对称性：优化枚举顺序、减少计算量</span></h6></li><li><h6><span id="一定的小于意为在有所有状态中在当前步骤选择了某个决策会导致一些决策一定小于">“一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于</span></h6><ul><li>例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于</li><li>试填法、字典序</li></ul></li></ol><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也许很有用，也许没什么卵用。
    
    </summary>
    
      <category term="细节" scheme="http://arintaro.com/categories/%E7%BB%86%E8%8A%82/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="方法论" scheme="http://arintaro.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2018 D1T3 赛道修建</title>
    <link href="http://arintaro.com/2019/04/27/Contest/NOIP%202018/D1T3%20%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/"/>
    <id>http://arintaro.com/2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/</id>
    <published>2019-04-27T09:01:25.456Z</published>
    <updated>2019-04-27T12:20:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>祭奠我考场写挂的55pts, 那时我真是个ruozhi。<br><a id="more"></a></p><h2><span id="description">Description:</span></h2><p>@card{</p><p>给定一棵带权树，要求从树上划分出$m$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \times 10^4$级别（实际上可以出到$5\times10^5$左右，边权再缩小点甚至能更大，卡$sort$?(雾</p><p>}</p><h2><span id="solution">Solution:</span></h2><p>@card{</p><p>分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。<br>既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助。</p><p>发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。</p><p>能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。<br>考虑<strong>性质1：每条路径对答案的贡献其实是相同的，都是$1$</strong>，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之<strong>性质2：父节点只能有一条路径到当前节点</strong>，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在<strong>保证配对数最大的同时，还要保证剩下的深度最大</strong>，从而上传给父节点。</p><p>至此，我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？<br>然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下：</p><blockquote><p>给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。</p></blockquote><p>这里网上通常有三种实现形式，我从复杂到简洁讲：</p><h4><span id="算法1贪心平衡树双向链表-删除标记">算法1：贪心+平衡树/双向链表、删除标记</span></h4><p>首先，我们显然有<strong>性质1：应该优先配对较小的深度</strong>。</p><blockquote><p>如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。<br>不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。<br>实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。</p></blockquote><p>然后，我们有<strong>性质2：最优方案中，每个最小值都应该与能配对的最小的数配对</strong>，显然，不证了。<br>基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的<br>然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（<del>期望得分：55分，实际得分：100分</del></p><h4><span id="算法2双指针栈">算法2：双指针+栈</span></h4><p>一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是<strong>能配对的最小的数</strong>。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。<br>然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。</p><h4><span id="std算法双指针">STD算法：双指针</span></h4><p>那么有没有不用栈，常数更加优秀（并没有，更加简洁的算法呢？有，就是本题的std1。<br>基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j$，配对到了左指针$i$，如果$j-1$不能与$i$配对，那么剩下的右指针也显然配对不了，所以$i$必须得与$j$配对，这时我们更新$last = j - 1$即可，如果最后考虑一个右指针$j$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]$成功配对的右指针平移到$[j,last-1]$，然后用$last$对应的值更新上传的最大值。由于网上$blog$没有对这个算法的讲解，$std$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std$在干什么。。</p><p>这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\frac{\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，<del>从而实现了卡sort的可能</del>。<br>还有俩剪枝，二分上界可以设到$min{\frac{\sum{w_i}}{m} ,d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。</p><p>}</p><h2><span id="code">Code:</span></h2><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rid = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>, sumw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[maxn], rcnt[<span class="number">1</span>&lt;&lt;rid], rmod = (<span class="number">1</span> &lt;&lt; rid) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">256</span>) &#123; sort(arr+<span class="number">1</span>, arr+n+<span class="number">1</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">0</span>; i&lt;=<span class="number">31</span>; i+=rid) &#123;</span><br><span class="line"><span class="built_in">memset</span>(rcnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rcnt));</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=rmod; j++) rcnt[j] += rcnt[j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=n; k&gt;=<span class="number">1</span>; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k];</span><br><span class="line"><span class="built_in">memcpy</span>(arr, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">sumw += nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn], dist[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs(ev[i], x, mid);</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[ev[i]] + ew[i] &gt;= mid) res++;</span><br><span class="line"><span class="keyword">else</span> arr[++tot] = dist[ev[i]] + ew[i];</span><br><span class="line">&#125;</span><br><span class="line">rsort(arr, tot), dist[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++];</span><br><span class="line"><span class="keyword">if</span>(i == j) &#123; dist[x] = arr[last]; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(j &amp;&amp; arr[i] + arr[j<span class="number">-1</span>] &lt; mid) last = j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxd, dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]);</span><br><span class="line">dp[x] = max(dp[x], dp[y] + ew[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">dfs2(root, root);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = min(maxd, sumw / m);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(root, root, mid) &gt;= m) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>@card{</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sit multiset<span class="meta-string">&lt;int&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sumw = <span class="number">0</span>, dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">sumw += nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs(ev[i], x, mid);</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">dist[x] = <span class="number">0</span>, s.clear();</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[ev[i]] + ew[i] &gt;= mid) res++;</span><br><span class="line"><span class="keyword">else</span> s.insert(dist[ev[i]] + ew[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; <span class="comment">// nxt一定在it后面</span></span><br><span class="line">sit nxt = s.lower_bound(mid - (*it));</span><br><span class="line"><span class="keyword">if</span>(nxt == it &amp;&amp; nxt != s.end()) nxt++;</span><br><span class="line"><span class="keyword">if</span>(nxt == s.end()) &#123; it++; <span class="keyword">continue</span>; &#125;</span><br><span class="line">s.erase(nxt), s.erase(it++), res++; <span class="comment">// 注意先删nxt, 不然it++可能等于nxt</span></span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!s.empty()) dist[x] = *s.rbegin();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = sumw / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(root, root, mid) &gt;= m) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;祭奠我考场写挂的55pts, 那时我真是个ruozhi。&lt;br&gt;
    
    </summary>
    
      <category term="比赛" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="NOIP2018" scheme="http://arintaro.com/categories/%E6%AF%94%E8%B5%9B/NOIP2018/"/>
    
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://arintaro.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="贪心" scheme="http://arintaro.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="双指针" scheme="http://arintaro.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>树的相关性质(更新中)</title>
    <link href="http://arintaro.com/2019/04/27/Algorithm/%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
    <id>http://arintaro.com/2019/04/27/Algorithm/树的相关性质/</id>
    <published>2019-04-27T09:01:25.373Z</published>
    <updated>2019-04-27T12:11:36.049Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。</p><a id="more"></a><h2><span id="一-树的直径">一、树的直径</span></h2><p>@card{</p><h4><span id="一求法">（一）求法：</span></h4><ol><li><h6><span id="两次dfs">两次DFS</span></h6><p>比较容易求出具体路径，缺点是实现比树形DP麻烦，并且要求树的边权非负。</p></li><li><h6><span id="树形dp">树形DP</span></h6><p>实现简单，但求具体路径比较麻烦，适用于只需要直径长度的情况（如二分答案的上界剪枝等），对边权没有要求。</p></li></ol><h4><span id="二性质">（二）性质：</span></h4><ol><li><h6><span id="基本思想">基本思想：</span></h6><p>分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。</p></li><li><h6><span id="任意一个节点作根直径两端点一定是叶子节点">任意一个节点作根，直径两端点一定是叶子节点。</span></h6></li><li><h6><span id="距离任意点最远的点一定是直径的一个端点-相当有用的性质">距离任意点最远的点一定是直径的一个端点。（相当有用的性质</span></h6><ul><li>设从A出发找到最远点B</li><li>如果A已经是直径上一个端点，正确性显然。</li><li>如果不是，考虑反证，设直径为CD。</li><li>由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。</li><li>则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。</li></ul></li><li><h6><span id="树可能会有多个直径但是一定会有一条路径也可能是一个点的公共部分且在这部分两侧的长度一定相等">树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分，且在这部分两侧的长度一定相等。</span></h6><ul><li>显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。</li><li>如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。</li></ul></li><li><h6><span id="对于两棵树用一条边连接它们新的直径的端点一定是原两颗树直径的端点">对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。</span></h6><ul><li>如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。</li></ul></li><li><h6><span id="往一棵树里加一个点直径的端点最多改变一个">往一棵树里加一个点，直径的端点最多改变一个</span></h6><ul><li>先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。</li></ul></li></ol><h4><span id="三在具体题目下的证明例子">（三）在具体题目下的证明例子</span></h4><ol><li>NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，<del>然而原题不要求证明这些东西</del><ul><li>在任意直径上求最小偏心距都相等</li><li>考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。</li><li>考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。</li></ul></li></ol><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了非负权边树的一些简单性质，大概会长期更新，并且大概率不会有图/代码。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="总结" scheme="http://arintaro.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="图论" scheme="http://arintaro.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Template/%E5%B0%8F%E5%B7%A5%E5%85%B7/log2%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <id>http://arintaro.com/2019/04/27/Template/小工具/log2的姿势/</id>
    <published>2019-04-27T09:01:25.331Z</published>
    <updated>2019-04-27T13:01:50.095Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="1转double法">1.转double法</span></h4><p>@card{</p><p>double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，几乎是$O(1)$的。<br>请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">mlog2</span><span class="params">(lint x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> t = (<span class="keyword">double</span>)x;</span><br><span class="line">    <span class="keyword">return</span> (lint)((lint&amp;)t &gt;&gt; <span class="number">52</span> &amp; <span class="number">63</span>) + <span class="number">1</span>; <span class="comment">// 注意最前面还要再转一次long long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Luogu ST表 传统打表法 1011ms <a href="https://www.luogu.org/recordnew/show/13493959" target="_blank" rel="noopener">https://www.luogu.org/recordnew/show/13493959</a><br>Luogu ST表 double法 1009ms <a href="https://www.luogu.org/recordnew/show/18155615" target="_blank" rel="noopener">https://www.luogu.org/recordnew/show/18155615</a><br>实测后发现速度差异不大, 开了O2打表会快一些</p><p>}</p><h4><span id="2打表法">2.打表法</span></h4><p>@card{</p><p>显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论</p><p>$$\forall k \in [0,35], 2^kmod\ 37,\ 取遍[1,36]$$</p><p>}</p><h4><span id="3double法的具体测试">3.double法的具体测试</span></h4><p>@card{</p><ul><li>$test\ site:$<a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3865</a></li><li>$task:$ 实现函数mlog2，需要$O(1)$返回$\lfloor log_2{x} \rfloor​$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.org/problemnew/show/P3865</span></span><br><span class="line"><span class="comment">// 要求：实现函数mlog2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readint(x) scanf(<span class="meta-string">"%d"</span>,&amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, logn;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">mlog2</span><span class="params">(lint x)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rmq[<span class="number">20</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getrmq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) rmq[<span class="number">0</span>][i] = arr[i];</span><br><span class="line">    <span class="keyword">for</span>(rint d=<span class="number">1</span>; d&lt;=logn; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; d), half = (<span class="number">1</span> &lt;&lt; (d<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(rint i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=n; i++) &#123;</span><br><span class="line">            rmq[d][i] = max(rmq[d<span class="number">-1</span>][i], rmq[d<span class="number">-1</span>][i+half]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loglen = mlog2(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(rmq[loglen][l], rmq[loglen][r-(<span class="number">1</span>&lt;&lt;loglen)+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readint(n), readint(m);</span><br><span class="line">    logn = <span class="built_in">ceil</span>(log2(n));</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">    getrmq();</span><br><span class="line">    <span class="keyword">int</span> nl, nr;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        readint(nl), readint(nr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(nl,nr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;&lt;span id=&quot;1转double法&quot;&gt;1.转double法&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;@card{&lt;/p&gt;
&lt;p&gt;double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;amp;63取出即可，然而编译器不会让你
      
    
    </summary>
    
    
  </entry>
  
</feed>
