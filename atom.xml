<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rintaro&#39;s Blog</title>
  
  <subtitle>Algorithm and Anime(?</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arintaro.com/"/>
  <updated>2019-04-25T02:08:22.633Z</updated>
  <id>http://arintaro.com/</id>
  
  <author>
    <name>Rintaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Essay/LNOI2019%20&amp;%20%E5%A4%9A%E7%9C%81%E8%81%94%E8%80%83%20%E6%B8%B8%E8%AE%B0/"/>
    <id>http://arintaro.com/2019/04/27/Essay/LNOI2019 &amp; 多省联考 游记/</id>
    <published>2019-04-27T09:01:25.797Z</published>
    <updated>2019-04-25T02:08:22.633Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Day1"><a href="#Day1" class="headerlink" title="Day1:"></a>Day1:</h4><p>待更，鸽了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Day1&quot;&gt;&lt;a href=&quot;#Day1&quot; class=&quot;headerlink&quot; title=&quot;Day1:&quot;&gt;&lt;/a&gt;Day1:&lt;/h4&gt;&lt;p&gt;待更，鸽了&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Detail/%E7%BB%BC%E5%90%88%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://arintaro.com/2019/04/27/Detail/综合技巧与实践/</id>
    <published>2019-04-27T09:01:25.547Z</published>
    <updated>2019-04-11T06:23:34.289Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、杂项"><a href="#一、杂项" class="headerlink" title="一、杂项"></a>一、杂项</h4><p>​    1.值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域</p><h4 id="二、STL相关"><a href="#二、STL相关" class="headerlink" title="二、STL相关"></a>二、STL相关</h4><h5 id="1-algorithm"><a href="#1-algorithm" class="headerlink" title="1.algorithm"></a>1.algorithm</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.l</span>ower_bound &amp; upper_bound <span class="comment">//我就算饿死，死外面，也不会自己写一个二分查找的</span></span><br><span class="line"><span class="keyword">int</span> pos = lower_bound(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>,val) - arr; <span class="comment">//在有序数组[1,n]中查第一个 &gt;=val的数</span></span><br><span class="line"><span class="comment">// 最后一个参数可以传比较函数，需要与序列顺序相同，即 单增 &lt; less 和 单减 &lt; greater</span></span><br><span class="line"><span class="number">2.u</span>nique <span class="comment">//常用于离散化</span></span><br><span class="line">       n = unique(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>) - (arr+<span class="number">1</span>); <span class="comment">//去重，新元素存在[1,n]</span></span><br><span class="line">   <span class="number">3.</span>inplace_merge merge <span class="comment">// 常用于CDQ分治中，不要cdq里套sort了！！</span></span><br><span class="line">       <span class="comment">// 数组 arr分为有序的两部分 [1,mid] [mid+1,n]</span></span><br><span class="line">       inplace_merge(arr+<span class="number">1</span>,arr+mid+<span class="number">1</span>,arr+n+<span class="number">1</span>);</span><br><span class="line">merge(first1,last1,first2,last2,result,compare);</span><br><span class="line"><span class="number">4.</span>nth_element <span class="comment">//数组中O(n)找第k大，前k个数一定都在[1，k]</span></span><br><span class="line">       nth_element(arr+<span class="number">1</span>,arr+k,arr+n+<span class="number">1</span>);</span><br><span class="line"><span class="number">5.</span>sort stable_sort <span class="comment">// 后一个可以稳定排序</span></span><br><span class="line">   <span class="number">6.</span>reverse <span class="comment">// 跟sort传参一样，序列反转</span></span><br></pre></td></tr></table></figure><h5 id="2-vector"><a href="#2-vector" class="headerlink" title="2.vector"></a>2.vector</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">vector</span>的clear不会释放空间，需要释放空间的话，需要:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(a); <span class="comment">// 但是几乎比clear慢一倍</span></span><br></pre></td></tr></table></figure><h4 id="三、NOI-Linux相关"><a href="#三、NOI-Linux相关" class="headerlink" title="三、NOI Linux相关"></a>三、NOI Linux相关</h4><p>​    1.Emacs相关（M为Alt键，C为Ctrl键</p><ul><li>M+x输入命令 C+x+k关闭当前窗口</li><li>Options-Use CUA Keys (转换复制粘贴快捷键)</li><li>Options-Customize Emacs-Custom-Themes-Tango Dark （转换主题）</li><li>Options-Set Default Font - Ubuntu Mono 20-30（变更字体</li><li>C-x-2 水平切分当前Buffer, C-x-3 左右切分</li><li>命令 Find-file后， ~/.emacs 可以直接打开配置文件</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">global-linum-mode</span> <span class="literal">t</span>) <span class="comment">;;line num 显示行号</span></span><br><span class="line">(<span class="name">setq</span> c-basic-offset <span class="number">3</span>) <span class="comment">;; 变更缩进</span></span><br><span class="line">(<span class="name">setq</span> default-tab-width <span class="number">3</span>) </span><br><span class="line"></span><br><span class="line">(<span class="name">electric-pair-mode</span> <span class="literal">t</span>) <span class="comment">;;electric pair 括号补全</span></span><br><span class="line">(<span class="name">electric-layout-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">electric-indent-mode</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq-default</span> cursor-type 'bar) <span class="comment">;;光标竖线</span></span><br><span class="line">(<span class="name">show-paren-mode</span> <span class="literal">t</span>) <span class="comment">;;show paren 括号配对</span></span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> [f4] 'shell) <span class="comment">;;摁F4进入shell</span></span><br><span class="line">(<span class="name">defun</span> compile-file()(<span class="name">interactive</span>)</span><br><span class="line">(<span class="name">compile</span>(<span class="name">format</span> <span class="string">"g++ -o '%s' '%s' -lm -Wall -g"</span></span><br><span class="line">(<span class="name">file-name-sans-extension</span>(<span class="name">buffer-name</span>))(<span class="name">buffer-name</span>))))</span><br><span class="line">(<span class="name">global-set-key</span> [f5] 'compile-file) <span class="comment">;;摁F5编译</span></span><br><span class="line">(<span class="name">global-set-key</span> [f6] 'gdb) <span class="comment">;;摁F6进入gdb调试</span></span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-s"</span>) 'save-buffer) <span class="comment">;; Ctrl+s变为保存</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"C-a"</span>) 'mark-the-whole-buffer) <span class="comment">;; Ctrl+s变为保存</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"RET"</span>) 'newline-and-indent) <span class="comment">;;回车自动缩进</span></span><br></pre></td></tr></table></figure><h4 id="四、对拍相关"><a href="#四、对拍相关" class="headerlink" title="四、对拍相关"></a>四、对拍相关</h4><p>​    1.程序运行时间  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> t = clock();</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; (clock() - t) / CLOCKS_PER_SEC &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、杂项&quot;&gt;&lt;a href=&quot;#一、杂项&quot; class=&quot;headerlink&quot; title=&quot;一、杂项&quot;&gt;&lt;/a&gt;一、杂项&lt;/h4&gt;&lt;p&gt;​    1.值域范围奇怪，如带0等会影响树状数组一类的东西，需要加减移动值域&lt;/p&gt;
&lt;h4 id=&quot;二、STL相关&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Detail/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://arintaro.com/2019/04/27/Detail/常见代码实现细节/</id>
    <published>2019-04-27T09:01:25.528Z</published>
    <updated>2019-04-26T12:52:52.032Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录的问题，全是我调过的问题orz</p><h4 id="一、变量溢出问题"><a href="#一、变量溢出问题" class="headerlink" title="一、变量溢出问题"></a>一、变量溢出问题</h4><ol><li>乘是一个相当危险的操作，只要有乘，必须考虑溢出问题，lint型做乘法带模数时，要写快速乘</li><li>int型涉及到前缀和/乘法时，注意要转lint防爆，有的题表面是1e9左右，但有多次加法操作，也得开lint</li><li>INT范围是 2^31-1也就是2.1e9，一般来说1e9可以安全加减一次，平时inf开到1e9即可， 但是要注意毒瘤题范围2^32或者左右，一定要开long long，</li><li>unsigned类型：值域$[0,2^{8<em>size}-1]$溢出后对$2^{8</em>size}$取模。</li><li>signed类型: 值$[-2^{8<em>size-1},2^{8</em>size-1}-1]$，溢出后也取模，只不过会平移到值域范围内。</li><li>long double型可以存下long long型的所有有效数字，遇到long long的溢出问题可以考虑转long double存整数</li></ol><h4 id="二、运算问题"><a href="#二、运算问题" class="headerlink" title="二、运算问题"></a><strong>二、运算问题</strong></h4><ol><li>有时候模数是一个负数，要得到最小非负整数解前，需要把负数转成正数</li><li>要注意乘除法的顺序，是否需要向下取整、先进行除法的话能否整除</li><li>做乘法初值一定要设为1，例如线段树的乘法Lazytag，累乘的初值，</li><li>维护一个最小值变量初值要设为inf，维护最大值有负数的时候要赋为-inf</li><li>注意非负整数与“正整数”的区别，值域里可能会有0</li><li>有时候求区间$[l,r]$之类的，$l&gt;=1$，有时候我们利用区间可减性会导致值域里出现$0$，注意特判。</li></ol><h4 id="三、语言问题"><a href="#三、语言问题" class="headerlink" title="三、语言问题"></a><strong>三、语言问题</strong></h4><ol><li>有时需要注意\n \r的问题，建议写手动读入的时候直接特判掉</li><li>宏定义千万别忘了括号，调一辈子</li><li>lint 输入输出 %lld，ldob输入输出 %Lf</li><li>数组作为形参会退化成指针，不能再用sizeof求大小</li><li>题目中要求“当输入用例 n=k=0 时，表示输入终止”, 不能写 n&amp;&amp;k, 因为可能n与k其中一个还可能等于0</li><li>程序中常量默认是INT型，设定 long long a = 10000 <em> 9999 </em> 9998 等一定要注意常量爆INT的问题</li><li>使用二分查找时，要注意不存在的情况，我们常用的写法下标会返回n+1，注意特判掉</li><li>写递归式程序、维护双指针时，一定要把需要维护的东西列个表，比如vis数组等</li><li>维护双指针时，需要注意运算顺序，j–，i++是发生在操作前还是操作后，应该具体写出定义</li><li>计算某些东西时，如果计算后需要移动指针，注意别先移动指针了。（Acwing 294）</li><li>写一些嵌套循环移动同一个或多个指针时，必须考虑不存在，不移动，移动多了越界的情况，不然等着WA普及-吧</li><li>维护单调队列的一些变形时（如点队列维护两点间斜率，区间队列带二分等），一定要仔细考虑边界情况和各种退队情况进队情况，这种东西极其容易写炸。</li></ol><h4 id="四、数学相关"><a href="#四、数学相关" class="headerlink" title="四、数学相关"></a><strong>四、数学相关</strong></h4><ol><li><p>BSGS注意判断，算出的指数要大于等于0，即 $i*len - ht[Yk] &gt;= 0​$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Z == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//Luogu P2485 [SDOI2011]计算器</span></span><br><span class="line"><span class="keyword">if</span>(Y % P == <span class="number">0</span>) <span class="keyword">return</span> Z%P == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>; </span><br><span class="line">i*len - ht[Yk] &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>无论是什么题目，题目中保证质数了，也有可能其中的某个数是这个质数的倍数，注意判断这种情况</p></li><li>exgcd求出的d，如果要算最小非负解，一定把模数取决定值，才能用我们惯用的写法</li><li>如果在模意义下做减法，一定要随时调整至非负即 $(a%7 + 7) % 7$ 才是安全的</li><li>计算组合数时，要注意 $0!=1$ 以及它的逆元，选0一个数一定时一种方案，$m&lt;n\ ||\ m&lt;0\ ||\ n&lt;0$时0种方案</li><li>试填法，一般最后一位可以等于“后面没有位了，最后一位小于等于即可保证一定小于等于”，前置位必须保证小于</li></ol><h4 id="五、数据结构相关"><a href="#五、数据结构相关" class="headerlink" title="五、数据结构相关"></a>五、数据结构相关</h4><ol><li>维护一个差分序列时，时常会有+1,-1，为了防止爆炸，建议你把值域范围开到[0,n+1]</li><li>分块题由于最后一段的右端点是$min(t*len,n)$, 建议你直接预处理出端点，不要每次特判，特别容易错</li><li>分块题开数组不要开混了</li><li>在权值线段树或平衡树上求k小时，函数一般定义时p的子树中求k小，此时如果进右子树别忘了减去“已经确定比它小的个数”</li><li>常见的分治$(l+r) &gt;&gt; 1$ 作为$mid$, 层数为[log2n，log2n+2]，算内存的时候记得取 log2n + 2</li><li>静态线段树空间直接开4<em>n防越界，动态开点的范围为 $[mlog_2m, 2</em>n-1]$</li><li>翻转序列等需要改变子树顺序的延时标记需要在进入时立即下放，为了防止翻车，我们不如无论什么标记都是进入时立即下放</li><li>下放延时标记时，需要考虑此标记对其他标记的影响，需要一起结算，（eg: 区间加区间最小值最大值的影响</li><li>pushup与pushdown时，注意不要错误地把下标为0的节点信息更新来更新去</li><li>将操作重新排序后，注意是删除操作优先，还是增加操作优先</li><li>邻接表 i=nxt[i], 千万别写成 i=nxt[x]</li><li>如果一个数据结构题需要大量判边界，前驱后继是否存在等，一般是要插几个inf或-inf的虚点减少特判。</li><li>有延时标记+动态开点时，注意下传的延时标记会不会传到0上，让下传的标记回归虚无。</li><li>有时需要特判“不存在”、”没找到“的情况</li><li>写一些链式的指针结构时，如果需要清空/删除某些东西，一定要记得清空<strong>相关</strong>指针，数据清不清无所谓。</li></ol><h4 id="六、图论相关"><a href="#六、图论相关" class="headerlink" title="六、图论相关"></a>六、图论相关</h4><ol><li>如果无向图里有重边，一般只加一次，无向图邻接表开两倍，树邻接表开到节点数即可。</li><li>邻接矩阵注意初值是0还是inf</li><li>在有负权边时，树的直径不能通过两次DFS求。</li><li>无向图邻接表修改边的属性时，注意也要把反向的边也一起修改。</li><li>带有重边的图中，不能只记录来源节点，可能需要记录来源边，来处理一些情况，如“二元环”。</li><li>在写图的遍历DFS、BFS时，别忘了递归子节点/将子节点入队，（别笑，我真的干过，还调了一段时间。。</li></ol><h4 id="七、动态规划相关"><a href="#七、动态规划相关" class="headerlink" title="七、动态规划相关"></a>七、动态规划相关</h4><ol><li>要仔细考虑初值的设计，比如背包问题，要求“背包必须装满”，按照实际含义，$dp[0] = 0, \forall j \ \ dp[j] = -inf$，因为在第0个物品时，只有“没装东西”是合法的状态。</li><li>状压DP把状态映射到集合中后，注意初值设置下标也要是集合中的下标，例如0映射到1，需要$dp[0][1] = 1$</li><li></li></ol><h4 id="八、杂项"><a href="#八、杂项" class="headerlink" title="八、杂项"></a>八、杂项</h4><ol><li>题目中的限制条件一定要用手写出来，不然很容易写混 &lt;= &gt;=</li><li>一些涉及到坐标，线段长的问题，一定要仔细考虑边界情况以及定义，有时候需要+1，-1</li><li>在经过对拍/大样例后，程序仍可能WA的原因一般是溢出(尤其需要注意(比较)函数传参时)、数组越界(小范围越界不会RE)。</li></ol><h4 id="九、奇异的语言细节"><a href="#九、奇异的语言细节" class="headerlink" title="九、奇异的语言细节"></a>九、奇异的语言细节</h4><ol><li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++标准并没有规定参数的求值顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(++x,x); <span class="comment">// 输出 1 1</span></span><br><span class="line">test(++x,x<span class="number">-1</span>); <span class="comment">// 输出1 -1</span></span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里记录的问题，全是我调过的问题orz&lt;/p&gt;
&lt;h4 id=&quot;一、变量溢出问题&quot;&gt;&lt;a href=&quot;#一、变量溢出问题&quot; class=&quot;headerlink&quot; title=&quot;一、变量溢出问题&quot;&gt;&lt;/a&gt;一、变量溢出问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;乘是一个相当危险的操作，只
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Detail/OI%E4%B8%AD%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://arintaro.com/2019/04/27/Detail/OI中知识点与技巧总结/</id>
    <published>2019-04-27T09:01:25.509Z</published>
    <updated>2019-04-18T02:33:00.446Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、最优化问题"><a href="#一、最优化问题" class="headerlink" title="一、最优化问题"></a>一、最优化问题</h4><ol><li>二分答案：答案具有“单调性”，外层花费$log\ ans$的时间转化为判定性问题<ul><li>答案具有“单调性”：注意是先0后1函数，还是先1后0函数，和二分的实现形式，是一直保持小于，还是能累加就累加？ 一般定义判定是“是否存在一个小于等于、是否存在一个大于等于”，这么定义是显然有单调性的</li><li>二分出的答案一般对check的进行有所帮助</li></ul></li><li>动态规划：一定要有最优子结构性质</li><li>贪心：一般作为正解中的一个步骤出现，用于去掉某些限制条件，很少作为一个题的main idea出现，<ul><li>可以小范围搜索+多重限制贪心乱搞</li><li>一般一个错误的贪心，都能提炼出一些在某些限制条件下的正确性质</li></ul></li><li></li></ol><h4 id="二、计数问题"><a href="#二、计数问题" class="headerlink" title="二、计数问题"></a>二、计数问题</h4><h4 id="三、数据结构题"><a href="#三、数据结构题" class="headerlink" title="三、数据结构题"></a>三、数据结构题</h4><h4 id="四、数学题"><a href="#四、数学题" class="headerlink" title="四、数学题"></a>四、数学题</h4><ol><li>求和题：核心思想：[交换求和顺序]</li><li></li></ol><h4 id="五、图论问题"><a href="#五、图论问题" class="headerlink" title="五、图论问题"></a>五、图论问题</h4><h4 id="六、搜索优化策略"><a href="#六、搜索优化策略" class="headerlink" title="六、搜索优化策略"></a>六、搜索优化策略</h4><h4 id="七、动态规划优化策略"><a href="#七、动态规划优化策略" class="headerlink" title="七、动态规划优化策略"></a>七、动态规划优化策略</h4><ol><li>费用提前/延后计算：没有关于某个维度的限制条件，这个维度纯粹用来计算费用，考虑是否可以提前计算</li><li></li></ol><h4 id="七、常见有用思想与技巧、性质"><a href="#七、常见有用思想与技巧、性质" class="headerlink" title="七、常见有用思想与技巧、性质"></a>七、常见有用思想与技巧、性质</h4><ol><li>正难则反：广泛应用于各种问题<ul><li>答案不容易求、不容易划分，利用全集减去补集从而求出答案</li><li>字典序最小的方案：结合性质5，倒序处理</li></ul></li><li>单调性（一阶导数）：不一定是常规意义上的“函数”，也可能是自己实现的复杂函数</li><li>凹凸性（二阶导数）：凸壳优化</li><li>对称性：</li><li>“一定的小于”：意为在有所有状态中，在当前步骤选择了某个决策，会导致一些决策一定小于<ul><li>例如平衡树找kth，如果在某个节点上向右走，那么左子树的节点一定小于</li><li>试填法、字典序</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、最优化问题&quot;&gt;&lt;a href=&quot;#一、最优化问题&quot; class=&quot;headerlink&quot; title=&quot;一、最优化问题&quot;&gt;&lt;/a&gt;一、最优化问题&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;二分答案：答案具有“单调性”，外层花费$log\ ans$的时间转化为判定性问题&lt;ul&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Contest/NOIP%202018/D1T3%20%E8%B5%9B%E9%81%93%E4%BF%AE%E5%BB%BA/"/>
    <id>http://arintaro.com/2019/04/27/Contest/NOIP 2018/D1T3 赛道修建/</id>
    <published>2019-04-27T09:01:25.456Z</published>
    <updated>2019-04-25T09:07:27.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h4><p>给定一棵带权树，要求从树上划分出$m​$条不相交的路径，令“长度最小的路径的长度”最大，数据范围在$5 \times 10^4​$级别（实际上可以出到$5\times10^5​$左右，边权再缩小点甚至能更大，卡$sort​$?(雾</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution:"></a>Solution:</h4><p>分析一下出题方向，这个描述正解基本是二分答案没跑了。一般来说，有一个不错的$idea$，但是难度还不够/卡不掉乱搞，需要往外面套个壳，最容易套也最好想的就是加个”最小值最大、最大值最小”的描述，外层就套上了个二分答案的壳，所以我们肯定是优先考虑二分答案的。<br>既然确定了算法是二分答案，每次判断能否有$m$条路径，长度至少有$mid$，那么二分的出的答案”路径的最小长度”必然对$check$有所帮助，发现不容易$check$，因为我们并不知道“从哪里划分路径”，如果这一步划分出了一条边，可能较大影响后面的计算，所以我们必须确定一个计算顺序，让我们可以容易的划分路径。按照套路，思考到这里，肯定需要有一个性质帮助我们确定计算顺序，也就是“从哪里下手”。能够确定计算顺序的性质一般来说都是贪心，就像“疫情控制”一样。<br>考虑<strong>性质1：每条路径对答案的贡献其实是相同的，都是$1$</strong>，我们之前做过不少依靠“对答案贡献相同”的贪心，都是排序以后考虑怎么选对后序影响最好，然后能选就选，从此确定计算顺序。非常像这里的模型，考虑怎么“排序”，如果当前节点往下能构成一条长度大于等于$mid$的路径，那就直接选上这条路径，因为这条路径对答案的贡献至多是$1$，即使把它留给父节点用，答案也肯定不会更优，加之<strong>性质2：父节点只能有一条路径到当前节点</strong>，答案反而还可能变得更坏，所以我们可以按照类似点分治的套路从下到上，每次考虑经过当前节点的路径，能配对就配对，注意这里在<strong>保证配对数最大的同时，还要保证剩下的深度最大</strong>，从而上传给父节点。我们二分出的答案也有了用武之地，发现的性质也很简洁，在考场上基本可以确定这就是正解想法了。（您哪来的自信？<br>然而到这里，才是本文的正题，上面都是废话，没人不会的，具体该怎么实现呢？我们可以把上面的问题抽象一下：</p><blockquote><p>给定一个数列和一个数$mid$，要求从数列中选出最多对数，和大于等于$mid$，并在此基础上保证剩下的数中的“最大值”最大。</p></blockquote><p>这里网上通常有三种实现形式，我从复杂到简洁讲：</p><h6 id="算法1：贪心-平衡树-双向链表、删除标记"><a href="#算法1：贪心-平衡树-双向链表、删除标记" class="headerlink" title="算法1：贪心+平衡树/双向链表、删除标记"></a>算法1：贪心+平衡树/双向链表、删除标记</h6><p>首先，我们显然有<strong>性质1：应该优先配对较小的深度</strong>。</p><blockquote><p>如果您觉得并不显然，这是证明：由于我们考虑了每个深度能否配对，这肯定保证了对数最多。以我们只要证明可以保证剩下的最大值最大即可。<br>不妨考虑当前还没被删能配对最小的数，它显然可以与当前还没被删最大的数配对，如果存在一种方案，不配对它，且对数相同，最大值更大：如果这种方案配对了当前最大值，我们显然可以把当前最大值配对的数换成当前最小的，从而不改变最大值；如果这种方案没配对当前最大值，那么我们把最小值和最大值一配会增多一个对数，与假设矛盾，故这样的方案不存在，我们应该优先配较小的。<br>实际上，我觉得这种显然性质的证明大多都是反证一步就出来了，再不行带个讨论，比较废话。</p></blockquote><p>然后，我们有<strong>性质2：最优方案中，每个最小值都应该与能配对的最小的数配对</strong>，显然，不证了。<br>基于这俩性质，我们可以直接实现，大概就是从小到大考虑每个深度$deep[i]$，在平衡树里找最小的 $deep[y]$满足$deep[y] \ge mid - deep[x]$即可，找完直接删了，这种方法最显然，复杂度和常数都最差，在菊花图上非常容易T掉，具体实现时，还要注意“没找到”，“找到自己”，“迭代器删除”等细节（如果没有$multiset$，代码量也是最大的<br>然后还有复杂度不对的乱搞，比如用$vector$暴力$erase$，用双向链表指针扫来扫去，用二分+删除标记，二分到被删除的就暴力往后找，这些都容易退化到$O(n^2)$，不说了。（<del>期望得分：55分，实际得分：100分</del></p><h6 id="算法2：双指针-栈"><a href="#算法2：双指针-栈" class="headerlink" title="算法2：双指针+栈"></a>算法2：双指针+栈</h6><p>一般这种形式的数列问题都能用排序+双指针解决，我们接着考虑，可以先排序，由于性质2，我们可以对每个左指针，把右指针一直往左扫，直到右指针指的数没法配对为止，中途把右指针扫到的数都入栈，这样栈顶就是<strong>能配对的最小的数</strong>。当然，如果栈里没有数就不能配对了，它就是“剩下的数”，记得用它更新上传给父节点的最大深度。最后再把左指针向右移动一个，由于左指针指的数变大了，以前能配对的数现在还都能配对，不影响正确性。<br>然后配对完栈里的数肯定都能两两配对，如果还剩奇数个，我们显然还可以把剩下最大的数上传给父节点，答案累加即可。我个人认为这种算法是最优秀的，没什么细节，理解起来还不困难。</p><h6 id="STD算法：双指针"><a href="#STD算法：双指针" class="headerlink" title="STD算法：双指针"></a>STD算法：双指针</h6><p>那么有没有不用栈，常数更加优秀（并不，更加简洁的算法呢？有，就是本题的标算。<br>基于算法2，我们可以对每个右指针考虑能配对的左指针，把左指针一直往右移，直到能配对为止，并且中间用配对不了的更新上传的最大值。然而这样会导致留下的不是最大的，所以我们需要另外维护一个指针$last​$，表示最大（最右边）的一个右指针，它配对的左指针可以往前找一个更小的右指针进行配对。对一个右指针$j​$，配对到了左指针$i​$，如果$j-1​$不能与$i​$配对，那么剩下的右指针也显然配对不了，所以$i​$必须得与$j​$配对，这时我们更新$last = j - 1​$即可，如果最后考虑一个右指针$j​$的时候，左右指针相撞，那么就剩下了一个数（对应算法2中的栈里的数还剩奇数个），这时我们可以把$[j+1,last]​$成功配对的右指针平移到$[j,last-1]​$，然后用$last​$对应的值更新上传的最大值。由于网上$blog​$没有对这个算法的讲解，$std​$里的变量名还都不超过两个字母，ruozhi的我看了两节课才看懂$std​$在干什么。。</p><p>这时有人就要问了，优化了一大顿，我算法1也是$O(nlogn log\frac{\sum{w_i}}{m})$的，您$std$不还是得排序，复杂度都一样啊。然而并不是，$std$采用了高端的基数排序，把排序复杂度降到了$O(n)$，<del>从而实现了卡sort的可能</del>。<br>还有俩剪枝，二分上界可以设到$min{\frac{\sum{w_i}}{m} ,d}$，其中$d$为直径长度。然后每次二分答案大于等于$m$了就立即返回。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> rid = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>, sumw = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp[maxn], rcnt[<span class="number">1</span>&lt;&lt;rid], rmod = (<span class="number">1</span> &lt;&lt; rid) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rsort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">256</span>) &#123; sort(arr+<span class="number">1</span>, arr+n+<span class="number">1</span>); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">0</span>; i&lt;=<span class="number">31</span>; i+=rid) &#123;</span><br><span class="line"><span class="built_in">memset</span>(rcnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(rcnt));</span><br><span class="line"><span class="keyword">for</span>(rint k=<span class="number">1</span>; k&lt;=n; k++) rcnt[arr[k] &gt;&gt; i &amp; rmod]++;</span><br><span class="line"><span class="keyword">for</span>(rint j=<span class="number">1</span>; j&lt;=rmod; j++) rcnt[j] += rcnt[j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(rint k=n; k&gt;=<span class="number">1</span>; k--) temp[rcnt[(arr[k] &gt;&gt; i &amp; rmod)]--] = arr[k];</span><br><span class="line"><span class="built_in">memcpy</span>(arr, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">sumw += nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[maxn], dist[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs(ev[i], x, mid);</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[ev[i]] + ew[i] &gt;= mid) res++;</span><br><span class="line"><span class="keyword">else</span> arr[++tot] = dist[ev[i]] + ew[i];</span><br><span class="line">&#125;</span><br><span class="line">rsort(arr, tot), dist[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>, j=tot, last=tot; i &lt;= j; i++, j--, res++) &#123;</span><br><span class="line"><span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] + arr[j] &lt; mid) dist[x] = arr[i++];</span><br><span class="line"><span class="keyword">if</span>(i == j) &#123; dist[x] = arr[last]; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(j &amp;&amp; arr[i] + arr[j<span class="number">-1</span>] &lt; mid) last = j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxd, dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x], y=ev[i]; i; i=nxt[i], y=ev[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs2(y, x), maxd = max(maxd, dp[x] + dp[y] + ew[i]);</span><br><span class="line">dp[x] = max(dp[x], dp[y] + ew[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line">dfs2(root, root);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = min(maxd, sumw / m);</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(root, root, mid) &gt;= m) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset版，在菊花图上效率很低，不过开了O2以后跑的飞快</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isnum(x) (<span class="meta-string">'0'</span> &lt;= (x) &amp;&amp; (x) &lt;= <span class="meta-string">'9'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sit multiset<span class="meta-string">&lt;int&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> tint&gt;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">readint</span><span class="params">(tint&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar(); x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; !isnum(ch); ch = getchar()) <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; isnum(ch); ch = getchar()) x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">x *= f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sumw = <span class="number">0</span>, dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], ev[maxm], ew[maxm], nxt[maxm];</span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> nu, <span class="keyword">int</span> nv, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">ev[++totedge] = nv, ew[totedge] = nw, nxt[totedge] = head[nu];</span><br><span class="line">head[nu] = totedge;</span><br><span class="line">sumw += nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">res += dfs(ev[i], x, mid);</span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">dist[x] = <span class="number">0</span>, s.clear();</span><br><span class="line"><span class="keyword">for</span>(rint i=head[x]; i; i=nxt[i]) &#123;</span><br><span class="line"><span class="keyword">if</span>(ev[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[ev[i]] + ew[i] &gt;= mid) res++;</span><br><span class="line"><span class="keyword">else</span> s.insert(dist[ev[i]] + ew[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(sit it=s.begin(); it!=s.end() &amp;&amp; s.size();) &#123; <span class="comment">// nxt一定在it后面</span></span><br><span class="line">sit nxt = s.lower_bound(mid - (*it));</span><br><span class="line"><span class="keyword">if</span>(nxt == it &amp;&amp; nxt != s.end()) nxt++;</span><br><span class="line"><span class="keyword">if</span>(nxt == s.end()) &#123; it++; <span class="keyword">continue</span>; &#125;</span><br><span class="line">s.erase(nxt), s.erase(it++), res++; <span class="comment">// 注意先删nxt, 不然it++可能等于nxt</span></span><br><span class="line"><span class="keyword">if</span>(res &gt;= m) <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!s.empty()) dist[x] = *s.rbegin();</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> nu, nv, nw;</span><br><span class="line">readint(n), readint(m);</span><br><span class="line"><span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">readint(nu), readint(nv), readint(nw);</span><br><span class="line">addedge(nu, nv, nw), addedge(nv, nu, nw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = sumw / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dfs(root, root, mid) &gt;= m) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description:&quot;&gt;&lt;/a&gt;Description:&lt;/h4&gt;&lt;p&gt;给定一棵带权树，要求从树上划分出$m​$条不相交的路径，令“长度
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树的相关性质(更新中)</title>
    <link href="http://arintaro.com/2019/04/27/Algorithm/%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%E8%B4%A8/"/>
    <id>http://arintaro.com/2019/04/27/Algorithm/树的相关性质/</id>
    <published>2019-04-27T09:01:25.373Z</published>
    <updated>2019-04-27T10:18:53.945Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>本文大概会长期更新，并且大概率不会有图。</p><h4 id="一、树的直径"><a href="#一、树的直径" class="headerlink" title="一、树的直径"></a>一、树的直径</h4><h5 id="（一）求法：树形DP（不要求边权非负）、两次DFS"><a href="#（一）求法：树形DP（不要求边权非负）、两次DFS" class="headerlink" title="（一）求法：树形DP（不要求边权非负）、两次DFS"></a>（一）求法：树形DP（不要求边权非负）、两次DFS</h5><h5 id="（二）性质："><a href="#（二）性质：" class="headerlink" title="（二）性质："></a>（二）性质：</h5><ol><li>分析问题时，经常会把直径展开成一条链，其他子树在其下面，就像基环树把唯一的环作为广义根节点一样，本文下面所提的性质，大多基于“边权非负“这一前提条件，应用时请注意。</li><li>任意一个节点作根，直径两端点一定是叶子节点。</li><li>距离任意点最远的点一定是直径的一个端点。（相当有用的性质<ul><li>设从A出发找到最远点B</li><li>如果A已经是直径上一个端点，正确性显然。</li><li>如果不是，考虑反证，设直径为CD。</li><li>由于树必然联通，一定存在一条路径能从AB上一点E到达CD上一点F（可能E、F是同一个点。</li><li>则有$AE+ EB &gt; AE + EF + FD​$，推出$EB &gt; EF + FD​$，则有$CB = CF + FE + EB &gt; CF + FE + EF + FD &gt; CF + FD = CD​$，（注意，这里利用了放缩条件$FE + EF &gt; 0​$），与假设矛盾，故假设不成立。</li></ul></li><li>树可能会有多个直径，但是一定会有一条路径（也可能是一个点）的公共部分，且在这部分两侧的长度一定相等。<ul><li>显然，若存在两直径不相交，我们把其连接起来会得到一条更长的路径。</li><li>如果存在两条两侧长度不等的直径，由于它们总长一定相等，我们可以在两侧分别找到它们分出来较长的部分，一接又能得到一条更长的路径。</li></ul></li><li>对于两棵树，用一条边连接它们，新的直径的端点一定是原两颗树直径的端点。<ul><li>如果直径还在一棵树中显然，不在的话基于性质2，也相当显然。</li></ul></li><li>往一棵树里加一个点，直径的端点最多改变一个<ul><li>先不考虑加进来的边权，因为另一端无论找到什么点，都会累加这个边权，所以问题即转化为：在没加之前，距它的父节点距离最远的点，再次应用性质三，显然成立。</li></ul></li></ol><h5 id="（三）在具体题目下的性质证明"><a href="#（三）在具体题目下的性质证明" class="headerlink" title="（三）在具体题目下的性质证明"></a>（三）在具体题目下的性质证明</h5><ol><li>NOIP 2007 树网的核 （由于没有图，这部分很难懂，建议画图，<del>然而原题不要求证明这些东西</del><ul><li>在任意直径上求最小偏心距都相等</li><li>考虑任意两条直径，由于性质4，两侧长度都相等，关于给定长度$s$的限制条件显然是等价的，接下来只需讨论两条直径因为“位置”的不同而导致的答案优劣即可。</li><li>考虑两条求出最小偏心距不相等的直径中答案更劣的那一条，那么在答案更优的那条的“私有部分”上（不在性质4提到的公共部分上），一定存在一个导致这条答案变劣的子树，即离这条最优的核最远的点在这个子树上。根据直径的最长性，到这个子树上最远点的距离是显然没到更优的直径端点长的，矛盾。所以不存在答案更劣的，所以最小偏心距都相等。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;本文大概会长期更新，并且大概率不会有图。&lt;/p&gt;
&lt;h4 id=&quot;一、树的直径&quot;&gt;&lt;a href=&quot;#一、树的直径&quot; class=&quot;headerlink&quot; title=&quot;一、树的直径&quot;&gt;&lt;/a&gt;一、树的直径&lt;/h4&gt;&lt;h5 id=&quot;（一）
      
    
    </summary>
    
      <category term="算法" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="图论" scheme="http://arintaro.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://arintaro.com/2019/04/27/Template/%E5%B0%8F%E5%B7%A5%E5%85%B7/log2%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <id>http://arintaro.com/2019/04/27/Template/小工具/log2的姿势/</id>
    <published>2019-04-27T09:01:25.331Z</published>
    <updated>2019-04-26T08:25:22.435Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-转double法"><a href="#1-转double法" class="headerlink" title="1.转double法"></a>1.转double法</h5><p>double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不妨直接右移52位找到符号位，然后用&amp;63取出即可，然而编译器不会让你右移一个double，所以需要(lint&amp;)，强制让编译器把t当作lint处理，复杂度你从代码也可以看出来，几乎是$O(1)$的。<br>请注意，最后是否+1有时候根据编译器的不同会有不同的结果，我在NOI Linux与DevC++上测试均需要+1，考试用前请稍微测试一下。（一般来说手玩2 7 8 9即可）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">mlog2</span><span class="params">(lint x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> t = (<span class="keyword">double</span>)x;</span><br><span class="line">    <span class="keyword">return</span> (lint)((lint&amp;)t &gt;&gt; <span class="number">52</span> &amp; <span class="number">63</span>) + <span class="number">1</span>; <span class="comment">// 注意最前面还要再转一次long long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Luogu ST表 传统打表法 1011ms <a href="https://www.luogu.org/recordnew/show/13493959" target="_blank" rel="noopener">https://www.luogu.org/recordnew/show/13493959</a><br>Luogu ST表 double法 1009ms <a href="https://www.luogu.org/recordnew/show/18155615" target="_blank" rel="noopener">https://www.luogu.org/recordnew/show/18155615</a><br>实测后发现速度差异不大, 开了O2打表会快一些</p><h5 id="2-打表法"><a href="#2-打表法" class="headerlink" title="2.打表法"></a>2.打表法</h5><p>显然我们可以对值域内的所有整数打表，但是如果数据较大，且只查2的指数，可以利用这样的一个结论</p><p>$$\forall k \in [0,35], 2^kmod\ 37,\ 取遍[1,36]​$$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test site: https://www.luogu.org/problemnew/show/P3865</span></span><br><span class="line"><span class="comment">// 要求：实现函数mlog2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> readint(x) scanf(<span class="meta-string">"%d"</span>,&amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lint long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, logn;</span><br><span class="line"><span class="keyword">int</span> arr[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> lint <span class="title">mlog2</span><span class="params">(lint x)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rmq[<span class="number">20</span>][maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getrmq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) rmq[<span class="number">0</span>][i] = arr[i];</span><br><span class="line">    <span class="keyword">for</span>(rint d=<span class="number">1</span>; d&lt;=logn; d++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="number">1</span> &lt;&lt; d), half = (<span class="number">1</span> &lt;&lt; (d<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">for</span>(rint i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=n; i++) &#123;</span><br><span class="line">            rmq[d][i] = max(rmq[d<span class="number">-1</span>][i], rmq[d<span class="number">-1</span>][i+half]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loglen = mlog2(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(rmq[loglen][l], rmq[loglen][r-(<span class="number">1</span>&lt;&lt;loglen)+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readint(n), readint(m);</span><br><span class="line">    logn = <span class="built_in">ceil</span>(log2(n));</span><br><span class="line">    <span class="keyword">for</span>(rint i=<span class="number">1</span>; i&lt;=n; i++) readint(arr[i]);</span><br><span class="line">    getrmq();</span><br><span class="line">    <span class="keyword">int</span> nl, nr;</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        readint(nl), readint(nr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(nl,nr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-转double法&quot;&gt;&lt;a href=&quot;#1-转double法&quot; class=&quot;headerlink&quot; title=&quot;1.转double法&quot;&gt;&lt;/a&gt;1.转double法&lt;/h5&gt;&lt;p&gt;double储存数的方式是[0,51]尾数位，52位后是指数位与符号位，那不
      
    
    </summary>
    
    
  </entry>
  
</feed>
